"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const diff_1 = require("./diff");
const types_1 = require("./types");
function cloneAction(action) {
    const parent = action.parent;
    const children = action.children;
    const subtreeDigest = action.subtreeDigest;
    action.parent = undefined;
    action.children = [];
    action.subtreeDigest = 'unknown';
    const result = JSON.parse(JSON.stringify(action));
    action.parent = parent;
    action.children = children;
    action.subtreeDigest = subtreeDigest;
    return result;
}
function buildDiffDiagram(diff) {
    const diffActionsByAction = new Map();
    const buildActions = (state) => {
        const lAction = diff.baseActions[state.lNode];
        const rAction = diff.headActions[state.rNode];
        switch (state.moveType) {
            case diff_1.MoveType.AdvanceBoth: {
                const action = cloneAction(rAction);
                if (rAction.parent) {
                    const parent = diffActionsByAction.get(rAction.parent);
                    parent === null || parent === void 0 ? void 0 : parent.children.push(action);
                    action.parent = parent;
                }
                diffActionsByAction.set(rAction, action);
                diffActionsByAction.set(lAction, action);
                return action;
            }
            case diff_1.MoveType.Change: {
                const action = cloneAction(rAction);
                action.diffMode = types_1.DiffMode.Change;
                action.formerName = (0, types_1.nodeName)(lAction);
                action.formerResult = (0, types_1.nodeResult)(lAction);
                if (rAction.parent) {
                    const parent = diffActionsByAction.get(rAction.parent);
                    parent === null || parent === void 0 ? void 0 : parent.children.push(action);
                    action.parent = parent;
                }
                diffActionsByAction.set(rAction, action);
                diffActionsByAction.set(lAction, action);
                return action;
            }
            case diff_1.MoveType.DeleteLeft: {
                const action = cloneAction(lAction);
                action.diffMode = types_1.DiffMode.Delete;
                action.digest = ['delete', action.digest].join(':');
                // The parent of a deleted action is the cloned action of:
                //
                //   a) If the deleted action is a child of a deleted action, the deleted action's parent.
                //      Append to the children.
                //   b) If the deleted action is not a child of a deleted action, the Head equivalent of the
                //      deleted action's parent.
                // Case a)
                const deletedActionsParent = () => {
                    if (!lAction.parent)
                        return undefined;
                    return diffActionsByAction.get(lAction.parent);
                };
                // Case b)
                const headEquivalentOfDeletedActionsParent = () => {
                    if (!(rAction === null || rAction === void 0 ? void 0 : rAction.parent))
                        return undefined;
                    return diffActionsByAction.get(rAction.parent);
                };
                const parent = deletedActionsParent() || headEquivalentOfDeletedActionsParent();
                if (parent) {
                    parent.children.splice(parent.children.length, 0, action);
                    action.parent = parent;
                }
                diffActionsByAction.set(lAction, action);
                return action;
            }
            case diff_1.MoveType.InsertRight: {
                const action = cloneAction(rAction);
                action.diffMode = types_1.DiffMode.Insert;
                if (rAction.parent) {
                    const parent = diffActionsByAction.get(rAction.parent);
                    parent === null || parent === void 0 ? void 0 : parent.children.push(action);
                    action.parent = parent;
                }
                diffActionsByAction.set(rAction, action);
                return action;
            }
        }
    };
    const actions = diff.moves.map((state) => buildActions(state));
    const uniqueActorIds = new Set();
    const actors = [];
    actions
        .map((action) => (0, types_1.actionActors)(action))
        .flat()
        .filter(Boolean)
        .forEach((actor) => {
        if (!actor)
            throw Error('actor not found');
        if (!uniqueActorIds.has(actor.id)) {
            uniqueActorIds.add(actor.id);
            actors.push(actor);
        }
    });
    actors.sort((a, b) => a.order - b.order);
    const rootActions = actions.filter((action) => !action.parent);
    return {
        actors,
        rootActions,
    };
}
exports.default = buildDiffDiagram;
