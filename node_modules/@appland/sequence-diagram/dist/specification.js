"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const priority_1 = __importDefault(require("./priority"));
class Specification {
    constructor(priority, includedCodeObjectIds, requiredCodeObjectIds) {
        this.priority = priority;
        this.includedCodeObjectIds = includedCodeObjectIds;
        this.requiredCodeObjectIds = requiredCodeObjectIds;
        this.loops = true;
    }
    get hasRequiredCodeObjects() {
        return this.requiredCodeObjectIds.size > 0;
    }
    priorityOf(codeObject) {
        return this.priority.priorityOf(codeObject);
    }
    isIncludedCodeObject(codeObject) {
        return Specification.matchCodeObject(this.includedCodeObjectIds, codeObject);
    }
    isRequiredCodeObject(codeObject) {
        return Specification.matchCodeObject(this.requiredCodeObjectIds, codeObject);
    }
    static build(appmap, options) {
        const excludeSet = new Set(options.exclude || []);
        const expandSet = new Set(options.expand || []);
        const includedCodeObjectIds = new Set();
        const hasNonPackageChildren = (co) => {
            if (co.type !== 'package')
                return true;
            return co.children.some((child) => child.type !== 'package');
        };
        const includeCodeObjects = (co) => {
            if (co.type === 'class' && co.packageObject && expandSet.has(co.packageObject.fqid)) {
                includedCodeObjectIds.add(co.fqid);
                co.children.forEach((child) => includeCodeObjects(child));
            }
            if (!this.DefaultActorTypes.includes(co.type))
                return;
            if (excludeSet.has(co.fqid))
                return;
            if (!expandSet.has(co.fqid) && hasNonPackageChildren(co))
                includedCodeObjectIds.add(co.fqid);
            co.children.forEach((child) => includeCodeObjects(child));
        };
        appmap.classMap.roots.forEach((root) => includeCodeObjects(root));
        const requiredCodeObjectIds = new Set(options.require || []);
        for (const coid of requiredCodeObjectIds) {
            includedCodeObjectIds.add(coid);
        }
        const priorityArg = options.priority || {};
        const priority = new priority_1.default();
        if (!Object.keys(priorityArg).includes('http:HTTP server requests'))
            priorityArg['http:HTTP server requests'] = 0;
        {
            const externalServices = [...includedCodeObjectIds]
                .filter((coid) => coid.split(':')[0] === 'external-service')
                .sort();
            externalServices.push('database:Database');
            for (let index = 0; index < externalServices.length; index++) {
                const service = externalServices[index];
                if (!Object.keys(priorityArg).includes(service))
                    priorityArg[service] = (includedCodeObjectIds.size + index + 1) * 1000;
            }
        }
        Object.entries(priorityArg || {}).forEach((entry) => priority.setPriority(entry[0], entry[1]));
        const spec = new Specification(priority, includedCodeObjectIds, requiredCodeObjectIds);
        spec.loops = !!options.loops;
        return spec;
    }
    static matchCodeObject(codeObjectIds, codeObject) {
        let co = codeObject;
        while (co) {
            if (codeObjectIds.has(co.fqid)) {
                return co;
            }
            co = co.parent;
        }
    }
}
exports.default = Specification;
Specification.DefaultActorTypes = [
    'package',
    'database',
    'http',
    'external-service',
];
