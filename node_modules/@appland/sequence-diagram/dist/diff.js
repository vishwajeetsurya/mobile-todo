"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Move = exports.MoveType = void 0;
const priority_queue_1 = require("@datastructures-js/priority-queue");
const types_1 = require("./types");
var MoveType;
(function (MoveType) {
    MoveType[MoveType["AdvanceBoth"] = 1] = "AdvanceBoth";
    MoveType[MoveType["DeleteLeft"] = 2] = "DeleteLeft";
    MoveType[MoveType["InsertRight"] = 3] = "InsertRight";
    MoveType[MoveType["Change"] = 4] = "Change";
})(MoveType = exports.MoveType || (exports.MoveType = {}));
const Costs = new Map();
Costs.set(MoveType.AdvanceBoth, 0);
Costs.set(MoveType.Change, 1.0);
Costs.set(MoveType.InsertRight, 2.0);
Costs.set(MoveType.DeleteLeft, 2.0);
class Move {
    constructor(position, moveType) {
        this.moveType = moveType;
        this.lNode = position.lNode;
        this.rNode = position.rNode;
        const cost = Costs.get(moveType);
        if (cost === undefined)
            throw Error(`No cost for ${moveType}`);
        this.cost = cost;
    }
}
exports.Move = Move;
function positionKey(position) {
    return `${position.lNode},${position.rNode}`;
}
function moveTypeName(moveType) {
    switch (moveType) {
        case MoveType.AdvanceBoth:
            return 'advance both';
        case MoveType.DeleteLeft:
            return 'delete left';
        case MoveType.InsertRight:
            return 'insert right';
        case MoveType.Change:
            return 'change';
    }
}
/**
 * Start with the graph state (-1, -1) of each Diagram.
 * Enqueue moves from the inital state.
 * Pull the lowest cost move from the queue
 *    If the known cost to the new location is undefined, or if the cost via this move is less than the known cost
 *      Store the step to the new state
 *      Store the total cost as the minimum cost
 *      Enqueue the possible next moves
 */
function diff(baseDiagram, headDiagram, diffOptions = {}) {
    var _a, _b;
    const buildActions = (diagram) => {
        const result = [];
        const collectAction = (action) => {
            result.push(action);
            action.children.forEach((child) => collectAction(child));
        };
        diagram.rootActions.forEach((action) => collectAction(action));
        return result;
    };
    const lActions = buildActions(baseDiagram);
    const rActions = buildActions(headDiagram);
    const advance = (diagram, action) => {
        if (action < diagram.length)
            return action + 1;
    };
    const advanceBoth = (move) => {
        const [lNode, rNode] = [advance(lActions, move.lNode), advance(rActions, move.rNode)];
        if (lNode === undefined || rNode === undefined)
            return;
        const lDigest = digestOf(lActions, lNode);
        const rDigest = digestOf(rActions, rNode);
        // Advancing both is only a legal move if both resulting actions have the same digest.
        if (lDigest !== rDigest)
            return;
        return new Move({
            lNode: lNode,
            rNode: rNode,
        }, MoveType.AdvanceBoth);
    };
    const change = (move) => {
        var _a, _b, _c, _d;
        const [lNode, rNode] = [advance(lActions, move.lNode), advance(rActions, move.rNode)];
        // The change can't move beyond the bounds of the graph.
        if (lNode === undefined || rNode === undefined)
            return;
        // The change needs to originate from the same actor.
        if (((_a = (0, types_1.actionActors)(lActions[move.lNode])[0]) === null || _a === void 0 ? void 0 : _a.id) !== ((_b = (0, types_1.actionActors)(rActions[move.rNode])[0]) === null || _b === void 0 ? void 0 : _b.id))
            return;
        // The change cannot change the type of the node.
        if (((_c = lActions[lNode]) === null || _c === void 0 ? void 0 : _c.nodeType) !== ((_d = rActions[rNode]) === null || _d === void 0 ? void 0 : _d.nodeType))
            return;
        return new Move({
            lNode: lNode,
            rNode: rNode,
        }, MoveType.Change);
    };
    const deleteLeft = (move) => {
        const lNode = advance(lActions, move.lNode);
        if (lNode === undefined)
            return;
        return new Move({ lNode: lNode, rNode: move.rNode }, MoveType.DeleteLeft);
    };
    const insertRight = (move) => {
        const rNode = advance(rActions, move.rNode);
        if (rNode === undefined)
            return;
        return new Move({
            lNode: move.lNode,
            rNode: rNode,
        }, MoveType.InsertRight);
    };
    const digestOf = (actions, action) => {
        if (action === -1)
            return 'head';
        else if (action === actions.length)
            return 'tail';
        else
            return actions[action].digest;
    };
    /**
     * Possible moves are:
     * - If both nodes have the same digest, advance both nodes.
     * - If nodes have non-equal digest
     *    The left node is a removal
     *    The right node is an insertion
     */
    const possibleMoves = (move) => {
        return [advanceBoth(move), change(move), deleteLeft(move), insertRight(move)].filter(Boolean);
    };
    const pq = new priority_queue_1.MinPriorityQueue((entry) => entry.cost);
    const distances = new Map();
    const stateMoves = new Map();
    const statePreceding = new Map();
    const initialState = { lNode: -1, rNode: -1, moveType: MoveType.AdvanceBoth };
    possibleMoves(initialState).forEach((position) => pq.enqueue({ position, preceding: initialState, cost: position.cost }));
    while (!pq.isEmpty()) {
        const { position, preceding, cost: totalCost } = pq.dequeue();
        if (!position)
            throw Error('next position not found');
        if (position.lNode === lActions.length && position.rNode === rActions.length)
            break;
        if (distances.get(positionKey(position)) === undefined ||
            totalCost < distances.get(positionKey(position))) {
            if (diffOptions.verbose) {
                console.log(moveTypeName(position.moveType) +
                    ` from ${(0, types_1.nodeName)(lActions[preceding.lNode])}, ${(_a = rActions[preceding.rNode]) === null || _a === void 0 ? void 0 : _a.name} to ${(0, types_1.nodeName)(lActions[position.lNode])}, ${(_b = rActions[position.rNode]) === null || _b === void 0 ? void 0 : _b.name}`);
                console.log(`Min cost to ${positionKey(position)} is ${totalCost} via ${moveTypeName(position.moveType)} from ${positionKey(preceding)}`);
            }
            distances.set(positionKey(position), totalCost);
            stateMoves.set(positionKey(position), position.moveType);
            if (preceding)
                statePreceding.set(positionKey(position), positionKey(preceding));
            possibleMoves(position).forEach((newPosition) => pq.enqueue({
                position: newPosition,
                preceding: position,
                cost: totalCost + newPosition.cost,
            }));
        }
    }
    const moves = [];
    {
        let reachedState = [lActions.length - 1, rActions.length - 1].join(',');
        while (reachedState !== '-1,-1') {
            if (!reachedState)
                throw Error('reachedState not found');
            const [lNode, rNode] = reachedState.split(',').map(Number);
            const move = stateMoves.get(reachedState);
            const state = { lNode: lNode, rNode: rNode, moveType: move };
            moves.push(state);
            reachedState = statePreceding.get(reachedState);
        }
    }
    return { baseActions: lActions, headActions: rActions, moves: moves.reverse() };
}
exports.default = diff;
