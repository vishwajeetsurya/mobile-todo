"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.merge = void 0;
const sha256_js_1 = __importDefault(require("crypto-js/sha256.js"));
const lru_cache_1 = __importDefault(require("lru-cache"));
const types_1 = require("./types");
const sha256Cache = new lru_cache_1.default({ max: 3000 });
function buildDigest(actions) {
    const sha256Input = actions.map((action) => action.subtreeDigest).join('\n');
    let result = sha256Cache.get(sha256Input);
    if (!result) {
        result = (0, sha256_js_1.default)(sha256Input).toString();
        sha256Cache.set(sha256Input, result);
    }
    return result;
}
function countDigests(actions, windowSize) {
    const digestCount = new Map();
    for (let index = 0; index + windowSize <= actions.length; index++) {
        const range = actions.slice(index, index + windowSize);
        const digest = buildDigest(range);
        const count = digestCount.get(digest);
        if (count !== undefined)
            digestCount.set(digest, count + 1);
        else
            digestCount.set(digest, 1);
    }
    return digestCount;
}
const isMerge = (item) => item.constructor === Array;
const buildLoop = (merge) => {
    const digest = buildDigest(merge[0]);
    // Since we are going to use merge[0] as the children of the loop, the event ids and elapsed time from the
    // loop actions that will be discarded need to be merged into merge[0]. This needs to happen
    // recursively in order to avoid losing event ids and elapsed time data from nested loops.
    const aggregateLoopMemberData = (action, duplicates) => {
        action.eventIds = [...action.eventIds, ...duplicates.map((d) => d.eventIds).flat()].sort((a, b) => a - b);
        action.elapsed =
            (action.elapsed || 0) + duplicates.reduce((sum, d) => sum + (d.elapsed || 0), 0);
        action.children.forEach((child, index) => {
            aggregateLoopMemberData(child, duplicates.map((d) => d.children[index]));
        });
    };
    merge[0].forEach((member, index) => {
        aggregateLoopMemberData(member, merge.slice(1).map((m) => m[index]));
    });
    return {
        nodeType: types_1.NodeType.Loop,
        count: merge.length,
        digest: 'loop',
        subtreeDigest: ['loop', digest].join(':'),
        children: merge[0],
        elapsed: merge[0].reduce((sum, action) => sum + (action.elapsed || 0), 0),
        eventIds: [],
    };
};
const unroll = (items) => {
    const result = [];
    items.forEach((item) => {
        if (isMerge(item)) {
            if (item.length > 1)
                result.push(buildLoop(item));
            else
                result.push(...item[0]);
        }
        else
            result.push(item);
    });
    return result;
};
function merge(actions, windowSize) {
    const digestCount = countDigests(actions, windowSize);
    const digestsSorted = [...digestCount.keys()]
        .filter((key) => digestCount.get(key) > 1)
        .sort((a, b) => digestCount.get(b) - digestCount.get(a));
    if (digestsSorted.length === 0)
        return;
    for (let digestIndex = 0; digestIndex < digestsSorted.length; digestIndex++) {
        const referenceDigest = digestsSorted[digestIndex];
        const result = [];
        let merge = undefined;
        for (let actionIndex = 0; actionIndex + windowSize <= actions.length;) {
            const window = actions.slice(actionIndex, actionIndex + windowSize);
            const windowDigest = buildDigest(window);
            if (windowDigest === referenceDigest) {
                if (merge) {
                    merge.push(window);
                }
                else {
                    merge = [window];
                    result.push(merge);
                }
                actionIndex += windowSize;
            }
            else {
                merge = undefined;
                result.push(window[0]);
                actionIndex += 1;
            }
        }
        const hasLoop = result.filter((item) => isMerge(item) && item.length > 1).length > 0;
        if (hasLoop)
            return unroll(result);
    }
}
exports.merge = merge;
