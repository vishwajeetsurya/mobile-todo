"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.format = exports.extension = void 0;
const types_1 = require("../types");
exports.extension = '.txt';
function diffModeName(diffMode) {
    switch (diffMode) {
        case types_1.DiffMode.Change:
            return 'changed to';
        case types_1.DiffMode.Insert:
            return 'added';
        case types_1.DiffMode.Delete:
            return 'removed';
    }
}
function format(diagram, maxDepth = 4) {
    const lineCount = new Map();
    const lines = [];
    const describeChange = (action, depth = 1) => {
        if (depth > maxDepth)
            return;
        if (action.diffMode !== undefined) {
            const tokens = [];
            const actor = (0, types_1.actionActors)(action)[1];
            const normalizeName = (str) => {
                return str.replace(/\n/g, ' ');
            };
            const qualifyAction = (str) => {
                if (!actor)
                    return str;
                if ((0, types_1.isQuery)(action)) {
                    return ['SQL', ['', str, ''].join('`')].join(' ');
                }
                else if ((0, types_1.isClientRPC)(action)) {
                    return ['HTTP client request', ['', str, ''].join('`')].join(' ');
                }
                else if ((0, types_1.isServerRPC)(action)) {
                    return ['HTTP server request', ['', str, ''].join('`')].join(' ');
                }
                else {
                    const separator = (0, types_1.isFunction)(action) ? (action.static ? '.' : '#') : '#';
                    return ['function call', ['', [actor.name, str].join(separator), ''].join('`')].join(' ');
                }
            };
            if (action.diffMode === types_1.DiffMode.Change) {
                const formerName = action.formerName
                    ? qualifyAction(normalizeName(action.formerName))
                    : undefined;
                const currentName = (0, types_1.nodeName)(action)
                    ? qualifyAction(normalizeName((0, types_1.nodeName)(action)))
                    : undefined;
                const formerResult = action.formerResult ? normalizeName(action.formerResult) : undefined;
                const currentResult = (0, types_1.nodeResult)(action) ? normalizeName((0, types_1.nodeResult)(action)) : undefined;
                if (formerName !== currentName) {
                    tokens.push('changed');
                    tokens.push(formerName || 'undefined');
                    tokens.push('to');
                    tokens.push(currentName || 'undefined');
                }
                if (formerResult !== currentResult) {
                    if (tokens.length === 0) {
                        tokens.push('changed');
                        tokens.push(currentName || 'undefined');
                    }
                    else {
                        tokens.push('and');
                        tokens.push('changed');
                    }
                    tokens.push('to return');
                    tokens.push(currentResult || 'undefined');
                    tokens.push('instead of');
                    tokens.push(formerResult || 'undefined');
                }
            }
            else {
                tokens.push(diffModeName(action.diffMode));
                tokens.push(qualifyAction(normalizeName((0, types_1.nodeName)(action))));
            }
            if (tokens.length > 0) {
                const message = [new Array(depth).join('  '), tokens.join(' ')].join('');
                if (lineCount.has(message)) {
                    lineCount.set(message, lineCount.get(message) + 1);
                }
                else {
                    lineCount.set(message, 1);
                    lines.push(message);
                }
            }
            depth += 1;
        }
        action.children.forEach((child) => describeChange(child, depth));
    };
    diagram.rootActions.forEach((action) => describeChange(action));
    return lines
        .map((line) => {
        const count = lineCount.get(line);
        return count === 1 ? line : [`${count} times`, line].join(': ');
    })
        .join('\n');
}
exports.format = format;
