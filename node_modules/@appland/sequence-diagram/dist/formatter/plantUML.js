"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.format = exports.extension = void 0;
const diff_1 = require("diff");
const types_1 = require("../types");
const DisplayCharLimit = 50;
exports.extension = '.uml';
function formatElapsed(elapsed, markupEnabled) {
    const timeStr = () => {
        return `${+(elapsed * 1000).toPrecision(3)} ms`;
    };
    if (markupEnabled)
        return `<color:gray> ${timeStr()}</color>`;
    else
        return `(${timeStr()})`;
}
function singleLine(str) {
    return str.replace(/\n/g, '\\n').replace(/\s{2,}/g, ' ');
}
class Label {
    constructor(action) {
        this.action = action;
    }
    get actionNameIsTrimmed() {
        return (0, types_1.nodeName)(this.action).length > DisplayCharLimit;
    }
    requestLabel(markupEnabled) {
        const { action } = this;
        const label = singleLine((0, types_1.nodeName)(this.action)).slice(0, DisplayCharLimit);
        let formerLabel;
        if (action.formerName)
            formerLabel = singleLine(action.formerName).slice(0, DisplayCharLimit);
        const formattedLabel = this.formatDiffLabel(label, formerLabel);
        const tokens = [];
        // PlantUML / Creole doesn't successfully combine strikethrough with underline.
        // Only the underline ends up being rendered.
        if (markupEnabled && (0, types_1.isFunction)(action) && action.static && action.diffMode !== types_1.DiffMode.Delete)
            tokens.push('<u>');
        tokens.push(formattedLabel);
        if (markupEnabled && (0, types_1.isFunction)(action) && action.static && action.diffMode !== types_1.DiffMode.Delete)
            tokens.push('</u>');
        if (action.elapsed && action.diffMode !== types_1.DiffMode.Delete) {
            tokens.push(' ');
            tokens.push(formatElapsed(action.elapsed, markupEnabled));
        }
        return tokens.join('');
    }
    responseLabel(markupEnabled) {
        const response = actionResponse(this.action);
        if (!response)
            return;
        let label = (0, types_1.nodeResult)(this.action);
        if (!label)
            return;
        label = singleLine(label).slice(0, DisplayCharLimit);
        let formerLabel;
        if (this.action.formerResult)
            formerLabel = singleLine(this.action.formerResult).slice(0, DisplayCharLimit);
        const formattedLabel = this.formatDiffLabel(label, formerLabel);
        const tokens = [];
        if (markupEnabled && response.raisesException)
            tokens.push('<i>');
        tokens.push(formattedLabel);
        if (markupEnabled && response.raisesException)
            tokens.push('</i>');
        return tokens.join('');
    }
    note(foldLimit = 80) {
        const { action } = this;
        const label = fold((0, types_1.nodeName)(this.action), foldLimit);
        let formerLabel = [];
        if (action.formerName)
            formerLabel = fold(action.formerName, foldLimit);
        const result = [];
        for (let i = 0; i < Math.max(label.length, formerLabel.length); i += 1) {
            const line = this.formatDiffLabel(label[i], formerLabel[i]);
            result.push(line);
        }
        return result.join('\n');
    }
    formatDiffLabel(label, formerLabel) {
        const tokens = [];
        const addedSegment = (text) => {
            tokens.push(`<color:${Label.AddedColor}><back:${Label.AddedColorBackground}>`);
            tokens.push(text);
            tokens.push('</back></color>');
        };
        const removedSegment = (text) => {
            tokens.push(`<color:${Label.RemovedColor}><back:${Label.RemovedColorBackground}>--`);
            tokens.push(text);
            tokens.push('--</back></color>');
        };
        if (this.action.diffMode === types_1.DiffMode.Change && label && formerLabel && label !== formerLabel) {
            const diff = (0, diff_1.diffChars)(formerLabel, label);
            const changeCharsCount = diff.reduce((memo, change) => (change.added || change.removed ? memo + (change.count || 0) : memo), 0);
            if (changeCharsCount / Math.max(formerLabel.length, label.length) <
                Label.ChangedCharsThreshod) {
                for (const change of diff) {
                    if (change.removed) {
                        removedSegment(change.value);
                    }
                    else if (change.added) {
                        addedSegment(change.value);
                    }
                    else {
                        tokens.push(change.value);
                    }
                }
            }
            else {
                removedSegment(formerLabel);
                tokens.push(' ');
                addedSegment(label);
            }
        }
        else if (this.action.diffMode && label && formerLabel && label === formerLabel) {
            tokens.push(label);
        }
        else if (label) {
            if (this.action.diffMode) {
                this.action.diffMode === types_1.DiffMode.Delete ? removedSegment(label) : addedSegment(label);
            }
            else {
                tokens.push(label);
            }
        }
        return tokens.join('');
    }
}
Label.ChangedCharsThreshod = 0.25;
Label.GitHubDiffLightThemeRemovedColorBackground = '#FCECEA'; // [ 252, 236, 234 ];
Label.GitHubDiffLightThemeAddedColorBackground = '#EBFEEE'; // [ 235, 254, 238 ];
Label.GitHubDiffDarkThemeRemovedColorBackground = '#29201A'; // [ 41, 32, 26 ];
Label.GitHubDiffDarkThemeAddedColorBackground = '#172238'; // [ 23, 34, 56 ];
Label.RemovedColor = 'lightgray';
Label.AddedColor = 'lightgray';
Label.RemovedColorBackground = Label.GitHubDiffDarkThemeRemovedColorBackground;
Label.AddedColorBackground = Label.GitHubDiffDarkThemeAddedColorBackground;
function actionResponse(action) {
    return (0, types_1.isFunction)(action)
        ? action.returnValue
        : (0, types_1.isServerRPC)(action) || (0, types_1.isClientRPC)(action)
            ? { status: action.status, raisesException: action.status >= 400 }
            : undefined;
}
function alias(id) {
    return id.replace(/[^a-zA-Z0-9]/g, '_');
}
function color(action, markupEnabled) {
    if (!markupEnabled)
        return;
    switch (action.diffMode) {
        case types_1.DiffMode.Delete:
            return 'red';
        case types_1.DiffMode.Insert:
            return 'green';
        case types_1.DiffMode.Change:
            return 'CA9C3F';
    }
}
function arrowColor(tail, head, action, markupEnabled) {
    let c = color(action, markupEnabled);
    if (c) {
        c = ['[#', c, ']'].join('');
    }
    return [tail, c, head].filter(Boolean).join('');
}
function fold(line, limit) {
    const output = [];
    let buffer = '';
    line
        .split('\n')
        .map((line) => line.split(/\s+/))
        .flat()
        .forEach((word) => {
        if (buffer.length === 0) {
            buffer += word;
        }
        else if (buffer.length + word.length < limit) {
            buffer += ' ';
            buffer += word;
        }
        else {
            output.push(buffer);
            buffer = word;
        }
    });
    output.push(buffer);
    return output;
}
const requestArrow = (action, markupEnabled) => {
    const [caller, callee] = (0, types_1.actionActors)(action);
    let arrowTokens;
    if (caller && callee) {
        arrowTokens = { tail: '-', head: '>' };
    }
    else if (caller) {
        arrowTokens = { tail: '-', head: '>]' };
    }
    else {
        arrowTokens = { tail: '[-', head: '>' };
    }
    return arrowColor(arrowTokens.tail, arrowTokens.head, action, markupEnabled);
};
const responseArrow = (action, markupEnabled) => {
    const [caller, callee] = (0, types_1.actionActors)(action);
    let arrowTokens;
    if (caller && callee) {
        arrowTokens = { head: '<', tail: '--' };
    }
    else if (caller) {
        arrowTokens = { head: '<', tail: '--]' };
    }
    else {
        arrowTokens = { head: '[<', tail: '--' };
    }
    return arrowColor(arrowTokens.head, arrowTokens.tail, action, markupEnabled);
};
class EventLines {
    constructor() {
        this._indent = 1;
        this.lines = [];
    }
    indent() {
        this._indent += 1;
    }
    outdent() {
        this._indent -= 1;
    }
    printLeftAligned(...lines) {
        lines.forEach((line) => this.lines.push(line));
    }
    print(...lines) {
        lines.forEach((line) => this.lines.push([Array(this._indent).join('  '), line].join('')));
    }
}
function format(diagram, _source, options = {}) {
    const markupEnabled = options.disableMarkup !== true;
    const notesEnabled = options.disableNotes !== true;
    const events = new EventLines();
    const renderChildren = (action) => action.children.forEach((child) => renderAction(child));
    const renderAction = (action) => {
        events.indent();
        if ((0, types_1.isLoop)(action)) {
            const colorTag = color(action, markupEnabled) ? `#${color(action, markupEnabled)}` : '';
            let countStr = action.count.toString();
            if ((0, types_1.hasAncestor)(action, (action) => (0, types_1.isLoop)(action)))
                countStr = `~${countStr}`;
            const tokens = [`${countStr} times`];
            if (action.elapsed) {
                tokens.push(` ${formatElapsed(action.elapsed, markupEnabled)}`);
            }
            events.print(`Loop${colorTag} ${tokens.join('')}`);
            renderChildren(action);
            events.print(`End`);
        }
        else {
            const label = new Label(action);
            const actors = (0, types_1.actionActors)(action);
            {
                const incomingTokens = actors.map((actor) => (actor ? alias(actor.name) : ''));
                const arrow = requestArrow(action, markupEnabled);
                events.print([incomingTokens.join(arrow), label.requestLabel(markupEnabled)].join(': '));
            }
            {
                if (label.actionNameIsTrimmed && notesEnabled) {
                    events.print('Note right');
                    events.indent();
                    events.printLeftAligned(label.note(80));
                    events.outdent();
                    events.print('End note');
                }
            }
            const response = actionResponse(action);
            const doActivate = response && actors[1];
            if (doActivate) {
                if (!actors[1])
                    throw Error();
                events.print(`activate ${alias(actors[1].name)}`);
            }
            renderChildren(action);
            if (response) {
                const outgoingTokens = actors.map((actor) => (actor ? alias(actor.name) : ''));
                const arrow = responseArrow(action, markupEnabled);
                const responseLabel = label.responseLabel(markupEnabled);
                const tokens = [outgoingTokens.join(arrow)];
                if (responseLabel)
                    tokens.push(responseLabel);
                events.print(tokens.join(': '));
            }
            if (doActivate) {
                if (!actors[1])
                    throw Error();
                events.print(`deactivate ${alias(actors[1].name)}`);
            }
        }
        events.outdent();
    };
    diagram.rootActions.forEach((action) => renderAction(action));
    return `@startuml
!includeurl https://raw.githubusercontent.com/getappmap/plantuml-theme/main/appmap-theme.puml
${diagram.actors
        .map((actor) => `participant ${alias(actor.name)} as "${singleLine(actor.name)}"`)
        .join('\n')}
${events.lines.join('\n')}
@enduml`;
}
exports.format = format;
