"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getActors = void 0;
const openapi_1 = require("@appland/openapi");
const sha256_js_1 = __importDefault(require("crypto-js/sha256.js"));
const lru_cache_1 = __importDefault(require("lru-cache"));
const mergeWindow_1 = require("./mergeWindow");
const selectEvents_1 = require("./selectEvents");
const types_1 = require("./types");
const MAX_WINDOW_SIZE = 5;
const parsedSqlCache = new lru_cache_1.default({ max: 1000 });
const sha256Cache = new lru_cache_1.default({ max: 1000 });
class ActorManager {
    constructor(specification) {
        this.specification = specification;
        this._actorsByCodeObjectId = new Map();
        this._actors = [];
    }
    findOrCreateActor(event) {
        const actorCodeObject = this.specification.isIncludedCodeObject(event.codeObject);
        if (!actorCodeObject)
            throw Error('actor code object not found');
        const order = this.specification.priorityOf(actorCodeObject);
        const actorKey = actorCodeObject.fqid;
        let actor = this._actorsByCodeObjectId.get(actorKey);
        if (actor)
            return actor;
        actor = {
            id: actorCodeObject.fqid,
            name: actorCodeObject.name,
            order,
        };
        this._actors.push(actor);
        this._actorsByCodeObjectId.set(actorKey, actor);
        return actor;
    }
    getSortedActors() {
        return this._actors.sort((a, b) => a.order - b.order);
    }
}
function buildDiagram(_appmapFile, appmap, specification) {
    const events = (0, selectEvents_1.selectEvents)(appmap, specification);
    const actorManager = new ActorManager(specification);
    function buildRequest(caller, callee) {
        if ((callee === null || callee === void 0 ? void 0 : callee.httpServerRequest) && (callee === null || callee === void 0 ? void 0 : callee.httpServerResponse)) {
            if (!callee.route)
                throw Error('callee.route not found');
            const response = callee.httpServerResponse;
            return {
                nodeType: types_1.NodeType.ServerRPC,
                callee: actorManager.findOrCreateActor(callee),
                route: callee.route,
                status: response.status || response.status_code,
                digest: callee.buildStableHash(parsedSqlCache).digest(),
                subtreeDigest: 'undefined',
                children: [],
                elapsed: callee.elapsedTime,
                eventIds: [callee.id],
            };
        }
        else if ((callee === null || callee === void 0 ? void 0 : callee.httpClientRequest) && (callee === null || callee === void 0 ? void 0 : callee.httpClientResponse)) {
            if (!callee.route)
                throw Error('callee.route not found');
            const response = callee.httpClientResponse;
            return {
                nodeType: types_1.NodeType.ClientRPC,
                caller: caller ? actorManager.findOrCreateActor(caller) : undefined,
                callee: actorManager.findOrCreateActor(callee),
                route: callee.route,
                status: response.status || response.status_code,
                digest: callee.buildStableHash(parsedSqlCache).digest(),
                subtreeDigest: 'undefined',
                children: [],
                elapsed: callee.elapsedTime,
                eventIds: [callee.id],
            };
        }
        else if (callee === null || callee === void 0 ? void 0 : callee.sqlQuery) {
            const truncatedQuery = callee.sqlQuery.endsWith('...');
            return {
                nodeType: types_1.NodeType.Query,
                caller: caller ? actorManager.findOrCreateActor(caller) : undefined,
                callee: actorManager.findOrCreateActor(callee),
                query: callee.sqlQuery,
                digest: truncatedQuery ? 'truncatedQuery' : callee.buildStableHash(parsedSqlCache).digest(),
                subtreeDigest: 'undefined',
                children: [],
                elapsed: callee.elapsedTime,
                eventIds: [callee.id],
            };
        }
        else if (callee) {
            return {
                nodeType: types_1.NodeType.Function,
                caller: caller ? actorManager.findOrCreateActor(caller) : undefined,
                callee: actorManager.findOrCreateActor(callee),
                name: callee.codeObject.name,
                static: callee.codeObject.static,
                digest: callee.buildStableHash(parsedSqlCache).digest(),
                subtreeDigest: 'undefined',
                stableProperties: Object.assign({}, callee.stableProperties),
                returnValue: buildReturnValue(callee),
                children: [],
                elapsed: callee.elapsedTime,
                eventIds: [callee.id],
            };
        }
    }
    function buildReturnValue(callee) {
        var _a;
        const { returnEvent } = callee;
        if (!returnEvent)
            return;
        const voidReturn = {
            returnValueType: {
                name: 'void',
            },
            raisesException: false,
        };
        let returnValueType;
        const raisesException = ((_a = returnEvent.exceptions) === null || _a === void 0 ? void 0 : _a.length) > 0;
        if (!returnEvent.returnValue && !raisesException)
            return voidReturn;
        if (returnEvent.returnValue) {
            let propertyNames;
            if (returnEvent.returnValue.properties) {
                propertyNames = returnEvent.returnValue.properties
                    .map((p) => [p.name, p.class].join(':'))
                    .sort();
            }
            const typeName = (0, openapi_1.classNameToOpenAPIType)(returnEvent.returnValue.class, { strict: true }) ||
                returnEvent.returnValue.class;
            returnValueType = {
                name: typeName,
                properties: propertyNames,
            };
        }
        return {
            returnValueType,
            raisesException,
        };
    }
    const codeObjectIds = new Set();
    const codeObjectSequence = new Map();
    const requestStack = [];
    const rootActions = [];
    const eventStack = [];
    const allMessages = new Array();
    events.forEach((event) => {
        if (!codeObjectIds.has(event.codeObject.fqid)) {
            codeObjectSequence.set(event.codeObject.fqid, codeObjectSequence.size);
            codeObjectIds.add(event.codeObject.fqid);
        }
        if (event.isCall()) {
            eventStack.push(event);
            const caller = eventStack[eventStack.length - 2];
            const request = buildRequest(caller, event);
            if (request) {
                const parent = requestStack[requestStack.length - 1];
                if (parent) {
                    parent.children.push(request);
                }
                else {
                    rootActions.push(request);
                }
                allMessages.push(request);
            }
            requestStack.push(request);
        }
        else {
            requestStack.pop();
            eventStack.pop();
        }
    });
    // Combine the digests of children into the parent digest.
    // Do this recursively.
    const buildSubtreeDigests = (node) => {
        const hashEntries = [node.digest];
        node.children.forEach((child) => {
            buildSubtreeDigests(child);
            hashEntries.push(child.subtreeDigest);
        });
        const hashInput = hashEntries.join('\n');
        let sha256Digest = sha256Cache.get(hashInput);
        if (!sha256Digest) {
            sha256Digest = (0, sha256_js_1.default)(hashInput).toString();
            sha256Cache.set(hashInput, sha256Digest);
        }
        node.subtreeDigest = sha256Digest;
    };
    const detectLoops = (node) => {
        node.children.forEach((child) => detectLoops(child));
        if (node.children.length < 2)
            return;
        let windowSize = 1;
        while (windowSize <= MAX_WINDOW_SIZE) {
            const mergedChildren = (0, mergeWindow_1.merge)(node.children, windowSize);
            if (mergedChildren) {
                node.children = mergedChildren;
            }
            else {
                windowSize += 1;
            }
        }
    };
    rootActions.forEach((root) => buildSubtreeDigests(root));
    if (specification.loops)
        rootActions.forEach((root) => detectLoops(root));
    rootActions.forEach((root) => (0, types_1.setParent)(root));
    return {
        actors: actorManager.getSortedActors(),
        rootActions,
    };
}
exports.default = buildDiagram;
function getActors(appmap, specification) {
    const actorManager = new ActorManager(specification);
    const events = (0, selectEvents_1.selectEvents)(appmap, specification);
    events.forEach((event) => actorManager.findOrCreateActor(event));
    return actorManager.getSortedActors();
}
exports.getActors = getActors;
