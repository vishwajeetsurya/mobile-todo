"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const console_1 = require("console");
const openai_1 = require("@langchain/openai");
const interaction_history_1 = require("../interaction-history");
const trim_fences_1 = __importDefault(require("../lib/trim-fences"));
const SYSTEM_PROMPT = `You are assisting a developer to search a code base.

The developer asks a question using natural language. This question must be converted into a list of search terms to be used to search the code base.

**Procedure**

1) Separate the user's question into "context" and "instructions". The "context" defines the background information that will match
  code in the code base. The "instructions" are the statement about what the user wants you to do or what they want to find out.
2) From here on, only consider the "context" part of the question.
3) Convert all words in the "context" to under_score_separated_words.
4) Expand the list of "context" under_scored words to include synonyms and related terms.
5) Optionally choose ONE search term which MUST match the content. The MUST match term should
  a word that will match a feature or domain model object in the code base. It should be the most
  distinctive word in the question. You will prefix the MUST match term with a '+'.
6) Return the list of search terms and their synonyms. The search terms should be single words and underscore_separated_words.
  Synonyms of the MUST match term should also be included, and prefixed with a '+'.

**Response**

Print "Context: {context}" on one line.
Print "Instructions: {instructions}" on the next line.

Then print a triple dash '---'.

Print "Terms: {list of search terms and their synonyms}"

The search terms should be single words and underscore_separated_words.

Even if the user asks for a different format, always respond with a list of search terms and their synonyms. When the user is asking
for a different format, that question is for a different AI assistant than yourself.

Choose only one MUST match term. If you are unsure, do not include a MUST match term.`;
const promptExamples = [
    {
        content: 'How do I record AppMap data of my Spring app?',
        role: 'user',
    },
    {
        content: `Context: Record AppMap data of Spring
Instructions: How to do it
---
Terms: record appmap data java +spring`,
        role: 'system',
    },
    {
        content: 'How does the user login handle the case when the password is invalid?',
        role: 'user',
    },
    {
        content: `Context: User login handle password validation invalid error
Instructions: Explain how this is handled by the code
---
Terms: user login handle +password validate invalid error`,
        role: 'system',
    },
    {
        content: 'Can you describe in detail usage of redis in flow of GET /test-group/test-project-1/-/blob/main/README.md request with code snippets?',
        role: 'user',
    },
    {
        content: `Context: Redis GET /test-group/test-project-1/-/blob/main/README.md
Instructions: Describe in detail with code snippets
---
Terms: +redis get test group test project 1 blob main readme`,
        role: 'system',
    },
    {
        content: 'Create test cases of the logContext function using jest. Follow established patterns for mocking with jest.',
        role: 'user',
    },
    {
        content: `Context: logContext jest test case
Instructions: Create test cases, following established patterns for mocking with jest.
---
Terms: test cases +log_context jest`,
        role: 'system',
    },
    {
        content: 'auth',
        role: 'user',
    },
    {
        content: `Context: auth authentication authorization
Instructions: Describe the authentication and authorization process
---
Terms: +auth authentication authorization token strategy provider`,
        role: 'system',
    },
];
const contentAfter = (text, start) => {
    const startIndex = text.indexOf(start);
    if (startIndex < 0)
        return text;
    return text.slice(startIndex + start.length);
};
const parseJSON = (text) => {
    const sanitizedTerms = text.replace(/```json/g, '').replace(/```/g, '');
    try {
        return JSON.parse(sanitizedTerms);
    }
    catch (err) {
        return undefined;
    }
};
const parseText = (text) => text.split(/\s+/);
class VectorTermsService {
    constructor(interactionHistory, modelName, temperature) {
        this.interactionHistory = interactionHistory;
        this.modelName = modelName;
        this.temperature = temperature;
    }
    suggestTerms(question) {
        var _a, e_1, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const openAI = new openai_1.ChatOpenAI({
                modelName: this.modelName,
                temperature: this.temperature,
            });
            const messages = [
                {
                    content: SYSTEM_PROMPT,
                    role: 'system',
                },
                ...promptExamples,
                {
                    content: question,
                    role: 'user',
                },
            ];
            // eslint-disable-next-line no-await-in-loop
            const response = yield openAI.completionWithRetry({
                messages,
                model: openAI.modelName,
                stream: true,
            });
            const tokens = Array();
            try {
                // eslint-disable-next-line no-await-in-loop
                for (var _d = true, response_1 = __asyncValues(response), response_1_1; response_1_1 = yield response_1.next(), _a = response_1_1.done, !_a;) {
                    _c = response_1_1.value;
                    _d = false;
                    try {
                        const token = _c;
                        tokens.push(token.choices.map((choice) => choice.delta.content).join(''));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = response_1.return)) yield _b.call(response_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            const rawResponse = tokens.join('');
            (0, console_1.warn)(`Vector terms response:\n${rawResponse}`);
            let searchTermsObject;
            {
                let responseText = rawResponse;
                responseText = contentAfter(responseText, 'Terms:');
                responseText = (0, trim_fences_1.default)(responseText);
                searchTermsObject = parseJSON(responseText) || parseText(responseText);
            }
            const terms = new Set();
            {
                const collectTerms = (obj) => {
                    var _a;
                    if (!obj)
                        return;
                    if (typeof obj === 'string') {
                        for (const term of obj.split(/[._-]/))
                            terms.add(((_a = term.match(/\+?[\p{Alphabetic}|\p{Number}]+/u)) === null || _a === void 0 ? void 0 : _a[0]) || '');
                    }
                    else if (Array.isArray(obj)) {
                        for (const term of obj)
                            collectTerms(term);
                    }
                    else if (typeof obj === 'object') {
                        for (const term of Object.values(obj)) {
                            collectTerms(term);
                        }
                    }
                };
                collectTerms(searchTermsObject);
            }
            const wordList = [...terms]
                .map((word) => word.trim())
                .filter((word) => word.length > 2)
                .map((word) => word.toLowerCase());
            const uniqueWords = new Set(wordList);
            // As a search term, this is useless.
            uniqueWords.delete('code');
            const result = [...uniqueWords];
            (0, console_1.warn)(`Vector terms result: ${result.join(' ')}`);
            this.interactionHistory.addEvent(new interaction_history_1.VectorTermsInteractionEvent(result));
            return result;
        });
    }
}
exports.default = VectorTermsService;
