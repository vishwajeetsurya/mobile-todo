"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const openai_1 = require("@langchain/openai");
const interaction_history_1 = require("../interaction-history");
const SYSTEM_PROMPT = `**Programming language and framework detector**

A software developer is asking a question about a project. Your task is to determine which
language and frameworks the user is referring to in their question.

# About you**

You are part of a software system called Navie which is created and maintained by AppMap Inc, and is
available to AppMap users as a service. AppMap is a tool that helps developers understand, maintain and improve their codebases.
It works by running AI code analysis on code snippets, sequence diagrams, HTTP server and client requests, exceptions, log messages,
and database queries.

## About the user

The user is a software developer who is working on a project. They are asking a question about the project.

## Classification categories

Your job is to list the programming languages and frameworks that are mentioned in the question.

**Response**

* language: Always respond with a list of programming languages that are mentioned in the question.
  If no programming languages match the question, respond with the word "unknown".

* frameworks: Optionally respond with a list of frameworks that are mentioned in the question.
  If no frameworks match the question, omit the frameworks.

**Examples**

- language: Ruby
  frameworks: [ Rails ]

- language: Python
  frameworks: [ Django ]

- language: JavaScript
  frameworks: [ React, Angular, Vue ]

- language: Java
  frameworks: [ Spring, "Spring Boot", Quarkus ]

If no languages or frameworks are mentioned, respond with the word "unknown".
`;
class TechStackService {
    constructor(interactionHistory, modelName, temperature) {
        this.interactionHistory = interactionHistory;
        this.modelName = modelName;
        this.temperature = temperature;
    }
    detectTerms(question) {
        var _a, e_1, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const openAI = new openai_1.ChatOpenAI({
                modelName: this.modelName,
                temperature: this.temperature,
            });
            const messages = [
                {
                    content: SYSTEM_PROMPT,
                    role: 'system',
                },
                {
                    content: question,
                    role: 'user',
                },
            ];
            // eslint-disable-next-line no-await-in-loop
            const response = yield openAI.completionWithRetry({
                messages,
                model: openAI.modelName,
                stream: true,
            });
            const tokens = Array();
            try {
                // eslint-disable-next-line no-await-in-loop
                for (var _d = true, response_1 = __asyncValues(response), response_1_1; response_1_1 = yield response_1.next(), _a = response_1_1.done, !_a;) {
                    _c = response_1_1.value;
                    _d = false;
                    try {
                        const token = _c;
                        tokens.push(token.choices.map((choice) => choice.delta.content).join(''));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = response_1.return)) yield _b.call(response_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            const rawTerms = tokens.join('');
            const stopWords = ['language', 'frameworks', 'unknown'];
            const terms = rawTerms
                .split(/\s+/)
                .map((term) => term.trim().toLowerCase())
                .map((term) => term.replace(/[^a-zA-Z0-9-]/g, ''))
                .filter((term) => !stopWords.includes(term))
                .filter(Boolean);
            this.interactionHistory.addEvent(new interaction_history_1.TechStackEvent(terms));
            return terms;
        });
    }
}
exports.default = TechStackService;
