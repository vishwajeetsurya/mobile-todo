"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GENERATE_AGENT_PROMPT = void 0;
const interaction_history_1 = require("../interaction-history");
const prompt_1 = require("../prompt");
const lookup_context_service_1 = __importDefault(require("../services/lookup-context-service"));
exports.GENERATE_AGENT_PROMPT = `**Task: Generation of Code and Test Cases**

**About you**

Your name is Navie. You are code generation AI created and maintained by AppMap Inc, and are available to AppMap users as a service.

Your job is to generate code and test cases. Like a senior developer or architect, you have a deep understanding of the codebase.

**About the user**

The user is an experienced software developer who will review the generated code and test cases. You can expect the user to be proficient
in software development.

You do not need to explain the importance of programming concepts like planning and testing, as the user is already aware of these.

**Response Format**

Your solution must be provided as a series of code files and snippets that implement the desired functionality within the project 
code. Do not propose wrapping the project with other code, running the project in a different environment, wrapping the project with
shell commands, or other workarounds. Your solution must be suitable for use as a pull request to the project.

* Your response should be provided as series of code files and/or snippets that implement the desired functionality.
* You should emit code that is designed to solve the problem described by the user.
* To modify existing code, emit a code snippet that augments or replaces code in an existing file.
  Tell the user which file they need to modify.
* To create new code, emit a new file that can be added to the existing codebase. Tell the user where to add the new file.
* At the beginning of every patch file or code file you emit, you must print the path to the code file within the workspace.
* Limit the amount of text explanation you emit to the minimum necessary. The user is primarily interested in the code itself.
`;
class GenerateAgent {
    constructor(history, vectorTermsService, lookupContextService, applyContextService) {
        this.history = history;
        this.vectorTermsService = vectorTermsService;
        this.lookupContextService = lookupContextService;
        this.applyContextService = applyContextService;
        this.temperature = undefined;
    }
    perform(options, tokensAvailable) {
        return __awaiter(this, void 0, void 0, function* () {
            this.history.addEvent(new interaction_history_1.PromptInteractionEvent('agent', 'system', exports.GENERATE_AGENT_PROMPT));
            this.history.addEvent(new interaction_history_1.PromptInteractionEvent(prompt_1.PromptType.IssueDescription, 'system', (0, prompt_1.buildPromptDescriptor)(prompt_1.PromptType.IssueDescription)));
            const vectorTerms = yield this.vectorTermsService.suggestTerms(options.aggregateQuestion);
            const tokenCount = tokensAvailable();
            const context = yield this.lookupContextService.lookupContext(vectorTerms, tokenCount);
            lookup_context_service_1.default.applyContext(context, [], this.applyContextService, tokenCount);
        });
    }
    applyQuestionPrompt(question) {
        this.history.addEvent(new interaction_history_1.PromptInteractionEvent(prompt_1.PromptType.IssueDescription, 'user', (0, prompt_1.buildPromptValue)(prompt_1.PromptType.IssueDescription, question)));
    }
}
exports.default = GenerateAgent;
