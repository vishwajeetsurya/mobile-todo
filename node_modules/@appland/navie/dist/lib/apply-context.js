"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_SELECTION_FREQUENCY = void 0;
const console_1 = require("console");
const context_1 = require("../context");
const VERBOSE = process.env.DEBUG === 'true';
var ContextItemStatus;
(function (ContextItemStatus) {
    ContextItemStatus["OK"] = "ok";
    ContextItemStatus["SIMILAR_CONTENT"] = "similar_content";
    ContextItemStatus["ITEM_UNDEFINED"] = "item_undefined";
    ContextItemStatus["ITEM_TOO_BIG"] = "item_too_big";
})(ContextItemStatus || (ContextItemStatus = {}));
exports.DEFAULT_SELECTION_FREQUENCY = Object.entries({
    [context_1.ContextV2.ContextItemType.SequenceDiagram]: 1,
    [context_1.ContextV2.ContextItemType.CodeSnippet]: 5,
    [context_1.ContextV2.ContextItemType.DataRequest]: 2,
    [context_1.ContextV2.ContextItemType.HelpDoc]: 2,
}).reduce((map, [key, value]) => {
    map.set(key, value);
    return map;
}, new Map());
function applyContext(context, characterLimit, maxContentLength = characterLimit / 5, selectionFrequency = exports.DEFAULT_SELECTION_FREQUENCY, verbose = VERBOSE) {
    const itemTypeByIndex = Array();
    for (const [itemType, frequency] of selectionFrequency) {
        for (let i = 0; i < frequency; i += 1) {
            itemTypeByIndex.push(itemType);
        }
    }
    const availableContext = [...context];
    const roundSize = itemTypeByIndex.length;
    // Select items in a round-robin fashion, to ensure a mix of content types. Heuristically, we
    // want to see one sequence diagram, N code snippets, and M data requests. If we run out of
    // one type of content type, we'll continue adding the other types.
    let index = 0;
    const selectedContext = new Array();
    let availableItemCount = availableContext.length;
    while (availableItemCount > 0) {
        const itemType = index % roundSize;
        index += 1;
        let contextItem;
        const itemIndex = availableContext.findIndex((item) => (item === null || item === void 0 ? void 0 : item.type) === itemTypeByIndex[itemType]);
        if (itemIndex !== -1) {
            availableItemCount -= 1;
            contextItem = availableContext[itemIndex];
            availableContext[itemIndex] = undefined;
        }
        if (contextItem)
            selectedContext.push(contextItem);
    }
    let charsRemaining = characterLimit;
    (0, console_1.log)(`Remaining characters before context: ${charsRemaining}`);
    const appliedContext = new Array();
    const itemDescription = (contextItem) => [contextItem.type, context_1.ContextV2.isFileContextItem(contextItem) ? contextItem.location : undefined]
        .filter(Boolean)
        .join(' ');
    const addContextItem = (contextItem) => {
        var _a;
        // Don't consume too much of the character limit on a single item.
        if (contextItem.content.length > maxContentLength) {
            if (verbose) {
                (0, console_1.log)(`Skipping context item ${itemDescription(contextItem)} due to size. ${contextItem.content.length} > ${maxContentLength}`);
            }
            return ContextItemStatus.ITEM_TOO_BIG;
        }
        if (contextItem.type === context_1.ContextV2.ContextItemType.SequenceDiagram &&
            ((_a = appliedContext[appliedContext.length - 1]) === null || _a === void 0 ? void 0 : _a.type) === context_1.ContextV2.ContextItemType.SequenceDiagram) {
            if (verbose)
                (0, console_1.log)(`Skipping context item ${itemDescription(contextItem)} because the previous context item is also a sequence diagram.`);
            return ContextItemStatus.SIMILAR_CONTENT;
        }
        if (verbose)
            (0, console_1.log)(`Adding context item ${itemDescription(contextItem)} (${contextItem.content.length})`);
        charsRemaining -= contextItem.content.length;
        appliedContext.push(contextItem);
        return ContextItemStatus.OK;
    };
    let hasSequenceDiagramBeenAdded = false;
    const onlySequenceDiagramsRemaining = (i) => selectedContext
        .slice(i)
        .every((item) => item.type === context_1.ContextV2.ContextItemType.SequenceDiagram);
    for (let i = 0; i < selectedContext.length; i += 1) {
        const contextItem = selectedContext[i];
        const status = addContextItem(contextItem);
        if (status === ContextItemStatus.OK &&
            contextItem.type === context_1.ContextV2.ContextItemType.SequenceDiagram) {
            hasSequenceDiagramBeenAdded = true;
        }
        if (verbose)
            (0, console_1.log)(`Context item ${itemDescription(contextItem)} status: ${status}`);
        const contextItemsRemaining = selectedContext.length - i - 1;
        if (hasSequenceDiagramBeenAdded &&
            contextItemsRemaining > 1 &&
            onlySequenceDiagramsRemaining(i + 1)) {
            (0, console_1.log)(`Only sequence diagrams remain in the context, and at least one sequence diagram has already been added. No further context will be added.`);
            break;
        }
        if (charsRemaining <= 0) {
            (0, console_1.log)(`Characterlimit reached.`);
            break;
        }
    }
    (0, console_1.log)(`Added ${characterLimit - charsRemaining} characters out of a requested limit of ${characterLimit}.`);
    return appliedContext;
}
exports.default = applyContext;
