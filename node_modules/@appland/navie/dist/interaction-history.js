"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TechStackEvent = exports.ContextItemEvent = exports.HelpLookupEvent = exports.ContextLookupEvent = exports.CompletionEvent = exports.VectorTermsInteractionEvent = exports.PromptInteractionEvent = exports.ClassificationEvent = exports.AgentSelectionEvent = exports.isPromptEvent = exports.InteractionEvent = void 0;
const events_1 = __importDefault(require("events"));
const interaction_state_1 = __importDefault(require("./interaction-state"));
const prompt_1 = require("./prompt");
const message_1 = require("./message");
const SNIPPET_LENGTH = 800;
function contentSnippet(content, maxLength = SNIPPET_LENGTH) {
    if (content.length < maxLength)
        return content;
    return `${content.slice(0, maxLength)}... (${content.length})`;
}
class InteractionEvent {
    constructor(type) {
        this.type = type;
    }
}
exports.InteractionEvent = InteractionEvent;
function isPromptEvent(event) {
    return event.type === 'prompt';
}
exports.isPromptEvent = isPromptEvent;
class AgentSelectionEvent extends InteractionEvent {
    constructor(agent) {
        super('agentSelection');
        this.agent = agent;
    }
    get metadata() {
        return {
            type: this.type,
            agent: this.agent,
        };
    }
    get message() {
        return `[agentSelection] ${this.agent}`;
    }
    // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
    updateState(_state) { }
}
exports.AgentSelectionEvent = AgentSelectionEvent;
class ClassificationEvent extends InteractionEvent {
    constructor(classification) {
        super('classification');
        this.classification = classification;
    }
    get metadata() {
        return {
            type: this.type,
            classification: this.classification.map((label) => `${label.name}=${label.weight}`),
        };
    }
    get message() {
        return `[classification] ${this.classification
            .map((label) => `${label.name}=${label.weight}`)
            .join(', ')}`;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars, class-methods-use-this
    updateState(_state) { }
}
exports.ClassificationEvent = ClassificationEvent;
class PromptInteractionEvent extends InteractionEvent {
    constructor(name, role, content, prefix) {
        super('prompt');
        this.name = name;
        this.role = role;
        this.content = content;
        this.prefix = prefix;
    }
    get metadata() {
        return {
            type: this.type,
            role: this.role,
            name: this.name,
        };
    }
    get message() {
        return `[prompt] ${this.role}: ${contentSnippet(this.fullContent)}`;
    }
    get fullContent() {
        return [this.prefix, this.content].filter(Boolean).join(' ');
    }
    updateState(state) {
        state.messages.push({ content: this.fullContent, role: this.role });
    }
}
exports.PromptInteractionEvent = PromptInteractionEvent;
class VectorTermsInteractionEvent extends InteractionEvent {
    constructor(terms) {
        super('vectorTerms');
        this.terms = terms;
    }
    get metadata() {
        return {
            type: this.type,
            termCount: this.terms.length,
        };
    }
    get message() {
        return `[vectorTerms] ${this.terms.join(' ')}`;
    }
    updateState(state) {
        for (const term of this.terms)
            state.vectorTerms.push(term);
    }
}
exports.VectorTermsInteractionEvent = VectorTermsInteractionEvent;
class CompletionEvent extends InteractionEvent {
    constructor(model, temperature) {
        super('completion');
        this.model = model;
        this.temperature = temperature;
    }
    get metadata() {
        return {
            type: this.type,
            model: this.model,
            temperature: this.temperature,
        };
    }
    get message() {
        return `[completion] ${this.model} ${this.temperature}`;
    }
    updateState(state) {
        state.completionModel = this.model;
        state.completionTemperature = this.temperature;
    }
}
exports.CompletionEvent = CompletionEvent;
class ContextLookupEvent extends InteractionEvent {
    constructor(context) {
        super('contextLookup');
        this.context = context;
    }
    get contextAvailable() {
        return !!this.context;
    }
    get metadata() {
        return {
            type: this.type,
            contextAvailable: this.contextAvailable,
        };
    }
    get message() {
        if (!this.context)
            return `[contextLookup] not found`;
        const countByItemType = this.context.reduce((acc, item) => {
            var _a;
            acc.set(item.type, ((_a = acc.get(item.type)) !== null && _a !== void 0 ? _a : 0) + 1);
            return acc;
        }, new Map());
        const countByItemTypeStr = Array.from(countByItemType.entries())
            .map((entry) => `${entry[1]} ${entry[0]}`)
            .join(', ');
        return `[contextLookup] ${countByItemTypeStr}`;
    }
    updateState(state) {
        state.contextAvailable = this.context;
    }
}
exports.ContextLookupEvent = ContextLookupEvent;
class HelpLookupEvent extends InteractionEvent {
    constructor(help) {
        super('helpLookup');
        this.help = help;
    }
    get helpAvailable() {
        return !!this.help;
    }
    get metadata() {
        return {
            type: this.type,
            helpAvailable: this.helpAvailable,
        };
    }
    get message() {
        if (!this.help)
            return `[helpLookup] not found`;
        return `[helpLookup] ${this.help.length} items`;
    }
    updateState(state) {
        state.helpAvailable = this.help;
    }
}
exports.HelpLookupEvent = HelpLookupEvent;
class ContextItemEvent extends InteractionEvent {
    constructor(promptType, content, location) {
        super('contextItem');
        this.promptType = promptType;
        this.content = content;
        this.location = location;
    }
    get promptPrefix() {
        return prompt_1.PROMPTS[this.promptType].tagName;
    }
    get metadata() {
        const result = {
            type: this.type,
            promptType: this.promptType,
        };
        if (this.location)
            result.location = this.location;
        return result;
    }
    get message() {
        return [
            `[${this.promptPrefix}]`,
            this.location ? `${this.location}: ` : undefined,
            contentSnippet(this.content),
        ]
            .filter(Boolean)
            .join(' ');
    }
    updateState(state) {
        const content = [
            `[${this.promptPrefix}]`,
            [this.location, this.content].filter(Boolean).join(': '),
        ]
            .filter(Boolean)
            .join(' ');
        state.messages.push({ content, role: 'user' });
    }
}
exports.ContextItemEvent = ContextItemEvent;
class TechStackEvent extends InteractionEvent {
    constructor(terms) {
        super('techStack');
        this.terms = terms;
    }
    get metadata() {
        return {
            type: this.type,
            terms: this.terms,
        };
    }
    get message() {
        return `[techStack] ${this.terms.join(' ')}`;
    }
    updateState(state) {
        state.techStackTerms = this.terms;
    }
}
exports.TechStackEvent = TechStackEvent;
class InteractionHistory extends events_1.default {
    constructor() {
        super(...arguments);
        this.events = [];
    }
    // eslint-disable-next-line class-methods-use-this
    log(message) {
        console.log(message);
    }
    addEvent(event) {
        this.emit('event', event);
        this.events.push(event);
    }
    clear() {
        this.events.splice(0, this.events.length);
    }
    computeTokenSize() {
        const state = this.buildState();
        const tokenCharacters = state.messages
            .map((message) => message.content.length)
            .reduce((a, b) => a + b, 0);
        return Math.round(tokenCharacters / message_1.CHARACTERS_PER_TOKEN);
    }
    buildState() {
        const state = new interaction_state_1.default();
        for (const event of this.events) {
            event.updateState(state);
        }
        return state;
    }
}
exports.default = InteractionHistory;
