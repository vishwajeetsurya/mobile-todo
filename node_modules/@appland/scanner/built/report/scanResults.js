"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScanResults = void 0;
class DistinctItems {
    constructor() {
        this.members = {};
    }
    push(...items) {
        for (const item of items) {
            if (item === undefined)
                continue;
            const key = JSON.stringify(item);
            if (!(key in this.members))
                this.members[key] = item;
        }
    }
    [Symbol.iterator]() {
        return Object.values(this.members)[Symbol.iterator]();
    }
}
function collectMetadata(metadata) {
    var _a, _b;
    const uniqueApps = new DistinctItems();
    const uniqueLabels = new DistinctItems();
    const uniqueClients = new DistinctItems();
    const uniqueFrameworks = new DistinctItems();
    const uniqueGit = new DistinctItems();
    const uniqueLanguages = new DistinctItems();
    const uniqueRecorders = new DistinctItems();
    const uniqueExceptions = new DistinctItems();
    for (const item of metadata) {
        uniqueApps.push(item.app);
        uniqueLabels.push(...((_a = item.labels) !== null && _a !== void 0 ? _a : []));
        uniqueClients.push(item.client);
        uniqueFrameworks.push(...((_b = item.frameworks) !== null && _b !== void 0 ? _b : []));
        uniqueGit.push(item.git);
        uniqueLanguages.push(item.language);
        uniqueRecorders.push(item.recorder);
        uniqueExceptions.push(item.exception);
    }
    return {
        labels: [...uniqueLabels],
        apps: [...uniqueApps],
        clients: [...uniqueClients],
        frameworks: [...uniqueFrameworks],
        git: [...uniqueGit],
        languages: [...uniqueLanguages],
        recorders: [...uniqueRecorders],
        testStatuses: [],
        exceptions: [...uniqueExceptions],
    };
}
/**
 * ScannerSummary summarizes the results of the entire scan.
 * It's used for printing a user-friendly summary report, it's not used for machine-readable program output.
 */
class ScanResults {
    constructor(configuration = { checks: [] }, appMapMetadata = {}, findings = [], checks = []) {
        this.configuration = configuration;
        this.appMapMetadata = appMapMetadata;
        this.findings = findings;
        this.checks = checks;
        this.summary = {
            numAppMaps: Object.keys(appMapMetadata).length,
            numChecks: checks.length * Object.keys(appMapMetadata).length,
            rules: [...new Set(checks.map((check) => check.rule.id))].sort(),
            ruleLabels: [...new Set(checks.map((check) => check.rule.labels || []).flat())].sort(),
            numFindings: findings.length,
            appMapMetadata: collectMetadata(Object.values(appMapMetadata)),
        };
    }
    withFindings(findings) {
        return new ScanResults(this.configuration, this.appMapMetadata, findings, this.checks);
    }
    aggregate(sourceScanResults) {
        this.summary.numAppMaps += sourceScanResults.summary.numAppMaps;
        this.summary.numChecks += sourceScanResults.summary.numChecks;
        this.summary.rules = [...new Set(this.summary.rules.concat(sourceScanResults.summary.rules))];
        this.summary.ruleLabels = [
            ...new Set(this.summary.ruleLabels.concat(sourceScanResults.summary.ruleLabels)),
        ];
        this.summary.numFindings += sourceScanResults.summary.numFindings;
        // we don't need sourceScanResults.summary.appMetadata
        // appMapMetadata.Git may also contain secrets we don't want to transmit.
    }
}
exports.ScanResults = ScanResults;
