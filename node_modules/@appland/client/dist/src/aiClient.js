"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CodedError = void 0;
class CodedError extends Error {
    constructor(message, code) {
        super(message);
        this.code = code;
    }
}
exports.CodedError = CodedError;
class AIClient {
    constructor(socket, callbacks) {
        this.socket = socket;
        this.callbacks = callbacks;
        this.socket.on('exception', (error) => {
            this.panic(error);
        });
        // eslint-disable-next-line unicorn/prevent-abbreviations
        this.socket.onAny((data, ...args) => {
            var _a, _b;
            if (data === 'exception') {
                const { code, message } = args[0];
                const error = code ? new CodedError(message, code) : new Error(message);
                (_b = (_a = this.callbacks).onError) === null || _b === void 0 ? void 0 : _b.call(_a, error);
                return;
            }
            try {
                const message = JSON.parse(data);
                if (!('type' in message))
                    throw new Error('No message type');
                this.handleMessage(message).catch((error) => {
                    this.panic(error);
                });
            }
            catch (error) {
                this.panic(error);
            }
        });
    }
    async handleMessage(message) {
        var _a, _b, _c, _d;
        switch (message.type) {
            case 'ack':
                if (!('userMessageId' in message))
                    this.panic(new Error('Unexpected ack message: no userMessageId'));
                if (!('threadId' in message))
                    this.panic(new Error('Unexpected ack message: no threadId'));
                (_b = (_a = this.callbacks).onAck) === null || _b === void 0 ? void 0 : _b.call(_a, message.userMessageId, message.threadId);
                break;
            case 'token':
                if (!('token' in message))
                    this.panic(new Error('Unexpected token message: no token'));
                if (!('messageId' in message))
                    this.panic(new Error('Unexpected token message: no messageId'));
                this.callbacks.onToken(message.token, message.messageId);
                break;
            case 'request-context': {
                if (!this.callbacks.onRequestContext) {
                    this.panic(new Error('Unexpected request for context: no callback given'));
                }
                if (!('data' in message))
                    this.panic(new Error('Unexpected response: no data'));
                const data = message.data;
                const context = await ((_d = (_c = this.callbacks).onRequestContext) === null || _d === void 0 ? void 0 : _d.call(_c, data));
                this.socket.emit('message', JSON.stringify({ type: 'context', context }));
                break;
            }
            case 'end':
                this.callbacks.onComplete();
                this.disconnect();
                break;
            default:
                console.error(`Unknown message type ${message.type}`);
                console.warn(JSON.stringify(message));
        }
    }
    inputPrompt(input, options) {
        const question = typeof input === 'string' ? input : input.question;
        const prompt = {
            prompt: question,
            codeSelection: typeof input === 'string' ? undefined : input.codeSelection,
            threadId: options === null || options === void 0 ? void 0 : options.threadId,
            tool: options === null || options === void 0 ? void 0 : options.tool,
        };
        this.socket.emit('prompt', prompt);
    }
    panic(error) {
        var _a, _b;
        this.disconnect();
        (_b = (_a = this.callbacks).onError) === null || _b === void 0 ? void 0 : _b.call(_a, error);
    }
    disconnect() {
        this.socket.disconnect();
    }
}
exports.default = AIClient;
//# sourceMappingURL=aiClient.js.map