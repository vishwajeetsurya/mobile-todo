"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RetryCondition = void 0;
const buildRequest_1 = __importDefault(require("./buildRequest"));
const configuration_1 = require("./configuration");
exports.RetryCondition = Object.freeze({
    Timeout(_response, error) {
        if (error && typeof error === 'object' && 'code' in error) {
            const { code } = error;
            return ['ETIMEDOUT', 'EPIPE', 'ECONNRESET'].includes(code);
        }
        return false;
    },
    Status5xx(response) {
        return (response === null || response === void 0 ? void 0 : response.statusCode) && response.statusCode >= 500;
    },
});
function withDefaultOptions(options) {
    return Object.assign({ method: 'GET', authenticate: true, retry: {
            description: options.path,
            maxRetries: 3,
            retryDelay: 500,
        } }, options);
}
function shouldRetry(response, error) {
    return Object.values(exports.RetryCondition).some((condition) => condition(response, error));
}
function performRequest(options) {
    const requestOptions = withDefaultOptions(options);
    let query = '';
    if (requestOptions.query) {
        const searchParameters = new URLSearchParams();
        requestOptions.query.forEach(([key, value]) => searchParameters.append(key, value));
        query = `?${searchParameters.toString()}`;
    }
    const requestBuilder = (0, buildRequest_1.default)(requestOptions.path + query, {
        service: options.service || configuration_1.ServiceEndpoint.AppLandApi,
        requireApiKey: requestOptions.authenticate,
    });
    return new Promise((resolve, reject) => {
        let bodyContent = '';
        const additionalHeaders = {};
        if (requestOptions.body) {
            const { body } = requestOptions;
            const isUint8Array = body instanceof Uint8Array;
            const isBuffer = body instanceof Buffer;
            const isObject = typeof body === 'object';
            /* eslint-disable-next-line unicorn/prefer-ternary */
            if (isObject && !isUint8Array && !isBuffer) {
                bodyContent = JSON.stringify(body);
            }
            else {
                bodyContent = body.toString('utf-8');
            }
        }
        if (bodyContent) {
            additionalHeaders['Content-Length'] = Buffer.byteLength(bodyContent, 'utf-8').toString();
            additionalHeaders['Content-Type'] = 'application/json';
        }
        const request = requestBuilder.requestFunction(requestBuilder.url, {
            headers: Object.assign(Object.assign(Object.assign({}, additionalHeaders), requestOptions.headers), requestBuilder.headers),
            method: requestOptions.method,
        }, (response) => {
            let buf = '';
            response.on('data', (chunk) => {
                buf += chunk;
            });
            response.on('end', () => {
                if (!response.statusCode)
                    return reject(new Error('No status code'));
                return resolve({
                    statusCode: response.statusCode,
                    headers: response.headers,
                    body: Buffer.from(buf),
                    ok: response.statusCode >= 200 && response.statusCode < 300,
                });
            });
        });
        if (bodyContent)
            request.write(bodyContent, 'utf-8');
        request.on('error', (error) => {
            reject(error);
        });
        request.end();
    });
}
async function makeRequest(options) {
    const requestOptions = withDefaultOptions(options);
    let maxAttempts = 1;
    if (requestOptions.retry) {
        maxAttempts = (requestOptions.retry.maxRetries || 0) + 1;
    }
    let numberAttempts = 0;
    /* eslint-disable no-await-in-loop */
    for (;;) {
        let response;
        let error;
        try {
            response = await performRequest(options);
        }
        catch (error_) {
            error = error_;
        }
        numberAttempts += 1;
        if (!shouldRetry(response, error) || numberAttempts >= maxAttempts || !requestOptions.retry) {
            if (response)
                return response;
            throw error;
        }
        const nextAttempt = (requestOptions.retry.retryDelay || 500) * 2 ** (numberAttempts - 1);
        await new Promise((resolve) => {
            setTimeout(resolve, nextAttempt);
        });
    }
    /* eslint-enable no-await-in-loop */
}
exports.default = makeRequest;
//# sourceMappingURL=makeRequest.js.map