"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatHttpServerRequest = exports.formatValue = exports.prefixLines = exports.exists = exports.findFiles = exports.processNamedFiles = exports.processFiles = exports.ProcessFileOptions = exports.writeFileAtomic = exports.isFile = exports.mtime = exports.isCodedError = exports.baseName = exports.verbose = exports.endTime = void 0;
const fs_1 = require("fs");
const graceful_fs_1 = __importDefault(require("graceful-fs"));
const async_1 = require("async");
const util_1 = require("util");
const path_1 = require("path");
const assert_1 = __importDefault(require("assert"));
const promises_1 = require("fs/promises");
const StartTime = Date.now();
const renameFile = (0, util_1.promisify)(graceful_fs_1.default.rename);
function endTime() {
    return (Date.now() - StartTime) / 1000;
}
exports.endTime = endTime;
let isVerbose = false;
function verbose(v) {
    if (v !== undefined) {
        isVerbose = v;
    }
    return isVerbose;
}
exports.verbose = verbose;
function baseName(fileName) {
    return fileName.substring(0, fileName.length - '.appmap.json'.length);
}
exports.baseName = baseName;
async function statFile(filePath) {
    try {
        return await fs_1.promises.stat(filePath);
    }
    catch (e) {
        return null;
    }
}
function isCodedError(error) {
    if (!error.code)
        return false;
    return typeof error.code === 'string';
}
exports.isCodedError = isCodedError;
/**
 * Gets the last modified time of a file.
 *
 * @returns file mtime in ms, or null if the file does not exist or
 * is not a file.
 */
async function mtime(filePath) {
    // NB: 'ctime' is actually the time that the stats of the file were last changed.
    // And 'birthtime' is not guaranteed across platforms.
    // Therefore mtime is the most reliable indicator of when the file was created,
    // especially since we write files atomically (e.g. by moving them into place after writing them
    // as temp files).
    const fileStat = await statFile(filePath);
    if (!(fileStat === null || fileStat === void 0 ? void 0 : fileStat.isFile())) {
        return;
    }
    return fileStat.mtimeMs;
}
exports.mtime = mtime;
async function isFile(filePath) {
    const fileStat = await statFile(filePath);
    return !!(fileStat === null || fileStat === void 0 ? void 0 : fileStat.isFile());
}
exports.isFile = isFile;
/**
 * Atomically write a file by first writing to a temporary file in the same
 * directory then renaming in place.
 * @param dirName target directory path
 * @param fileName target file name
 * @param suffix used to create the temporary file name
 * @param data
 */
async function writeFileAtomic(dirName, fileName, suffix, data) {
    // first make sure the temp name isn't too long
    const NAME_MAX = 255; // note: might not be true on some esoteric systems
    const name = fileName.slice(0, NAME_MAX - suffix.length - 1);
    const tempFilePath = (0, path_1.join)(dirName, `${name}.${suffix}`);
    await fs_1.promises.writeFile(tempFilePath, data);
    await renameFile(tempFilePath, (0, path_1.join)(dirName, fileName));
}
exports.writeFileAtomic = writeFileAtomic;
class ProcessFileOptions {
    constructor() {
        this.fileCountFn = (_count) => { };
        this.errorFn = (err) => {
            process.stderr.write(err.toString() + '\n');
        };
        this.workerCount = 2;
    }
}
exports.ProcessFileOptions = ProcessFileOptions;
/**
 * Call a function with each matching file. No guarantee is given that
 * files will be processed in any particular order.
 */
async function processFiles(dir, extensionOrPredicate, fn, options = new ProcessFileOptions()) {
    const files = await findFiles(dir, extensionOrPredicate);
    options.fileCountFn(files.length);
    if (files.length === 0)
        return 0;
    const q = (0, async_1.queue)(fn, options.workerCount);
    q.error(options.errorFn);
    files.forEach((file) => q.push(file));
    if (!q.idle())
        await q.drain();
    return files.length;
}
exports.processFiles = processFiles;
/**
 * Finds all occurrances of `fileName` within a base directory. Each match must be a file, not a directory.
 * If a searched file is found, the sibling subdirectories are not recursed into.
 * This is optimized compared to `processFiles` because it does not use `glob`, which is pretty slow for this use case.
 * It also begins processing right away, rather than waiting for all files to be enumerated.
 */
async function processNamedFiles(baseDir, fileName, fn) {
    const q = (0, async_1.queue)(fn, 2);
    const stats = async (fileName) => {
        try {
            return await fs_1.promises.lstat(fileName);
        }
        catch (_a) {
            // Ignore
        }
    };
    let matchCount = 0;
    const processDir = async (dir) => {
        // If the directory contains the target fileName, add it to the process queue and return.
        const targetFileName = (0, path_1.join)(dir, fileName);
        const target = await stats(targetFileName);
        if (target === null || target === void 0 ? void 0 : target.isFile()) {
            matchCount += 1;
            q.push(targetFileName);
            return;
        }
        // Otherwise, recurse on all subdirectories.
        let children;
        try {
            children = await (0, promises_1.readdir)(dir);
        }
        catch (err) {
            children = [];
        }
        for (const childName of children) {
            const child = await stats((0, path_1.join)(dir, childName));
            if (child === null || child === void 0 ? void 0 : child.isDirectory()) {
                await processDir((0, path_1.join)(dir, childName));
            }
        }
    };
    await processDir(baseDir);
    q.error(console.warn);
    if (!q.idle())
        await q.drain();
    return matchCount;
}
exports.processNamedFiles = processNamedFiles;
/**
 * Lists all matching files in a directory, and passes them to an optional function.
 */
async function findFiles(directory, extensionOrPredicate, fn) {
    const printDebug = verbose();
    if (printDebug) {
        console.warn(`Scanning ${directory} for files matching ${extensionOrPredicate}`);
    }
    const matchFile = async (file) => {
        if (typeof extensionOrPredicate === 'string') {
            return file.endsWith(extensionOrPredicate);
        }
        else {
            return await extensionOrPredicate(file);
        }
    };
    const traverseDirectory = async (dir, result = new Array()) => {
        let files;
        try {
            files = await (0, promises_1.readdir)(dir);
        }
        catch (err) {
            const code = err.code;
            if (code === 'ENOENT')
                return result;
            throw err;
        }
        for (const file of files) {
            const path = (0, path_1.join)(dir, file);
            let stat;
            try {
                stat = await fs_1.promises.stat(path);
            }
            catch (err) {
                const code = err.code;
                if (code === 'ENOENT')
                    return result;
                throw err;
            }
            if (stat.isDirectory()) {
                await traverseDirectory(path, result);
            }
            else if (stat.isFile() && (await matchFile(path))) {
                if (fn)
                    await fn(path);
                result.push(path);
            }
        }
        return result;
    };
    return await traverseDirectory(directory);
}
exports.findFiles = findFiles;
function exists(path) {
    return new Promise((resolve) => {
        fs_1.promises
            .access(path, fs_1.constants.R_OK)
            .then(() => {
            resolve(true);
        })
            .catch(() => {
            resolve(false);
        });
    });
}
exports.exists = exists;
/**
 * Append a prefix to each line in a string
 * @param str the string to be prefixed
 * @param prefix a string to prefix each line with
 * @returns the resulting string which starts each line with a prefix
 */
function prefixLines(str, prefix) {
    return str.replace(/^/gm, prefix);
}
exports.prefixLines = prefixLines;
function formatValue(value) {
    if ((value === null || value === void 0 ? void 0 : value.value) === null || (value === null || value === void 0 ? void 0 : value.value) === undefined) {
        return 'Null';
    }
    const valueStr = value.value.startsWith('#<') ? null : value.value;
    return [value.class, valueStr].filter((e) => e).join(' ');
}
exports.formatValue = formatValue;
function formatHttpServerRequest(event) {
    (0, assert_1.default)(event.httpServerRequest);
    const data = {
        method: event.httpServerRequest.request_method,
        path: event.httpServerRequest.normalized_path_info || event.httpServerRequest.path_info,
        statusCode: event.returnEvent && event.httpServerResponse
            ? event.httpServerResponse['status_code'] || event.httpServerResponse.status
            : '<none>',
    };
    return [data.method, data.path, `(${data.statusCode})`].join(' ');
}
exports.formatHttpServerRequest = formatHttpServerRequest;
//# sourceMappingURL=utils.js.map