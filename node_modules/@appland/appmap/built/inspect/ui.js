"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const cli_progress_1 = __importDefault(require("cli-progress"));
const yargs_1 = __importDefault(require("yargs"));
const readline_1 = __importDefault(require("readline"));
const context_1 = __importDefault(require("./context"));
const undoFilter_1 = __importDefault(require("./undoFilter"));
const filter_1 = __importDefault(require("./filter"));
const reset_1 = __importDefault(require("./reset"));
const print_1 = __importDefault(require("./print"));
const home_1 = __importDefault(require("./home"));
const assert_1 = __importDefault(require("assert"));
const navigate_1 = __importDefault(require("./navigate"));
class UI {
    constructor(appmapDir, codeObjectId) {
        this.appmapDir = appmapDir;
        this.codeObjectId = codeObjectId;
        this.context = new context_1.default(appmapDir, codeObjectId);
    }
    async start() {
        await this.search();
        this.rl = readline_1.default.createInterface({
            input: process.stdin,
            output: process.stdout,
        });
        this.rl.on('close', function () {
            yargs_1.default.exit(0, new Error());
        });
        this.home();
    }
    getCommand() {
        (0, assert_1.default)(this.rl, 'readline is not initialized');
        console.log();
        this.rl.question('Command (h)ome, (p)rint, (f)ilter, (u)ndo filter, (r)eset filters, (n)avigate, (q)uit: ', (command) => {
            // eslint-disable-next-line default-case
            switch (command) {
                case 'h':
                    this.home();
                    break;
                case 'p':
                    this.print();
                    break;
                case 'f':
                    this.filter();
                    break;
                case 'u':
                    this.undoFilter();
                    break;
                case 'n':
                    this.navigate();
                    break;
                case 's':
                    this.save();
                    break;
                case 'r':
                    this.reset();
                    break;
                case 'q':
                    (0, assert_1.default)(this.rl, 'readline is not initialized');
                    this.rl.close();
                    break;
                default:
                    this.getCommand();
            }
        });
    }
    home() {
        (0, assert_1.default)(this.context.stats);
        (0, home_1.default)(this.context, this.getCommand.bind(this));
    }
    filter() {
        (0, filter_1.default)(this.rl, this.context, this.home.bind(this));
    }
    async undoFilter() {
        await (0, undoFilter_1.default)(this.context, this.home.bind(this));
    }
    async reset() {
        await (0, reset_1.default)(this.context, this.home.bind(this));
    }
    print() {
        (0, assert_1.default)(this.context.stats);
        (0, print_1.default)(this.context.stats, this.rl, this.getCommand.bind(this), this.home.bind(this));
    }
    save() {
        this.context.save();
        console.log(`Saved code object id ${this.context.codeObjectId}`);
        this.home();
    }
    async navigate() {
        (0, assert_1.default)(this.rl);
        return (0, navigate_1.default)(this.rl, this.context, this.search.bind(this), this.home.bind(this));
    }
    async search() {
        const performSearch = async () => {
            console.warn('Finding matching AppMaps');
            let progress = new cli_progress_1.default.SingleBar({}, cli_progress_1.default.Presets.shades_classic);
            this.context.addListener('start', (count) => progress.start(count, 0));
            this.context.addListener('increment', progress.increment.bind(progress));
            this.context.addListener('collate', () => console.warn('Collating results...'));
            this.context.addListener('stop', (count) => progress.stop());
            await this.context.findCodeObjects();
            if (!this.context.codeObjectMatches) {
                console.warn(`Code object '${this.context.codeObjectId}' not found`);
                return this.navigate();
            }
            console.warn('Finding matching Events');
            await this.context.buildStats();
        };
        try {
            await performSearch();
        }
        finally {
            this.context.removeAllListeners();
        }
    }
}
exports.default = UI;
//# sourceMappingURL=ui.js.map