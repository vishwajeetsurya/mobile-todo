"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const findCodeObjects_1 = __importDefault(require("../search/findCodeObjects"));
const utils_1 = require("../utils");
const specification_1 = __importDefault(require("@appland/sequence-diagram/dist/specification"));
const priority_1 = __importDefault(require("@appland/sequence-diagram/dist/priority"));
async function analyzeAppMaps(appmapDir, codeObjectPatterns) {
    const requiredPatterns = new Set();
    const uniquePatterns = new Set();
    const priority = new priority_1.default();
    const requiredCodeObjectIds = new Set();
    const includedCodeObjectIds = new Set();
    const interpretCodeObjectPattern = (pattern) => {
        if (pattern.startsWith('+')) {
            pattern = pattern.slice(1);
            requiredPatterns.add(pattern);
        }
        uniquePatterns.add(pattern);
        priority.enrollPattern(pattern);
    };
    const collectCodeObject = (codeObjectIds, codeObject) => {
        codeObjectIds.add(codeObject.fqid);
    };
    codeObjectPatterns.forEach(interpretCodeObjectPattern);
    const appmaps = new Set();
    // Match non-required patterns
    await Promise.all([...uniquePatterns]
        .filter((pattern) => !requiredPatterns.has(pattern))
        .map(async (codeObjectPattern) => {
        const matches = await new findCodeObjects_1.default(appmapDir, codeObjectPattern).find();
        const codeObjectIds = new Set();
        matches.forEach((match) => {
            collectCodeObject(includedCodeObjectIds, match.codeObject);
            collectCodeObject(codeObjectIds, match.codeObject);
        });
        priority.expandPattern(codeObjectPattern, [...codeObjectIds]);
    }));
    // Collect AppMaps which match every required pattern.
    if (requiredPatterns.size > 0) {
        // Figure out which AppMaps these code objects reside in
        const appmapsForRequiredPattern = await Promise.all([...requiredPatterns].map(async (codeObjectPattern) => {
            const matches = await new findCodeObjects_1.default(appmapDir, codeObjectPattern).find();
            const codeObjectIds = new Set();
            const appmaps = new Set();
            matches.forEach((match) => {
                appmaps.add(match.appmap);
                collectCodeObject(includedCodeObjectIds, match.codeObject);
                collectCodeObject(requiredCodeObjectIds, match.codeObject);
                collectCodeObject(codeObjectIds, match.codeObject);
            });
            priority.expandPattern(codeObjectPattern, Array.from(codeObjectIds));
            return appmaps;
        }));
        const firstSet = appmapsForRequiredPattern.pop();
        if (firstSet) {
            for (const appmap of firstSet) {
                // every is true for empty arrays
                if (appmapsForRequiredPattern.every((appmaps) => appmaps.has(appmap))) {
                    appmaps.add(appmap);
                }
            }
        }
    }
    else {
        await (0, utils_1.processFiles)(appmapDir, '.appmap.json', (file, cb) => {
            appmaps === null || appmaps === void 0 ? void 0 : appmaps.add(file.slice(0, file.length - '.appmap.json'.length));
            cb();
        }, new utils_1.ProcessFileOptions());
    }
    return {
        appmaps: [...appmaps].sort(),
        specification: new specification_1.default(priority, includedCodeObjectIds, requiredCodeObjectIds),
    };
}
exports.default = analyzeAppMaps;
//# sourceMappingURL=analyzeAppMaps.js.map