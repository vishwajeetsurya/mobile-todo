"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = exports.MAX_APPMAP_SIZE = void 0;
const client_1 = require("@appland/client");
const utils_1 = require("../utils");
const promises_1 = require("fs/promises");
const assert_1 = __importDefault(require("assert"));
const userInteraction_1 = __importDefault(require("./userInteraction"));
const errors_1 = require("./errors");
const handleWorkingDirectory_1 = require("../lib/handleWorkingDirectory");
const locateAppMapDir_1 = require("../lib/locateAppMapDir");
const console_1 = require("console");
const appNameFromConfig_1 = require("../lib/appNameFromConfig");
const checkSize_1 = require("./checkSize");
exports.MAX_APPMAP_SIZE = 2 * 1024 * 1024;
function applyOrCheck(data, key, input) {
    if (!input)
        return;
    const existing = data[key];
    if (existing) {
        if (existing !== input)
            throw new errors_1.ValidationError(`"${key}" mismatch ("${existing}" !== "${input}")`);
    }
    else {
        data[key] = input;
    }
}
function checkMetadata(metadata, input) {
    if (!input)
        return; // no metadata in appmap, ie. matches
    (0, assert_1.default)(typeof input === 'object');
    applyOrCheck(metadata, 'application', input['app']);
    const git = input['git'];
    if (typeof git !== 'object')
        return;
    applyOrCheck(metadata, 'branch', git['branch']);
    applyOrCheck(metadata, 'commit', git['commit']);
}
async function collect(appmapDir, force) {
    const metadata = {};
    const paths = [];
    await (0, utils_1.findFiles)(appmapDir, '.appmap.json', (path) => {
        paths.push(path);
    });
    for (const path of paths) {
        checkMetadata(metadata, JSON.parse(await (0, promises_1.readFile)(path, 'utf-8')).metadata);
        if (!force)
            (0, checkSize_1.checkSize)(await (0, promises_1.stat)(path));
    }
    return [paths, metadata];
}
async function handler(argv) {
    const { directory, appmapDir: appmapDirOpt, app: appOpt, force } = argv;
    (0, utils_1.verbose)(argv.verbose);
    (0, handleWorkingDirectory_1.handleWorkingDirectory)(directory);
    const appmapDir = await (0, locateAppMapDir_1.locateAppMapDir)(appmapDirOpt);
    let app = appOpt;
    if (!app)
        app = await (0, appNameFromConfig_1.appNameFromConfig)();
    if (!app) {
        throw new errors_1.ValidationError([
            'Application name is required.',
            `You can provide the application name by setting the 'name' field in appmap.yml, or with the --app option.`,
        ].join('\n'));
    }
    const exists = await new client_1.App(app).exists();
    if (!exists)
        throw new errors_1.ValidationError(`Application '${app}' does not exist.`);
    userInteraction_1.default.progress(`Examining AppMaps...`);
    const [paths, metadata] = await collect(appmapDir, !!force);
    if (paths.length === 0)
        throw new Error(`No AppMaps found in directory '${appmapDir}'`);
    let total = paths.length;
    const { baseURL } = (0, client_1.loadConfiguration)();
    userInteraction_1.default.progress(`Uploading ${total} AppMaps for ${app} to ${baseURL}...`);
    const uuids = [];
    let processed = 0;
    for (const path of paths) {
        processed += 1;
        userInteraction_1.default.status = `[${processed}/${total}] ${path}`;
        const data = await (0, promises_1.readFile)(path); //  TODO: stream this instead of slurping the whole thing?
        let response;
        try {
            response = await client_1.AppMap.create(data, { app });
        }
        catch (e) {
            (0, console_1.warn)(`Error uploading ${path}: ${e}`);
            throw e;
        }
        uuids.push(response.uuid);
    }
    userInteraction_1.default.status = 'Creating mapset...';
    const mapset = await client_1.Mapset.create(app, uuids, metadata);
    const url = [baseURL, 'applications', mapset.app_id, 'mapsets', mapset.id].join('/');
    userInteraction_1.default.success(`Created mapset ${url} with ${total} AppMaps`);
}
exports.handler = handler;
const command = {
    command: 'upload',
    builder: {
        directory: {
            alias: 'd',
        },
        'appmap-dir': {},
        app: {
            alias: 'a',
            description: 'application name override',
            type: 'string',
        },
        force: {
            alias: 'f',
            description: 'force uploading oversized files',
            type: 'boolean',
        },
    },
    describe: 'Upload AppMaps and create a mapset',
    handler,
};
exports.default = command;
//# sourceMappingURL=upload.js.map