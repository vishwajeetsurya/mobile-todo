"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const connect_1 = __importDefault(require("connect"));
const body_parser_1 = require("body-parser");
const connect_cors_1 = __importDefault(require("connect-cors"));
const jayson_1 = __importDefault(require("jayson"));
const console_1 = require("console");
const assert_1 = __importDefault(require("assert"));
const rpc_1 = require("../../rpc/rpc");
const util_1 = require("util");
const utils_1 = require("../../utils");
function handlerMiddleware(name, handler) {
    return async (args, callback) => {
        if ((0, utils_1.verbose)())
            (0, console_1.log)(`[RPCServer] Handling JSON-RPC request for ${name} (${JSON.stringify(args)})`);
        let err, result;
        try {
            result = await handler(args);
        }
        catch (error) {
            err = error;
        }
        if (err) {
            (0, console_1.warn)(`[RPCServer] An error occurred handling ${name}: ${(0, util_1.inspect)(err)}`);
            const error = rpc_1.RpcError.fromException(err);
            callback(error);
        }
        else {
            callback(null, result);
        }
    };
}
class RPCServer {
    constructor(port, rpcHandlers) {
        this.rpcHandlers = rpcHandlers;
        this.bindPort = port;
    }
    start() {
        (0, assert_1.default)(this.app === undefined, 'RPC server already started');
        const rpcMethods = this.rpcHandlers.reduce((acc, handler) => {
            const methodNames = Array.isArray(handler.name) ? handler.name : [handler.name];
            methodNames.forEach((methodName) => {
                acc[methodName] = handlerMiddleware(methodName, handler.handler);
            });
            return acc;
        }, {});
        (0, console_1.log)(`Available JSON-RPC methods: ${Object.keys(rpcMethods).sort().join(', ')}`);
        (0, console_1.warn)(`Consult @appland/rpc for request and response data types.`);
        const server = new jayson_1.default.Server(rpcMethods);
        const app = (0, connect_1.default)();
        app.use((0, connect_cors_1.default)({ methods: ['POST'] }));
        app.use((0, body_parser_1.json)());
        app.use(server.middleware());
        const listener = app.listen(this.bindPort);
        listener.on('listening', () => {
            const address = listener.address();
            if (address === null) {
                throw new Error(`Failed to listen on port ${this.port} (address is null)`);
            }
            else if (typeof address === 'string') {
                (0, console_1.log)(`Running JSON-RPC server on: ${address}`);
            }
            else {
                this.port = address.port;
                (0, console_1.log)(`Running JSON-RPC server on port: ${this.port}`);
            }
        });
        this.app = listener;
    }
    unref() {
        if (this.app)
            this.app.unref();
    }
    stop() {
        if (this.app)
            this.app.close(console_1.warn);
    }
}
exports.default = RPCServer;
//# sourceMappingURL=rpcServer.js.map