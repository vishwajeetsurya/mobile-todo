"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildHelpIndex = exports.HelpIndex = exports.unpackRef = exports.packRef = exports.DEFAULT_MAX_RESULTS = void 0;
const lunr_1 = __importDefault(require("lunr"));
const utils_1 = require("../../utils");
const console_1 = require("console");
const promises_1 = require("fs/promises");
const text_splitter_1 = require("langchain/text_splitter");
const path_1 = require("path");
const fs_1 = require("fs");
const assert_1 = __importDefault(require("assert"));
const js_yaml_1 = require("js-yaml");
const DOCS_DIR = ['../../docs', '../../../built/docs']
    .map((dir) => (0, path_1.join)(__dirname, dir))
    .find((dir) => (0, fs_1.existsSync)(dir));
exports.DEFAULT_MAX_RESULTS = 10;
function packRef(filePath, from, to) {
    return [filePath, from, to].join(':');
}
exports.packRef = packRef;
function unpackRef(ref) {
    const [filePath, from, to] = ref.split(':');
    return [filePath, parseInt(from), parseInt(to)];
}
exports.unpackRef = unpackRef;
class HelpIndex {
    constructor(idx, _frontMatterByFile, contentByRef) {
        this.idx = idx;
        this._frontMatterByFile = _frontMatterByFile;
        this.contentByRef = contentByRef;
    }
    async search(keywords, maxResults = exports.DEFAULT_MAX_RESULTS) {
        return this.idx
            .search(keywords.join(' '))
            .map((result) => {
            let content = this.contentByRef.get(result.ref);
            const [filePath, from, to] = unpackRef(result.ref);
            if (!content) {
                (0, console_1.warn)(`Could not find content for ${result.ref}`);
                return;
            }
            const filePathWithoutMdSuffix = filePath.replace(/\.md$/, '');
            content = [
                `<!-- Permalink: https://appmap.io/docs/${filePathWithoutMdSuffix} -->`,
                content,
            ].join('\n');
            return {
                filePath,
                from,
                to,
                content,
                score: result.score,
            };
        })
            .filter(Boolean).slice(0, maxResults);
    }
    static async buildIndex(directory) {
        const documents = new Array();
        if ((0, utils_1.verbose)())
            (0, console_1.log)(`[HelpIndex] Adding help documents to full-text index`);
        const startTime = Date.now();
        const frontMatterByFile = new Map();
        const contentByRef = new Map();
        const buildDocument = async (filePath) => {
            const document = await (0, promises_1.readFile)(filePath, 'utf8');
            let [_, frontMatterStr, text] = document.split('---');
            if (!frontMatterStr) {
                frontMatterStr = '';
                text = document;
            }
            let frontMatter;
            if (frontMatterStr) {
                try {
                    frontMatter = (0, js_yaml_1.load)(frontMatterStr);
                }
                catch (e) {
                    (0, console_1.warn)(`Could not parse front matter in ${filePath}`);
                    (0, console_1.warn)(e);
                }
                if (frontMatter)
                    frontMatterByFile.set(filePath, frontMatter);
            }
            const splitter = new text_splitter_1.MarkdownTextSplitter();
            // TODO: Utilize the front matter
            const chunks = await splitter.createDocuments([text]);
            for (const chunk of chunks) {
                const { from, to } = chunk.metadata.loc.lines;
                const id = packRef(filePath, from, to);
                contentByRef.set(id, chunk.pageContent);
                const pageName = (frontMatter === null || frontMatter === void 0 ? void 0 : frontMatter.name) || (frontMatter === null || frontMatter === void 0 ? void 0 : frontMatter.title);
                documents.push({ id, pageName, content: chunk.pageContent });
            }
        };
        await (0, utils_1.processFiles)(directory, (filePath) => filePath.endsWith('.md'), buildDocument);
        const idx = (0, lunr_1.default)(function () {
            this.ref('id');
            this.field('pageName');
            this.field('content');
            this.tokenizer.separator = /[\s/-_:#.]+/;
            for (const doc of documents)
                this.add(doc);
        });
        const endTime = Date.now();
        if ((0, utils_1.verbose)())
            (0, console_1.log)(`[AppMapIndex] Added ${documents.length} AppMaps to full-text index in ${endTime - startTime}ms`);
        return new HelpIndex(idx, frontMatterByFile, contentByRef);
    }
}
exports.HelpIndex = HelpIndex;
let helpIndex;
// TODO: Store the help index JSON in the distribution, so that we don't have to rebuild it when the process loads.
function buildHelpIndex(directory) {
    return HelpIndex.buildIndex(directory);
}
exports.buildHelpIndex = buildHelpIndex;
async function collectHelp(helpRequest) {
    if (!helpIndex) {
        (0, assert_1.default)(DOCS_DIR, 'Could not find AppMap docs directory');
        helpIndex = await buildHelpIndex(DOCS_DIR);
    }
    return await helpIndex.search(helpRequest.vectorTerms);
}
exports.default = collectHelp;
//# sourceMappingURL=help.js.map