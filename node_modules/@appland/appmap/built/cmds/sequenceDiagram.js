"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = exports.builder = exports.describe = exports.command = void 0;
const promises_1 = require("fs/promises");
const path_1 = require("path");
const handleWorkingDirectory_1 = require("../lib/handleWorkingDirectory");
const utils_1 = require("../utils");
const models_1 = require("@appland/models");
const sequence_diagram_1 = require("@appland/sequence-diagram");
const serveAndOpen_1 = require("../lib/serveAndOpen");
const assert_1 = __importDefault(require("assert"));
const browserRenderer_1 = __importDefault(require("./sequenceDiagram/browserRenderer"));
const filterAppMap_1 = __importDefault(require("../lib/filterAppMap"));
exports.command = 'sequence-diagram <appmap...>';
exports.describe = 'Generate a sequence diagram for an AppMap';
const builder = (args) => {
    args.positional('appmap', {
        type: 'string',
        array: true,
    });
    args.option('directory', {
        describe: 'program working directory',
        type: 'string',
        alias: 'd',
    });
    args.option('output-dir', {
        describe: 'directory in which to save the sequence diagrams',
    });
    args.option('show-browser', {
        describe: 'when using a browser to render the diagram, show the browser window',
        type: 'boolean',
        default: false,
    });
    args.option('loops', {
        describe: 'identify loops and collect under a Loop object',
        type: 'boolean',
        default: true,
    });
    args.option('format', {
        describe: 'output format',
        alias: 'f',
        choices: ['png', 'plantuml', 'json'],
        default: 'png',
    });
    args.option('filter', {
        describe: 'Filter to use to prune the map',
        type: 'string',
    });
    args.option('exclude', {
        describe: 'code objects to exclude from the diagram',
        deprecated: true,
    });
    args.option('expand', {
        describe: 'code objects to expand in the diagram',
    });
    return args.strict();
};
exports.builder = builder;
const handler = async (argv) => {
    (0, utils_1.verbose)(argv.verbose);
    (0, handleWorkingDirectory_1.handleWorkingDirectory)(argv.directory);
    if (!argv.appmap) {
        console.log(`appmap argument is required`);
        process.exitCode = 1;
        return;
    }
    if (argv.format !== 'png' && !sequence_diagram_1.Formatters.includes(argv.format)) {
        console.log(`Invalid format: ${argv.format}`);
        process.exitCode = 1;
        return;
    }
    const { filter, expand } = argv;
    let browserRender;
    if (argv.format === 'png') {
        browserRender = new browserRenderer_1.default(argv.showBrowser);
    }
    const generateDiagram = async (appmapFileName) => {
        const appmapData = JSON.parse(await (0, promises_1.readFile)(appmapFileName, 'utf-8'));
        let appmap = (0, models_1.buildAppMap)().source(appmapData).build();
        if (filter)
            appmap = (0, filterAppMap_1.default)(appmap, filter);
        const specOptions = {
            loops: argv.loops,
        };
        if (expand)
            specOptions.expand = Array.isArray(expand) ? expand : [expand];
        if (argv.exclude)
            specOptions.exclude = Array.isArray(argv.exclude) ? argv.exclude : [argv.exclude];
        if (argv.outputDir)
            await (0, promises_1.mkdir)(argv.outputDir, { recursive: true });
        const specification = sequence_diagram_1.Specification.build(appmap, specOptions);
        const diagram = (0, sequence_diagram_1.buildDiagram)(appmapFileName, appmap, specification);
        const printDiagram = async (format) => {
            const template = (0, sequence_diagram_1.format)(format, diagram, appmapFileName);
            const outputFileName = [
                (0, path_1.basename)(appmapFileName, '.appmap.json'),
                '.sequence',
                template.extension,
            ].join('');
            let resultPath;
            if (argv.outputDir)
                resultPath = (0, path_1.join)(argv.outputDir, outputFileName);
            else
                resultPath = (0, path_1.join)((0, path_1.dirname)(appmapFileName), outputFileName);
            await (0, promises_1.writeFile)(resultPath, template.diagram);
            return resultPath;
        };
        let outputPath;
        if (argv.format === 'png') {
            // PNG rendering is performed by loading the sequence
            // diagram in a browser and taking a screenshot.
            const diagramPath = await printDiagram(sequence_diagram_1.FormatType.JSON);
            outputPath = await new Promise((resolve) => (0, serveAndOpen_1.serveAndOpenSequenceDiagram)(diagramPath, false, async (url) => {
                if ((0, utils_1.verbose)())
                    console.warn(`Rendering PNG`);
                (0, assert_1.default)(browserRender, 'Browser not initialized');
                const outputPath = (0, path_1.join)((0, path_1.dirname)(diagramPath), [(0, path_1.basename)(diagramPath, '.json'), '.png'].join(''));
                await browserRender.screenshot(url, outputPath);
                resolve(outputPath);
            }));
            console.warn(`Printed diagram ${outputPath}`);
        }
        else {
            // Other forms of output are produced directly by the
            // sequence diagram library.
            outputPath = await printDiagram(argv.format);
            console.log(`Printed diagram ${outputPath}`);
        }
    };
    for (const appmapFile of argv.appmap) {
        await generateDiagram(appmapFile);
    }
    if (browserRender)
        await browserRender.close();
};
exports.handler = handler;
//# sourceMappingURL=sequenceDiagram.js.map