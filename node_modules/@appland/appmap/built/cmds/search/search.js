"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = exports.builder = exports.describe = exports.command = void 0;
const assert_1 = __importDefault(require("assert"));
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const models_1 = require("@appland/models");
const handleWorkingDirectory_1 = require("../../lib/handleWorkingDirectory");
const utils_1 = require("../../utils");
const searchSingleAppMap_1 = __importDefault(require("./searchSingleAppMap"));
const AppMapIndex_1 = __importDefault(require("../../fulltext/AppMapIndex"));
const openers_1 = require("../open/openers");
exports.command = 'search <query>';
exports.describe = 'Search AppMaps, or a single AppMap, for search matches to a full-text query.';
const builder = (args) => {
    args.positional('query', {
        describe: 'full-text query',
        type: 'string',
        demandOption: true,
    });
    args.option('directory', {
        describe: 'program working directory',
        type: 'string',
        alias: 'd',
    });
    args.option('find-events', {
        describe: 'find events within AppMap search results',
        type: 'boolean',
    });
    args.option('context-depth', {
        describe: 'depth of call stack context to include around search matches',
        type: 'number',
        default: 2,
    });
    args.option('appmap', {
        describe: 'AppMap to search',
        type: 'string',
        alias: 'a',
    });
    args.option('max-results', {
        describe: 'maximum number of search results to return',
        type: 'number',
    });
    args.option('max-size', {
        describe: 'prune AppMap to a maximum size before searching (used only with --appmap option)',
        type: 'string',
    });
    args.option('filter', {
        describe: 'serialized AppMap filter to apply to the AppMap (used only with --appmap option)',
        type: 'string',
    });
    args.option('show', {
        describe: 'open AppMaps in a visual tool such as VSCode or the browser',
        boolean: false,
    });
    args.option('format', {
        describe: 'output format to use for printing the output. json: JSON serialization of the search results. appmap: AppMap data focused on the search results (only available with --appmap or --find-events options)',
        choices: ['json', 'appmap'],
        default: 'json',
        alias: 'f',
    });
    return args.strict();
};
exports.builder = builder;
const handler = async (argv) => {
    (0, utils_1.verbose)(argv.verbose);
    const { directory, query, appmap, contextDepth, show, maxResults, findEvents, format } = argv;
    (0, handleWorkingDirectory_1.handleWorkingDirectory)(directory);
    function printResultsJSON(response) {
        console.log(JSON.stringify(response, null, 2));
    }
    async function printResultsAppMap(response) {
        if (response.type === 'appmap')
            throw new Error(`Cannot output appmap format for appmap search results`);
        const { results } = response;
        const fqidsByAppMap = new Map();
        for (const result of results) {
            const fqids = fqidsByAppMap.get(result.appmap) || [];
            fqids.push(result.fqid);
            fqidsByAppMap.set(result.appmap, fqids);
        }
        const filterAppMap = (appmapId) => {
            const fqids = fqidsByAppMap.get(appmapId);
            (0, assert_1.default)(fqids);
            const appmap = (0, models_1.buildAppMap)()
                .source((0, fs_1.readFileSync)(appmapId + '.appmap.json', 'utf-8'))
                .build();
            const filter = new models_1.AppMapFilter();
            filter.declutter.context.on = true;
            filter.declutter.context.names = fqids;
            filter.declutter.context.depth = contextDepth;
            return filter.filter(appmap, []);
        };
        const appmaps = new Array();
        let count = 0;
        const sanitize = (str) => str.replace(/[^a-zA-Z0-9]/g, '_').slice(0, 100);
        // const outputDir = `.appmap/search-results/${sanitize(query)}`;
        for (const appmapId of fqidsByAppMap.keys()) {
            const filteredAppMap = filterAppMap(appmapId);
            if (show) {
                const appmapFile = `${sanitize(query)}_${count}.appmap.json`;
                await (0, promises_1.writeFile)(appmapFile, JSON.stringify(filteredAppMap, null, 2));
                await (0, openers_1.openInBrowser)(appmapFile, false);
                await new Promise((resolve) => setTimeout(resolve, 1000));
            }
            else {
                appmaps.push(filteredAppMap);
            }
            count += 1;
        }
        if (appmaps.length > 0)
            console.log(JSON.stringify(appmaps));
    }
    async function presentResults(response) {
        if (format === 'json') {
            printResultsJSON(response);
        }
        else if (format === 'appmap') {
            await printResultsAppMap(response);
        }
        else {
            throw new Error(`Unknown format: ${format}`);
        }
    }
    if (appmap) {
        const options = {
            maxResults,
        };
        const { maxSize, filter: filterStr } = argv;
        if (maxSize)
            options.maxSize = maxSize;
        if (filterStr)
            options.filter = (0, models_1.deserializeFilter)(filterStr);
        const response = await (0, searchSingleAppMap_1.default)(appmap, query, options);
        await presentResults(response);
    }
    else {
        const options = {
            maxResults,
        };
        const response = await AppMapIndex_1.default.search([process.cwd()], query, options);
        if (findEvents) {
            const eventOptions = { maxResults };
            const { maxSize, filter: filterStr } = argv;
            if (maxSize)
                eventOptions.maxSize = maxSize;
            if (filterStr)
                eventOptions.filter = (0, models_1.deserializeFilter)(filterStr);
            const { results } = response;
            let eventResults = new Array();
            for (const result of results) {
                const response = await (0, searchSingleAppMap_1.default)(result.appmap, query, options);
                eventResults.push(...response.results);
            }
            const numResults = eventResults.length;
            eventResults.sort((a, b) => b.score - a.score);
            if (eventResults.length > maxResults)
                eventResults = eventResults.slice(0, maxResults);
            await presentResults({ type: 'event', numResults: numResults, results: eventResults });
        }
        else {
            await presentResults(response);
        }
    }
};
exports.handler = handler;
//# sourceMappingURL=search.js.map