"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const fs_1 = require("fs");
const fs_2 = require("fs");
const promises_1 = require("fs/promises");
const js_yaml_1 = __importStar(require("js-yaml"));
const openapi_1 = require("@appland/openapi");
const locateAppMapDir_1 = require("../../lib/locateAppMapDir");
const handleWorkingDirectory_1 = require("../../lib/handleWorkingDirectory");
const locateAppMapConfigFile_1 = require("../../lib/locateAppMapConfigFile");
const fileSizeFilter_1 = require("../../lib/fileSizeFilter");
const utils_1 = require("../../utils");
const DataStore_1 = __importDefault(require("./DataStore"));
const DefinitionGenerator_1 = __importDefault(require("./DefinitionGenerator"));
class OpenAPICommand {
    constructor(appmapDir) {
        this.appmapDir = appmapDir;
        this.errors = [];
        this.filter = async (file) => ({ enable: true });
    }
    async execute() {
        // Make sure the directory exists -- if it doesn't, the glob below just returns nothing.
        if (!(0, fs_1.existsSync)(this.appmapDir)) {
            throw new Error(`AppMap directory ${this.appmapDir} does not exist`);
        }
        const dataStore = new DataStore_1.default();
        await dataStore.initialize();
        const collectAppMap = async (file) => {
            try {
                await dataStore.storeAppMap(file);
            }
            catch (e) {
                let errorString;
                try {
                    errorString = e.toString();
                }
                catch (x) {
                    errorString = (e || '').toString();
                }
                this.errors.push(errorString);
            }
        };
        const appMapFiles = await (0, utils_1.findFiles)(this.appmapDir, '.appmap.json');
        for (const file of appMapFiles) {
            const filterResult = await this.filter(file);
            if (!filterResult.enable) {
                if (filterResult.message)
                    console.warn(filterResult.message);
                continue;
            }
            await collectAppMap(file);
        }
        await dataStore.closeAll();
        const definitionGenerator = new DefinitionGenerator_1.default(dataStore);
        const { warnings, paths, securitySchemes } = await definitionGenerator.generate();
        // Leave the files in place if an error occurs.
        await dataStore.cleanup();
        return [
            {
                warnings,
                paths,
                securitySchemes,
            },
            appMapFiles.length,
        ];
    }
}
async function loadTemplate(fileName) {
    if (!fileName) {
        // eslint-disable-next-line no-param-reassign
        fileName = (0, path_1.join)(__dirname, '../../../resources/openapi-template.yaml');
    }
    return js_yaml_1.default.load((await fs_2.promises.readFile(fileName)).toString());
}
exports.default = {
    command: 'openapi',
    OpenAPICommand,
    aliases: ['swagger'],
    describe: 'Generate OpenAPI from AppMaps in a directory',
    builder(args) {
        args.option('directory', {
            describe: 'program working directory',
            type: 'string',
            alias: 'd',
        });
        args.option('appmap-dir', {
            describe: 'directory to recursively inspect for AppMaps',
        });
        args.option('max-size', {
            describe: 'maximum AppMap size that will be processed, in filesystem-reported MB',
            type: 'number',
            default: fileSizeFilter_1.DefaultMaxAppMapSizeInMB,
        });
        args.option('output-file', {
            alias: ['o'],
            describe: 'output file name',
            requiresArg: true,
        });
        args.option('openapi-template', {
            describe: 'template YAML; generated content will be placed in the paths and components sections',
        });
        args.option('openapi-title', {
            describe: 'info/title field of the OpenAPI document',
        });
        args.option('openapi-version', {
            describe: 'info/version field of the OpenAPI document',
        });
        return args.strict();
    },
    async handler(argv) {
        var _a, _b;
        (0, openapi_1.verbose)(argv.verbose);
        (0, handleWorkingDirectory_1.handleWorkingDirectory)(argv.directory);
        const appmapDir = await (0, locateAppMapDir_1.locateAppMapDir)(argv.appmapDir);
        const { openapiTitle, openapiVersion, maxSize, maxExamples } = argv;
        const maxAppMapSizeInBytes = Math.round(parseFloat(maxSize) * 1024 * 1024);
        function tryConfigure(path, fn) {
            try {
                fn();
            }
            catch (_a) {
                console.warn(`Warning: unable to configure OpenAPI field ${path}`);
            }
        }
        const appmapConfigFile = await (0, locateAppMapConfigFile_1.locateAppMapConfigFile)(appmapDir);
        const cmd = new OpenAPICommand(appmapDir);
        cmd.filter = (0, fileSizeFilter_1.fileSizeFilter)(maxAppMapSizeInBytes);
        const [openapi] = await cmd.execute();
        for (const error of cmd.errors) {
            console.warn(error);
        }
        const template = await loadTemplate(argv.openapiTemplate);
        template.paths = openapi.paths;
        if (openapiTitle) {
            tryConfigure('info.title', () => {
                template.info.title = openapiTitle;
            });
        }
        if (openapiVersion) {
            tryConfigure('info.version', () => {
                template.info.version = openapiVersion;
            });
        }
        // TODO: This should be made available, but isn't
        template.components = openapi.components;
        template.components || (template.components = {});
        let appmapConfig;
        if (appmapConfigFile) {
            appmapConfig = ((0, js_yaml_1.load)(await (0, promises_1.readFile)(appmapConfigFile, 'utf-8')) || {});
        }
        const overrides = (_a = appmapConfig === null || appmapConfig === void 0 ? void 0 : appmapConfig.openapi) === null || _a === void 0 ? void 0 : _a.overrides;
        const schemas = (_b = appmapConfig === null || appmapConfig === void 0 ? void 0 : appmapConfig.openapi) === null || _b === void 0 ? void 0 : _b.schemas;
        if (schemas)
            template.components.schemas = schemas;
        if (overrides)
            applySchemaOverrides(template.paths, overrides);
        if (template.paths)
            sortProperties(template.paths);
        let warnings = ['#'];
        if (Object.keys(openapi.warnings).length) {
            warnings.push('# OpenAPI generator reported warnings during processing:');
            for (const [path, messages] of Object.entries(openapi.warnings)) {
                for (const message of messages) {
                    warnings.push(`#   ${path}: ${message}`);
                }
            }
            warnings.push('#');
        }
        const fileContents = `# This document can be generated with the following command: 
#   appmap openapi
#
# Some helpful options:
#   --output-file        output file name
#   --openapi-title      title field of the OpenAPI document
#   --openapi-version    version field of the OpenAPI document
#
# For more info, run:
#   appmap openapi --help
#
# Visit our docs: https://appmap.io/docs/openapi.html
${warnings.join('\n')}
${js_yaml_1.default.dump(template)}
`;
        if (argv.outputFile) {
            await fs_2.promises.writeFile(argv.outputFile, fileContents);
        }
        else {
            console.log(fileContents);
        }
    },
};
function sortProperties(values) {
    Object.keys(values).forEach((key) => {
        let value = values[key];
        if (key === 'properties' && typeof value === 'object') {
            values[key] = Object.keys(value)
                .sort()
                .reduce((memo, key) => {
                const v = value[key];
                if (typeof v === 'object' && v !== null && v.constructor !== Array)
                    sortProperties(v);
                memo[key] = v;
                return memo;
            }, {});
        }
        else if (typeof value === 'object' && value !== null) {
            sortProperties(value);
        }
    });
}
function applySchemaOverrides(paths, overrides) {
    Object.keys(overrides).forEach((key) => {
        const value = overrides[key];
        if (value === undefined)
            return;
        if (paths[key] == undefined)
            return;
        if (key === 'schema') {
            paths.schema = Object.assign({}, overrides.schema);
        }
        else if (typeof value === 'object') {
            applySchemaOverrides(paths[key], value);
        }
    });
}
async function warnCatch(fn) {
    try {
        return await fn;
    }
    catch (err) {
        console.warn(err);
        return;
    }
}
//# sourceMappingURL=openapi.js.map