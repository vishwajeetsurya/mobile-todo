"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const openapi_1 = require("@appland/openapi");
const promises_1 = require("fs/promises");
const assert_1 = __importDefault(require("assert"));
const rpcRequest_1 = require("@appland/openapi/dist/rpcRequest");
class DefinitionGenerator {
    constructor(dataStore) {
        this.dataStore = dataStore;
    }
    async generate() {
        const securitySchemes = new openapi_1.SecuritySchemes();
        const paths = {};
        const warnings = {};
        const warningStrings = new Set();
        for (const requestFileName of this.dataStore.requestFileNames) {
            let requestData;
            try {
                requestData = JSON.parse(await (0, promises_1.readFile)(requestFileName, 'utf-8'));
            }
            catch (e) {
                console.warn(`Warning: unable to parse AppMap ${requestFileName}: ${e}`);
                continue;
            }
            (0, assert_1.default)(requestData);
            const model = new openapi_1.Model();
            for (const request of requestData) {
                model.addRpcRequest(request);
                if (request.requestHeaders) {
                    const authorizationHeader = (0, rpcRequest_1.headerValue)(request.requestHeaders, 'Authorization');
                    if (authorizationHeader)
                        securitySchemes.addAuthorizationHeader(authorizationHeader);
                }
            }
            const openapi = model.openapi();
            for (const [path, pathItem] of Object.entries(openapi)) {
                if (pathItem)
                    paths[path] = pathItem;
            }
            const collectedWarnings = model.collectWarnings();
            for (const key of Object.keys(collectedWarnings)) {
                if (!warnings[key])
                    warnings[key] = [];
                for (const warning of collectedWarnings[key]) {
                    const warningString = [key, warning].join(':');
                    if (!warningStrings.has(warningString)) {
                        warningStrings.add(warningString);
                        console.warn(`OpenAPI warning generating ${key}: ${warning}`);
                        warnings[key].push(warning);
                    }
                }
            }
        }
        return {
            warnings,
            paths: Object.keys(paths)
                .sort()
                .reduce((memo, path) => ((memo[path] = paths[path]), memo), {}),
            securitySchemes: securitySchemes.openapi(),
        };
    }
}
exports.default = DefinitionGenerator;
//# sourceMappingURL=DefinitionGenerator.js.map