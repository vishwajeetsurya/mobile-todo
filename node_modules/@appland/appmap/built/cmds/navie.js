"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = exports.builder = exports.describe = exports.command = exports.buildNavieProvider = exports.commonNavieArgsBuilder = void 0;
const node_console_1 = require("node:console");
const node_fs_1 = require("node:fs");
const promises_1 = require("node:fs/promises");
const consumers_1 = require("node:stream/consumers");
const chalk_1 = __importDefault(require("chalk"));
const client_1 = require("@appland/client");
const handleWorkingDirectory_1 = require("../lib/handleWorkingDirectory");
const explain_1 = require("../rpc/explain/explain");
const navie_local_1 = __importDefault(require("../rpc/explain/navie/navie-local"));
const navie_remote_1 = __importDefault(require("../rpc/explain/navie/navie-remote"));
const aiEnvVar_1 = __importStar(require("./index/aiEnvVar"));
const detectCodeEditor_1 = __importDefault(require("../lib/detectCodeEditor"));
function commonNavieArgsBuilder(args) {
    return args
        .option('directory', {
        describe: 'program working directory',
        type: 'string',
        alias: 'd',
        array: true,
        nargs: 1,
        default: [process.cwd()],
    })
        .option('navie-provider', {
        describe: 'navie provider to use',
        type: 'string',
        choices: ['local', 'remote'],
    })
        .option('log-navie', {
        describe: 'Log Navie events to stderr',
        boolean: true,
        default: false,
    })
        .option('ai-option', {
        describe: 'Specify an extended option to the AI provider, in the form of a key=value pair. May be repeated.',
        type: 'string',
        array: true,
    })
        .option('agent-mode', {
        describe: `This option is deprecated. Instead, start your question with @<command | agent>.`,
    })
        .option('code-editor', {
        describe: 'Active code editor. This information is used to tune the @help responses. If unspecified, the code editor may be picked up from environment variables APPMAP_CODE_EDITOR, TERM_PROGRAM and TERMINAL_EMULATOR.',
        type: 'string',
        // Allow this to be any string. The code editor brand name may be a clue to the language
        // in use, or the user's intent.
    });
}
exports.commonNavieArgsBuilder = commonNavieArgsBuilder;
function buildNavieProvider(argv) {
    const { logNavie } = argv;
    let aiOptions = argv.aiOption;
    if (aiOptions) {
        aiOptions = Array.isArray(aiOptions) ? aiOptions : [aiOptions];
    }
    const agentModeStr = argv.agentMode;
    let agentMode;
    if (agentModeStr)
        agentMode = agentModeStr;
    const useLocalNavie = () => {
        if (argv.navieProvider === 'local') {
            (0, node_console_1.warn)(`Using local Navie provider due to explicit --navie-provider=local option`);
            return true;
        }
        if (argv.navieProvider === 'remote') {
            (0, node_console_1.warn)(`Using remote Navie provider due to explicit --navie-provider=remote option`);
            return false;
        }
        const aiEnvVar = (0, aiEnvVar_1.default)();
        if (aiEnvVar) {
            (0, node_console_1.warn)(`Using local Navie provider due to presence of environment variable ${aiEnvVar}`);
            return true;
        }
        (0, node_console_1.warn)(`--navie-provider option not provided, and none of ${aiEnvVar_1.AI_KEY_ENV_VARS.join(' ')} are available. Using remote Navie provider.`);
        return false;
    };
    const applyAIOptions = (navie) => {
        if (aiOptions) {
            for (const option of aiOptions) {
                const [key, value] = option.split('=');
                if (key && value) {
                    navie.setOption(key, value);
                }
            }
        }
        if (agentMode) {
            navie.setOption('explainMode', agentMode);
        }
    };
    const buildLocalNavie = (contextProvider, projectInfoProvider, helpProvider) => {
        (0, client_1.loadConfiguration)(false);
        const navie = new navie_local_1.default(contextProvider, projectInfoProvider, helpProvider);
        applyAIOptions(navie);
        let START;
        const logEvent = (event) => {
            if (!logNavie)
                return;
            if (!START)
                START = Date.now();
            const elapsed = Date.now() - START;
            process.stderr.write(chalk_1.default.gray(`${elapsed}ms `));
            process.stderr.write(chalk_1.default.gray(event.message));
            process.stderr.write(chalk_1.default.gray('\n'));
        };
        navie.on('event', logEvent);
        return navie;
    };
    const buildRemoteNavie = (contextProvider, projectInfoProvider, helpProvider) => {
        (0, client_1.loadConfiguration)(true);
        const navie = new navie_remote_1.default(contextProvider, projectInfoProvider, helpProvider);
        applyAIOptions(navie);
        return navie;
    };
    return useLocalNavie() ? buildLocalNavie : buildRemoteNavie;
}
exports.buildNavieProvider = buildNavieProvider;
exports.command = 'navie [question..]';
exports.describe = 'Explain a question using Navie';
function builder(args) {
    return commonNavieArgsBuilder(args)
        .positional('question', {
        describe: 'Question text; appended to any other input',
        type: 'string',
        array: true,
    })
        .option('output', {
        describe: 'Output path',
        type: 'string',
        alias: 'o',
    })
        .option('input', {
        describe: 'Input path',
        type: 'string',
        alias: 'i',
    });
}
exports.builder = builder;
async function handler(argv) {
    await (0, handleWorkingDirectory_1.configureRpcDirectories)(argv.directory);
    const output = openOutput(argv.output);
    function attachNavie(navie) {
        return navie
            .on('error', (err) => {
            (0, node_console_1.warn)(err);
            process.exitCode = 1;
        })
            .on('token', (token) => output.write(token));
    }
    let codeEditor = argv.codeEditor;
    if (!codeEditor) {
        codeEditor = (0, detectCodeEditor_1.default)();
        if (codeEditor)
            (0, node_console_1.warn)(`Detected code editor: ${codeEditor}`);
    }
    const question = await getQuestion(argv.input, argv.question);
    const capturingProvider = (...args) => attachNavie(buildNavieProvider(argv)(...args));
    await (0, explain_1.explainHandler)(capturingProvider, codeEditor).handler({ question });
}
exports.handler = handler;
function openOutput(outputPath) {
    switch (outputPath) {
        case '-':
        case undefined:
            // prevent other things from messing with the output
            console.log = console.debug = console.warn;
            (0, node_console_1.warn)('No output specified, writing to stdout');
            return process.stdout;
        default:
            (0, node_console_1.warn)(`Writing output to ${outputPath}`);
            return (0, node_fs_1.createWriteStream)(outputPath);
    }
}
async function getQuestion(path, literal) {
    const question = [...(literal !== null && literal !== void 0 ? literal : [])];
    const targetPath = path !== null && path !== void 0 ? path : (question.length ? undefined : '-');
    if (targetPath === '-') {
        (0, node_console_1.warn)('Reading question from stdin');
        question.unshift(await (0, consumers_1.text)(process.stdin));
    }
    else if (targetPath) {
        (0, node_console_1.warn)(`Reading question from ${targetPath}`);
        question.unshift(await (0, promises_1.readFile)(targetPath, 'utf-8'));
    }
    return question.join(' ');
}
//# sourceMappingURL=navie.js.map