"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = exports.builder = exports.describe = exports.command = void 0;
const readline_1 = __importDefault(require("readline"));
const path_1 = require("path");
const promises_1 = require("fs/promises");
const handleWorkingDirectory_1 = require("../../lib/handleWorkingDirectory");
const detectRevisions_1 = __importDefault(require("./detectRevisions"));
const prepareOutputDir_1 = require("./prepareOutputDir");
const utils_1 = require("../../utils");
const loadAppMapConfig_1 = __importDefault(require("../../lib/loadAppMapConfig"));
const ChangeAnalysis_1 = require("../../diffArchive/ChangeAnalysis");
const reportChanges_1 = __importStar(require("./reportChanges"));
const deleteUnreferencedAppMaps_1 = __importDefault(require("./deleteUnreferencedAppMaps"));
exports.command = 'compare';
exports.describe = 'Compare runtime code behavior between base and head revisions';
const builder = (args) => {
    args.option('directory', {
        describe: 'program working directory',
        type: 'string',
        alias: 'd',
    });
    args.option('base-revision', {
        describe: 'base revision name or commit SHA.',
        alias: ['b', 'base'],
        demandOption: true,
    });
    args.option('head-revision', {
        describe: 'head revision name or commit SHA. By default, use the current commit.',
        alias: ['h', 'head'],
    });
    args.option('output-dir', {
        describe: 'directory in which to save the report files. Default is ./.appmap/change-report/<base-revision>-<head-revision>.',
    });
    args.option('clobber-output-dir', {
        describe: 'remove the output directory if it exists',
        type: 'boolean',
        default: false,
    });
    args.option('source-dir', {
        describe: 'root directory of the application source code',
        type: 'string',
        default: '.',
    });
    args.option('delete-unreferenced', {
        describe: 'whether to delete AppMaps from base and head that are unreferenced by the change report',
        default: true,
        alias: 'delete-unchanged',
    });
    args.option('report-removed', {
        describe: 'whether to report removed findings, such as removed API routes, resolved findings, etc',
        default: true,
    });
    return args.strict();
};
exports.builder = builder;
const handler = async (argv) => {
    (0, utils_1.verbose)(argv.verbose);
    const rl = readline_1.default.createInterface({
        input: process.stdin,
        output: process.stdout,
    });
    const { directory, sourceDir: srcDir, baseRevision: baseRevisionArg, outputDir: outputDirArg, headRevision: headRevisionArg, deleteUnreferenced, reportRemoved, } = argv;
    try {
        (0, handleWorkingDirectory_1.handleWorkingDirectory)(directory);
        const appmapConfig = await (0, loadAppMapConfig_1.default)();
        if (!appmapConfig)
            throw new Error(`Unable to load appmap.yml config file`);
        const { baseRevision, headRevision } = await (0, detectRevisions_1.default)(baseRevisionArg, headRevisionArg);
        const outputDir = await (0, prepareOutputDir_1.prepareOutputDir)(outputDirArg, baseRevision, headRevision, argv.clobberOutputDir, rl);
        const options = new reportChanges_1.ChangeReportOptions();
        options.reportRemoved = reportRemoved;
        const changeAnalysis = await (0, ChangeAnalysis_1.analyzeChanges)(outputDir, srcDir, baseRevision, headRevision);
        const report = await (0, reportChanges_1.default)(changeAnalysis, options);
        if (deleteUnreferenced) {
            const isPathReferenced = (revisionName, appmap) => changeAnalysis.referencedAppMaps.test(revisionName, appmap);
            await (0, deleteUnreferencedAppMaps_1.default)(changeAnalysis.paths, isPathReferenced);
        }
        if (report.warnings) {
            for (const [key, messages] of Object.entries(report.warnings)) {
                for (const message of messages) {
                    console.warn(`Warning (${key}): ${message}`);
                }
            }
        }
        await (0, promises_1.writeFile)((0, path_1.join)(outputDir, 'change-report.json'), JSON.stringify(report, null, 2));
    }
    finally {
        rl.close();
    }
};
exports.handler = handler;
//# sourceMappingURL=compare.js.map