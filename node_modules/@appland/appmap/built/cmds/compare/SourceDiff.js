"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceDiff = void 0;
const promises_1 = require("fs/promises");
const path_1 = require("path");
const models_1 = require("@appland/models");
const assert_1 = __importDefault(require("assert"));
const RevisionName_1 = require("../../diffArchive/RevisionName");
const SourceDiff_1 = __importDefault(require("../../diffArchive/SourceDiff"));
class SourceDiff {
    constructor(baseRevision, headRevision, paths) {
        this.baseRevision = baseRevision;
        this.headRevision = headRevision;
        this.paths = paths;
        this.diffs = new Map();
        this.classMaps = new Map();
        this.diffLoader = new SourceDiff_1.default(baseRevision, headRevision);
    }
    async get(appmap) {
        [RevisionName_1.RevisionName.Base, RevisionName_1.RevisionName.Head].forEach((revisionName) => (0, assert_1.default)(!appmap.startsWith(revisionName), `AppMap ${appmap} must not start with a revision name`));
        const yieldDiff = (diff) => (diff !== '' ? diff : undefined);
        let diff = this.diffs.get(appmap);
        if (diff)
            return Promise.resolve(yieldDiff(diff));
        diff = await this.loadDiff(appmap);
        this.diffs.set(appmap, diff);
        return yieldDiff(diff);
    }
    async loadDiff(appmap) {
        const loadClassMap = async () => {
            const classMapData = JSON.parse(await (0, promises_1.readFile)((0, path_1.join)(this.paths.classMapPath(RevisionName_1.RevisionName.Head, appmap)), 'utf-8'));
            return new models_1.ClassMap(classMapData);
        };
        const classMap = this.classMaps.get(appmap) || (await loadClassMap());
        const sourcePaths = new Set();
        const sourcePathRoots = new Set();
        classMap.visit((codeObject) => {
            if (!codeObject.location)
                return;
            const path = codeObject.location.split(':')[0];
            if (path.indexOf('.') && !path.startsWith('<') && !path.includes('#') && !(0, path_1.isAbsolute)(path)) {
                sourcePaths.add(path);
                const pathTokens = path.split('/');
                if (pathTokens.length > 0)
                    sourcePathRoots.add(pathTokens[0]);
            }
        });
        await this.diffLoader.update(sourcePathRoots);
        const result = [...sourcePaths]
            .sort()
            .map((path) => this.diffLoader.lookupDiff(path))
            .join('');
        return result;
    }
}
exports.SourceDiff = SourceDiff;
//# sourceMappingURL=SourceDiff.js.map