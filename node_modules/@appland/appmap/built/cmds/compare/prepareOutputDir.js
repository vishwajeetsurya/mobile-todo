"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareOutputDir = void 0;
const promises_1 = require("fs/promises");
const path_1 = require("path");
const utils_1 = require("../../utils");
const RevisionName_1 = require("../../diffArchive/RevisionName");
const ui_1 = require("./ui");
const ValidationError_1 = require("./ValidationError");
async function prepareOutputDir(outputDirArg, baseRevision, headRevision, clobberOutputDir, rl) {
    let outputDir = outputDirArg;
    if (!outputDir) {
        outputDir = `.appmap/change-report/${(0, ui_1.sanitizeRevision)(baseRevision)}-${(0, ui_1.sanitizeRevision)(headRevision)}`;
    }
    for (const revision of [RevisionName_1.RevisionName.Base, RevisionName_1.RevisionName.Head]) {
        if (!(await (0, utils_1.exists)((0, path_1.join)(outputDir, revision))))
            throw new ValidationError_1.ValidationError(`${revision} revision data (${(0, path_1.join)(outputDir, revision)}) does not exist`);
    }
    const diffDir = (0, path_1.join)(outputDir, RevisionName_1.RevisionName.Diff);
    if (await (0, utils_1.exists)(diffDir)) {
        if (!clobberOutputDir &&
            process.stdout.isTTY &&
            !(await (0, ui_1.confirm)(`Delete existing 'diff' in ${diffDir}?`, rl))) {
            throw new ValidationError_1.ValidationError(`The 'diff' data directory ${diffDir} exists and you chose not to delete it`);
        }
        await (0, promises_1.rm)(diffDir, { recursive: true, force: true });
        // Rapid rm and then mkdir will silently fail in practice.
        await new Promise((resolve) => setTimeout(resolve, 100));
    }
    await (0, promises_1.mkdir)((0, path_1.join)(outputDir, RevisionName_1.RevisionName.Diff), { recursive: true });
    return outputDir;
}
exports.prepareOutputDir = prepareOutputDir;
//# sourceMappingURL=prepareOutputDir.js.map