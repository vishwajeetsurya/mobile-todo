"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const async_1 = require("async");
const openapi_diff_1 = __importDefault(require("openapi-diff"));
const promises_1 = require("fs/promises");
const path_1 = require("path");
const sequence_diagram_1 = require("@appland/sequence-diagram");
const DiffDiagrams_1 = require("../../sequenceDiagramDiff/DiffDiagrams");
const SourceDiff_1 = require("./SourceDiff");
const loadSequenceDiagram_1 = require("./loadSequenceDiagram");
const RevisionName_1 = require("../../diffArchive/RevisionName");
const mapToRecord_1 = __importDefault(require("./mapToRecord"));
const resolvePath_1 = require("../../lib/resolvePath");
const models_1 = require("@appland/models");
const console_1 = require("console");
const utils_1 = require("../../utils");
class ReportFieldCalculator {
    constructor(changeAnalysis) {
        this.changeAnalysis = changeAnalysis;
        this.warnings = {};
        this.sourceDiff = new SourceDiff_1.SourceDiff(changeAnalysis.baseRevision, changeAnalysis.headRevision, changeAnalysis.paths);
    }
    async sequenceDiagramDiff(changedAppMaps) {
        const diffDiagrams = new DiffDiagrams_1.DiffDiagrams();
        const sequenceDiagramDiff = new Map();
        {
            const q = (0, async_1.queue)(async (changedAppMap) => {
                var _a;
                const { appmap } = changedAppMap;
                const sourceDiff = await this.sourceDiff.get(appmap);
                if (sourceDiff)
                    changedAppMap.sourceDiff = sourceDiff;
                const baseDiagram = await (0, loadSequenceDiagram_1.loadSequenceDiagram)(this.changeAnalysis.paths.sequenceDiagramPath(RevisionName_1.RevisionName.Base, appmap));
                const headDiagram = await (0, loadSequenceDiagram_1.loadSequenceDiagram)(this.changeAnalysis.paths.sequenceDiagramPath(RevisionName_1.RevisionName.Head, appmap));
                const diagramDiff = diffDiagrams.diff(baseDiagram, headDiagram);
                if (diagramDiff) {
                    const diagramJSON = (0, sequence_diagram_1.format)(sequence_diagram_1.FormatType.JSON, diagramDiff, 'diff');
                    const path = this.changeAnalysis.paths.sequenceDiagramDiffPath(appmap);
                    await (0, promises_1.mkdir)((0, path_1.dirname)(path), { recursive: true });
                    await (0, promises_1.writeFile)(path, diagramJSON.diagram);
                    changedAppMap.sequenceDiagramDiff = (0, path_1.relative)((0, path_1.join)(this.changeAnalysis.paths.workingDir, 'diff'), path);
                    // Build a text snippet for each top level context.
                    const allActions = [...diagramDiff.rootActions];
                    /* FIXME: this loop probably doesn't do what's intended —
                     * it's equivalent to:
                     *
                     *   diagramDiff.rootActions = [diagramDiff.rootActions[0]];
                     *   const snippet = format(FormatType.Text, diagramDiff, 'diff');
                     *   sequenceDiagramDiff.set(snippet.diagram, [appmap]);
                     *   diagramDiff.rootActions = allActions;
                     *
                     * but it's not clear what the intended behavior is since it's verified
                     * by tests to be this. — divide
                     */
                    // eslint-disable-next-line @typescript-eslint/prefer-for-of
                    for (let actionIndex = 0; actionIndex < diagramDiff.rootActions.length; actionIndex++) {
                        const action = diagramDiff.rootActions[actionIndex];
                        diagramDiff.rootActions = [action];
                        const snippet = (0, sequence_diagram_1.format)(sequence_diagram_1.FormatType.Text, diagramDiff, 'diff');
                        // TODO: nop if this is the empty string
                        if (!sequenceDiagramDiff.has(snippet.diagram))
                            sequenceDiagramDiff.set(snippet.diagram, []);
                        (_a = sequenceDiagramDiff.get(snippet.diagram)) === null || _a === void 0 ? void 0 : _a.push(appmap);
                    }
                    diagramDiff.rootActions = allActions;
                }
            }, 2);
            q.error(console.warn);
            changedAppMaps.forEach((appmap) => q.push(appmap));
            if (!q.idle())
                await q.drain();
        }
        const record = (0, mapToRecord_1.default)(sequenceDiagramDiff);
        for (const key of Object.keys(record)) {
            record[key] = record[key].sort();
        }
        return record;
    }
    async apiDiff(reportRemoved) {
        const baseDefinitions = await this.readOpenAPI(RevisionName_1.RevisionName.Base);
        const headDefinitions = await this.readOpenAPI(RevisionName_1.RevisionName.Head);
        if (!baseDefinitions || !headDefinitions)
            return;
        const diffOpenAPI = async () => {
            try {
                return await openapi_diff_1.default.diffSpecs({
                    sourceSpec: {
                        content: baseDefinitions,
                        location: 'base',
                        format: 'openapi3',
                    },
                    destinationSpec: {
                        content: headDefinitions,
                        location: 'head',
                        format: 'openapi3',
                    },
                });
            }
            catch (e) {
                const message = e instanceof Error ? e.message : `${e}`;
                if (!this.warnings['apiDiff'])
                    this.warnings['apiDiff'] = [];
                this.warnings['apiDiff'].push(`Error comparing OpenAPI definitions: ${message}`);
            }
        };
        let result;
        const computedOpenAPIDiff = await diffOpenAPI();
        if (computedOpenAPIDiff) {
            if (!reportRemoved && computedOpenAPIDiff.breakingDifferencesFound) {
                const diffOutcomeFailure = computedOpenAPIDiff;
                diffOutcomeFailure.breakingDifferencesFound = false;
                delete diffOutcomeFailure['breakingDifferences'];
            }
            if (computedOpenAPIDiff.breakingDifferencesFound) {
                console.log('Breaking change found!');
            }
            result = computedOpenAPIDiff;
        }
        return result;
    }
    async sqlDiff(reportRemoved) {
        var _a, _b, _c, _d;
        const collectStrings = async (revisionName, appmapName, indexFileName, strings) => {
            const indexFilePath = this.changeAnalysis.paths.indexFilePath(revisionName, appmapName, indexFileName);
            if (!(await (0, utils_1.exists)(indexFilePath))) {
                (0, console_1.warn)(`Index file ${indexFilePath} does not exist!`);
                return Promise.resolve();
            }
            const values = JSON.parse(await (0, promises_1.readFile)(indexFilePath, 'utf-8'));
            for (const value of values)
                strings.add(value);
        };
        const loadSQL = async (revisionName, appmaps) => {
            const queryStrings = new Set();
            const tableStrings = new Set();
            if (!appmaps)
                return { queries: queryStrings, tables: tableStrings };
            for (const appmapName of appmaps) {
                await collectStrings(revisionName, appmapName, 'canonical.sqlNormalized.json', queryStrings);
                await collectStrings(revisionName, appmapName, 'canonical.sqlTables.json', tableStrings);
            }
            console.info(`Found ${queryStrings.size} queries and ${tableStrings.size} tables for ${revisionName} revision`);
            return { queries: queryStrings, tables: tableStrings };
        };
        const { queries: baseQueries, tables: baseTables } = await loadSQL(RevisionName_1.RevisionName.Base, this.changeAnalysis.baseAppMaps);
        const { queries: headQueries, tables: headTables } = await loadSQL(RevisionName_1.RevisionName.Head, this.changeAnalysis.headAppMaps);
        const newQueryStrings = [...headQueries].filter((query) => !baseQueries.has(query)).sort();
        const removedQueries = reportRemoved
            ? [...baseQueries].filter((query) => !headQueries.has(query)).sort()
            : [];
        const newTables = [...headTables].filter((table) => !baseTables.has(table)).sort();
        const removedTables = reportRemoved
            ? [...baseTables].filter((table) => !headTables.has(table)).sort()
            : [];
        const newQuerySourceLinesMap = new Map();
        const newQueryAppMapsMap = new Map();
        for (const appmapName of this.changeAnalysis.headAppMaps || []) {
            const indexFilePath = this.changeAnalysis.paths.indexFilePath(RevisionName_1.RevisionName.Head, appmapName, 'canonical.sqlNormalized.json');
            const values = JSON.parse(await (0, promises_1.readFile)(indexFilePath, 'utf-8'));
            const newQueriesInAppMap = new Set();
            for (const value of values) {
                if (newQueryStrings.includes(value)) {
                    if (!newQueryAppMapsMap.has(value)) {
                        newQueryAppMapsMap.set(value, []);
                    }
                    newQueriesInAppMap.add(value);
                    (_a = newQueryAppMapsMap.get(value)) === null || _a === void 0 ? void 0 : _a.push(appmapName);
                }
            }
            const appmapFileName = this.changeAnalysis.paths.appmapPath(RevisionName_1.RevisionName.Head, appmapName);
            if (newQueriesInAppMap.size) {
                const appmap = (0, models_1.buildAppMap)()
                    .source(await (0, promises_1.readFile)(appmapFileName, 'utf-8'))
                    .build();
                const database = appmap.classMap.sqlObject;
                if (!database) {
                    (0, console_1.warn)(`No Database found in AppMap ${appmapFileName}`);
                }
                else {
                    for (const query of database.children) {
                        for (const queryEvent of query.events) {
                            if (queryEvent.sqlQuery && ((_b = queryEvent.sql) === null || _b === void 0 ? void 0 : _b.database_type)) {
                                const sqlNormalized = (0, models_1.normalizeSQL)(queryEvent.sqlQuery, queryEvent.sql.database_type);
                                if (newQueriesInAppMap.has(sqlNormalized)) {
                                    if (!newQuerySourceLinesMap.has(sqlNormalized))
                                        newQuerySourceLinesMap.set(sqlNormalized, []);
                                    let sourcePath;
                                    let sourceLine;
                                    for (const ancestor of queryEvent.ancestors()) {
                                        const { path } = ancestor;
                                        if (!path)
                                            continue;
                                        sourcePath = await (0, resolvePath_1.resolvePath)(path, (_c = appmap.metadata.language) === null || _c === void 0 ? void 0 : _c.name);
                                        if (sourcePath) {
                                            sourceLine = ancestor.lineno;
                                            break;
                                        }
                                    }
                                    if (sourcePath) {
                                        const sourceLocation = [sourcePath, sourceLine].filter(Boolean).join(':');
                                        (_d = newQuerySourceLinesMap.get(sqlNormalized)) === null || _d === void 0 ? void 0 : _d.push(sourceLocation);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        const newQueryAppMaps = [...newQueryAppMapsMap.keys()]
            .sort()
            .reduce((memo, key) => {
            memo.push({
                query: key,
                appmaps: newQueryAppMapsMap.get(key) || [],
                sourceLocations: [...new Set(newQuerySourceLinesMap.get(key) || [])].sort(),
            });
            return memo;
        }, new Array());
        return { newQueries: newQueryAppMaps, removedQueries, newTables, removedTables };
    }
    async readOpenAPI(revision) {
        const openapiPath = this.changeAnalysis.paths.openapiPath(revision);
        try {
            return await (0, promises_1.readFile)(openapiPath, 'utf-8');
        }
        catch (e) {
            if (e.code === 'ENOENT')
                return undefined;
            throw e;
        }
    }
}
exports.default = ReportFieldCalculator;
//# sourceMappingURL=ReportFieldCalculator.js.map