"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = exports.builder = exports.describe = exports.command = void 0;
const async_1 = require("async");
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const glob_1 = require("glob");
const util_1 = require("util");
const handleWorkingDirectory_1 = require("../lib/handleWorkingDirectory");
const sequence_diagram_1 = require("@appland/sequence-diagram");
const utils_1 = require("../utils");
const path_1 = require("path");
const DiffDiagrams_1 = require("../sequenceDiagramDiff/DiffDiagrams");
const readDiagramFile_1 = require("./sequenceDiagram/readDiagramFile");
const promises_2 = require("fs/promises");
exports.command = 'sequence-diagram-diff base-diagram head-diagram';
exports.describe = 'Diff sequence diagrams that are represented as JSON';
const builder = (args) => {
    args.positional('base-diagram', {
        describe: 'base diagram file or directory to compare',
    });
    args.positional('head-diagram', {
        describe: 'head diagram file or directory to compare',
    });
    args.option('directory', {
        describe: 'program working directory',
        type: 'string',
        alias: 'd',
    });
    args.option('output-dir', {
        describe: 'directory in which to save the sequence diagrams',
        default: '.',
    });
    args.option('format', {
        describe: 'output format',
        alias: 'f',
        choices: ['plantuml', 'json', 'text'],
        default: 'plantuml',
    });
    args.option('include', {
        describe: 'code objects to include in the diagram (inclusive of descendants)',
    });
    args.option('exclude', {
        describe: 'code objects to exclude from the diagram',
    });
    args.option('validate', {
        describe: 'enable diagram validation',
        type: 'boolean',
        default: true,
    });
    return args.strict();
};
exports.builder = builder;
async function printDiff(diagram, format, outputFileName, description) {
    const template = (0, sequence_diagram_1.format)(format, diagram, description);
    const outputPath = [outputFileName, template.extension].join('');
    await (0, promises_1.writeFile)(outputPath, template.diagram);
    console.log(`Printed diagram ${outputPath}`);
    return diagram;
}
const handler = async (argv) => {
    (0, utils_1.verbose)(argv.verbose);
    if (!sequence_diagram_1.Formatters.includes(argv.format)) {
        console.log(`Invalid format: ${argv.format}`);
        process.exitCode = 1;
        return;
    }
    (0, handleWorkingDirectory_1.handleWorkingDirectory)(argv.directory);
    await (0, promises_1.mkdir)(argv.outputDir, { recursive: true });
    const { baseDiagram: baseDiagramFile, headDiagram: headDiagramFile } = argv;
    const diffDiagrams = new DiffDiagrams_1.DiffDiagrams();
    if (argv.include)
        (Array.isArray(argv.include) ? argv.include : [argv.include]).forEach((expr) => diffDiagrams.include(expr));
    if (argv.exclude)
        (Array.isArray(argv.exclude) ? argv.exclude : [argv.exclude]).forEach((expr) => diffDiagrams.exclude(expr));
    [baseDiagramFile, headDiagramFile].forEach((fileName) => {
        if (!(0, fs_1.existsSync)(fileName))
            throw new Error(`${fileName} does not exist`);
    });
    const compareFiles = async () => {
        if (argv.validate) {
            const baseValidation = await (0, sequence_diagram_1.validateDiagram)(JSON.parse(await (0, promises_2.readFile)(baseDiagramFile, 'utf-8')));
            const headValidation = await (0, sequence_diagram_1.validateDiagram)(JSON.parse(await (0, promises_2.readFile)(headDiagramFile, 'utf-8')));
            if (baseValidation !== sequence_diagram_1.ValidationResult.Valid || headValidation !== sequence_diagram_1.ValidationResult.Valid) {
                console.error(`Base File: ${baseDiagramFile} is ${baseValidation === sequence_diagram_1.ValidationResult.AppMap ? 'an AppMap' : 'an invalid file'}`);
                console.error(`Head File: ${headDiagramFile} is ${headValidation === sequence_diagram_1.ValidationResult.AppMap ? 'an AppMap' : 'an invalid file'}`);
                if (baseValidation === sequence_diagram_1.ValidationResult.AppMap &&
                    headValidation === sequence_diagram_1.ValidationResult.AppMap) {
                    console.error('You have passed AppMap files. To compare diagrams, run the following commands:');
                    console.error(`appmap sequence-diagram -f json ${baseDiagramFile}`);
                    console.error(`appmap sequence-diagram -f json ${headDiagramFile}`);
                    console.error(`appmap sequence-diagram-diff ${(0, path_1.basename)(baseDiagramFile, '.appmap.json')}.sequence.json ${(0, path_1.basename)(headDiagramFile, '.appmap.json')}.sequence.json`);
                }
                return;
            }
        }
        const baseDiagram = await (0, readDiagramFile_1.readDiagramFile)(baseDiagramFile);
        const headDiagram = await (0, readDiagramFile_1.readDiagramFile)(headDiagramFile);
        const diffDiagram = diffDiagrams.diff(baseDiagram, headDiagram);
        if (!diffDiagram) {
            console.log(`${baseDiagramFile} and ${headDiagramFile} are identical`);
            return;
        }
        printDiff(diffDiagram, argv.format, (0, path_1.join)(argv.outputDir, 'diff'), `Diff ${baseDiagramFile} with ${headDiagramFile}`);
    };
    const compareDirectories = async () => {
        const diagramData = new Map();
        diagramData.set(baseDiagramFile, {
            diagrams: new Map(),
        });
        diagramData.set(headDiagramFile, {
            diagrams: new Map(),
        });
        await Promise.all([...diagramData.keys()].map(async (dirName) => {
            const data = diagramData.get(dirName);
            await (0, util_1.promisify)(glob_1.glob)(`${dirName}/**/*.sequence.json`).then(async (matches) => {
                const loader = (0, async_1.queue)(async (matchName) => {
                    const diagram = await (0, readDiagramFile_1.readDiagramFile)(matchName);
                    const relativePath = matchName.slice(dirName.length + 1);
                    data.diagrams.set(relativePath, diagram);
                }, 2);
                matches.forEach((fileName) => loader.push(fileName));
                if (!loader.idle())
                    await loader.drain();
            });
        }));
        const diagramNames = new Set();
        for (const fileName of diagramData.get(baseDiagramFile).diagrams.keys())
            diagramNames.add(fileName);
        for (const fileName of diagramData.get(headDiagramFile).diagrams.keys())
            diagramNames.add(fileName);
        for (const fileName of diagramNames) {
            const baseDiagram = diagramData.get(baseDiagramFile).diagrams.get(fileName);
            if (baseDiagram === undefined) {
                console.log(`Diagram ${fileName} exists only in ${headDiagramFile}`);
                continue;
            }
            const headDiagram = diagramData.get(headDiagramFile).diagrams.get(fileName);
            if (headDiagram === undefined) {
                console.log(`Diagram ${fileName} exists only in ${baseDiagramFile}`);
                continue;
            }
            const diffDiagram = diffDiagrams.diff(baseDiagram, headDiagram);
            if (!diffDiagram) {
                console.log(`${fileName} is identical`);
                continue;
            }
            printDiff(diffDiagram, argv.format, [fileName, 'diff'].join('.'), `Diff ${fileName}`);
        }
    };
    const isFile = [baseDiagramFile, headDiagramFile].map((fileName) => (0, fs_1.statSync)(fileName).isFile());
    if (isFile.every(Boolean)) {
        await compareFiles();
    }
    else if (isFile.every((b) => !b)) {
        await compareDirectories();
    }
    else {
        throw new Error(`Both arguments must be files, or be directories`);
    }
};
exports.handler = handler;
//# sourceMappingURL=sequenceDiagramDiff.js.map