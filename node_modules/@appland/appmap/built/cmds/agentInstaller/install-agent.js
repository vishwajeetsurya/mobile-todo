"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("node:util/types");
const yargs_1 = __importDefault(require("yargs"));
const fs_1 = require("fs");
const errors_1 = require("../errors");
const utils_1 = require("../../utils");
const agentInstallerProcedure_1 = __importDefault(require("./agentInstallerProcedure"));
const chalk_1 = __importDefault(require("chalk"));
const telemetry_1 = __importDefault(require("../../telemetry"));
const installers_1 = require("./installers");
const projectConfiguration_1 = require("./projectConfiguration");
const commandRunner_1 = require("./commandRunner");
const openTicket_1 = __importDefault(require("../../lib/ticket/openTicket"));
const installerUI_1 = __importDefault(require("./installerUI"));
class InstallerError extends Error {
    constructor(error, duration, project) {
        super();
        this.duration = duration;
        this.project = project;
        this.error = (0, types_1.isNativeError)(error) ? error : new Error(String(error));
        this.log = commandRunner_1.ProcessLog.consumeBuffer();
    }
    get message() {
        if (this.error instanceof errors_1.ValidationError || this.error instanceof errors_1.ChildProcessError) {
            return this.error.message;
        }
        else if ((0, types_1.isNativeError)(this.error)) {
            return this.error.stack || String(this.error);
        }
        return String(this.error);
    }
    async handle(ui) {
        var _a, _b, _c;
        ui.error();
        const installersAvailable = (_a = this.project) === null || _a === void 0 ? void 0 : _a.availableInstallers.map((i) => i.name).join(', ');
        if (this.error instanceof errors_1.AbortError) {
            ui.error(`${chalk_1.default.yellow('!')} Installation has been aborted.`);
            return true;
        }
        else if (this.error instanceof errors_1.InvalidPathError) {
            ui.error(`${chalk_1.default.red('!')} ${this.error.message}`);
            return true;
        }
        else if (this.error instanceof errors_1.UserConfigError) {
            ui.error(`${chalk_1.default.red('!')} Error in project configuration:\n\n${(_b = this.error) === null || _b === void 0 ? void 0 : _b.message}`);
            return true;
        }
        else {
            let exception;
            if (this.error instanceof Error) {
                exception = this.error.stack;
            }
            else {
                exception = String(this.error);
            }
            let directoryContents;
            if ((_c = this.project) === null || _c === void 0 ? void 0 : _c.path) {
                try {
                    directoryContents = (await fs_1.promises.readdir(this.project.path)).join('\n');
                }
                catch (e) {
                    if (e instanceof Error) {
                        directoryContents = e.stack;
                    }
                    else {
                        directoryContents = String(e);
                    }
                }
            }
        }
        return false;
    }
}
const handler = async (args) => {
    var _a;
    const { projectType, directory, verbose: isVerbose, interactive: interactiveArg, overwriteAppmapConfig: overwriteAppMapConfig, installerName, buildFile, } = args;
    const errors = [];
    const installers = installers_1.INSTALLERS.map((constructor) => new constructor(directory));
    (0, utils_1.verbose)(isVerbose);
    const interactive = interactiveArg !== undefined ? interactiveArg : process.stdout.isTTY;
    const ui = new installerUI_1.default(interactive, { overwriteAppMapConfig, installerName, buildFile });
    try {
        const stats = (0, fs_1.statSync)(directory, { throwIfNoEntry: false });
        if (!(stats === null || stats === void 0 ? void 0 : stats.isDirectory())) {
            const msg = `${directory} does not exist or is not a directory.`;
            console.error(`ERROR: ${msg}`);
            return {
                exitCode: 1,
                err: new errors_1.InvalidPathError(msg),
            };
        }
        const projects = await (0, projectConfiguration_1.getProjects)(ui, installers, directory, true, projectType);
        const noopsInvoked = new Set();
        for (const project of projects) {
            if ((_a = project.selectedInstaller) === null || _a === void 0 ? void 0 : _a.isNoop) {
                // make sure we're not duplicating messages
                if (noopsInvoked.has(project.selectedInstaller.name))
                    continue;
                // just give the installer a chance to print a message
                await project.selectedInstaller.installAgent(ui);
                noopsInvoked.add(project.selectedInstaller.name);
                continue;
            }
            const installProcedure = new agentInstallerProcedure_1.default(project.selectedInstaller, project.path);
            ui.message(`Installing AppMap agent for ${chalk_1.default.blue(project.name)}...`);
            try {
                await installProcedure.run(ui);
            }
            catch (e) {
                let installerError = new InstallerError(e, (0, utils_1.endTime)(), project);
                const handled = await installerError.handle(ui);
                if (handled) {
                    return { exitCode: 1, err: e };
                }
                errors.push(installerError);
            }
        }
        if (errors.length) {
            const message = projects.length === 1
                ? 'Installation failed. View error details?'
                : `${errors.length} out of ${projects.length} installations failed. View error details?`;
            if (await ui.shouldShowError(message)) {
                errors.forEach((error) => {
                    var _a;
                    ui.error(projects.length > 1
                        ? (0, utils_1.prefixLines)(error.message, `[${chalk_1.default.red((_a = error.project) === null || _a === void 0 ? void 0 : _a.name)}] `)
                        : error.message);
                });
            }
        }
    }
    catch (err) {
        const installerError = new InstallerError(err, 0, undefined);
        const handled = await installerError.handle(ui);
        if (handled) {
            return { exitCode: 1, err: err };
        }
        errors.push(installerError);
    }
    if (errors.length) {
        if (ui.interactive)
            await (0, openTicket_1.default)(errors.map((e) => e.message));
        const reason = new Error(errors.map((e) => e.message).join('\n'));
        return { exitCode: 1, err: reason };
    }
    return { exitCode: 0, err: null };
};
exports.default = {
    command: 'install [directory]',
    aliases: ['i', 'install-agent'],
    describe: 'Install and configure an AppMap language agent',
    builder(args) {
        args.option('project-type', {
            describe: [
                'Specifies the project dependency manager. Case-insensitive.',
                `Supported project types: ${installers_1.INSTALLER_NAMES.join(', ')}`,
            ].join('\n'),
            type: 'string',
            default: undefined,
            alias: 'p',
        });
        args.option('directory', {
            describe: 'Directory in which to install.',
            type: 'string',
            alias: 'd',
        });
        args.option('interactive', {
            describe: `Whether to interact with the user (assuming there's a TTY).`,
            type: 'boolean',
            default: true,
        });
        args.option('overwrite-appmap-config', {
            describe: `Whether to overwrite the appmap.yml file.`,
            type: 'boolean',
        });
        args.option('installer-name', {
            describe: `Installer name to use, in case of ambiguity.`,
            type: 'string',
        });
        args.option('build-file', {
            describe: `Build file name to use, in case of ambiguity.`,
            type: 'string',
        });
        args.positional('directory', {
            describe: 'Directory in which to install (deprecated; use -d)',
            default: '.',
        });
        return args.strict();
    },
    async handler(args) {
        const { exitCode, err } = await handler(args);
        telemetry_1.default.flush(() => {
            yargs_1.default.exit(exitCode, err);
        });
    },
};
//# sourceMappingURL=install-agent.js.map