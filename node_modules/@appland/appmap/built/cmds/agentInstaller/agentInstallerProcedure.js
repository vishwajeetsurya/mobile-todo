"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_assert_1 = __importDefault(require("node:assert"));
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = __importDefault(require("fs"));
const yargs_1 = __importDefault(require("yargs"));
const errors_1 = require("../errors");
const commandRunner_1 = require("./commandRunner");
const installerUI_1 = require("./installerUI");
const agentProcedure_1 = __importDefault(require("./agentProcedure"));
const commandStruct_1 = __importDefault(require("./commandStruct"));
const ValidationResult_1 = require("./ValidationResult");
const js_yaml_1 = require("js-yaml");
class AgentInstallerProcedure extends agentProcedure_1.default {
    async run(ui) {
        const confirm = ui.confirm([
            `AppMap is about to be installed. Confirm the details below.`,
            await this.getEnvironmentForDisplay(),
            '',
            '  Is this correct?',
        ]
            .flat()
            .join('\n'));
        if (!confirm) {
            ui.status('Aborting installation.');
            ui.error([
                'Modify the installation environment as needed, and re-run the command.',
                `Use ${chalk_1.default.blue('--help')} for more information.`,
            ].join('\n'));
            throw new errors_1.AbortError('aborted while confirming installation environment');
        }
        let useExistingAppMapYml = false;
        let existingConfig;
        if (this.configExists) {
            const overwriteAppMapConfig = await ui.overwriteAppMapConfig();
            if (overwriteAppMapConfig === installerUI_1.OverwriteOption.ABORT) {
                yargs_1.default.exit(0, new Error());
            }
            if (overwriteAppMapConfig === installerUI_1.OverwriteOption.USE_EXISTING) {
                try {
                    existingConfig = this.loadConfig();
                    useExistingAppMapYml = true;
                }
                catch (_a) {
                    throw new errors_1.AbortError('An appmap.yml file exists but is not valid. Please remove it or fix it and try again.');
                }
            }
        }
        ui.status('Installing AppMap...');
        try {
            const filesBeforeGitStatus = await this.gitStatus();
            const filesBefore = [];
            for (const file of filesBeforeGitStatus) {
                filesBefore.push(file.file);
            }
            await this.installer.checkCurrentConfig(ui);
            await this.installer.installAgent(ui);
            await this.verifyProject();
            if (!useExistingAppMapYml) {
                const initCommand = await this.installer.initCommand();
                (0, node_assert_1.default)(initCommand);
                const { stdout } = await (0, commandRunner_1.run)(initCommand);
                const initCommandOutput = JSON.parse(stdout);
                const recommendedConfig = (0, js_yaml_1.load)(initCommandOutput.configuration.contents) || {};
                recommendedConfig.language = this.installer.language;
                recommendedConfig.appmap_dir = this.installer.appmap_dir;
                this.writeConfigFile(recommendedConfig);
            }
            else {
                let dirty = false;
                const updateField = (fieldName) => {
                    if (!existingConfig[fieldName]) {
                        ui.success(`Updating ${fieldName} in appmap.yml`);
                        existingConfig[fieldName] = this.installer[fieldName];
                        dirty = true;
                    }
                };
                ['language', 'appmap_dir'].forEach(updateField);
                if (dirty) {
                    this.writeConfigFile(existingConfig);
                }
            }
            const result = await this.validateProject(ui, useExistingAppMapYml);
            if (ui.interactive)
                await this.commitConfiguration(ui, filesBefore);
            const successMessage = [
                chalk_1.default.green('Success! AppMap has finished installing.'),
                '',
                chalk_1.default.blue('NEXT STEP: Record AppMaps'),
                '',
                'You can consult the AppMap documentation, or continue with the ',
                'instructions provided in the AppMap code editor extension.',
            ];
            ui.success(successMessage.join('\n'));
            if (result === null || result === void 0 ? void 0 : result.errors)
                for (const warning of result.errors.filter((e) => e.level === 'warning'))
                    ui.warn((0, ValidationResult_1.formatValidationError)(warning));
        }
        catch (e) {
            const error = e;
            console.log(error === null || error === void 0 ? void 0 : error.message);
            if (this.installer.name === 'Bundler') {
                if (error === null || error === void 0 ? void 0 : error.message.includes('but is an incompatible architecture')) {
                    await (0, commandRunner_1.run)(new commandStruct_1.default('gem', ['uninstall', 'appmap', '-x', '--force'], this.path));
                    const incompatibleArchitectureMessage = [
                        '\n',
                        chalk_1.default.bold.red('AppMap Installation Error!'),
                        '',
                        'Please run the following command in your terminal, then re-run the installer:',
                        '',
                        chalk_1.default.blue('bundle'),
                        '\n',
                    ];
                    ui.error(incompatibleArchitectureMessage.join('\n'));
                }
                else if (error === null || error === void 0 ? void 0 : error.message.includes('without the test and development groups')) {
                    const bundlerConfigErrorMessage = [
                        '\n',
                        chalk_1.default.bold.red('AppMap Installation Error!'),
                        '',
                        'Please ensure that bundler installs either the development group,',
                        'the test group, or both. We suggest running the following command',
                        'in your terminal and then re-running the installer:',
                        '',
                        chalk_1.default.blue('bundle install --with development'),
                        '\n',
                        'For more information, see the bundler docs: ' +
                            'https://bundler.io/man/bundle-install.1.html',
                        '',
                    ];
                    ui.error(bundlerConfigErrorMessage.join('\n'));
                }
                else {
                    throw e;
                }
            }
            else {
                throw e;
            }
        }
    }
    writeConfigFile(config) {
        fs_1.default.writeFileSync(this.configPath, (0, js_yaml_1.dump)(config));
    }
}
exports.default = AgentInstallerProcedure;
//# sourceMappingURL=agentInstallerProcedure.js.map