"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = require("path");
const js_yaml_1 = __importDefault(require("js-yaml"));
const chalk_1 = __importDefault(require("chalk"));
const errors_1 = require("../errors");
const commandRunner_1 = require("./commandRunner");
const validator_1 = require("../../service/config/validator");
const commandStruct_1 = __importDefault(require("./commandStruct"));
const ValidationResult_1 = require("./ValidationResult");
class AgentProcedure {
    constructor(installer, path) {
        this.installer = installer;
        this.path = path;
    }
    async getEnvironmentForDisplay() {
        // TS is ok with this written as let env:[name: string]: string = {...}, but
        // babel doesn't like it. Splitting it up this way keeps them both happy:
        let env;
        env = {
            'Project type': this.installer.name,
            'Project directory': (0, path_1.resolve)(this.path),
        };
        let gitRemote;
        try {
            const stdout = (0, commandRunner_1.runSync)(new commandStruct_1.default('git', ['remote', '-v'], this.installer.path));
            if (stdout.length > 0) {
                gitRemote = stdout.split('\n')[0];
            }
            else {
                gitRemote = '[no remote]';
            }
        }
        catch (e) {
            const gitError = e.message.split('\n')[1];
            gitRemote = `[git remote failed, ${gitError}]`;
        }
        env['Git remote'] = gitRemote;
        if (this.installer.environment) {
            env = Object.assign(Object.assign({}, env), (await this.installer.environment()));
        }
        return Object.entries(env)
            .filter(([_, value]) => Boolean(value))
            .map(([key, value]) => `  ${chalk_1.default.blue(key)}: ${value.trim()}`);
    }
    async verifyProject() {
        const verifyCommand = await this.installer.verifyCommand();
        if (verifyCommand) {
            await (0, commandRunner_1.run)(verifyCommand);
        }
    }
    async validateAgent(ui, cmd) {
        try {
            return (0, commandRunner_1.run)(cmd);
        }
        catch (e) {
            ui.error('Failed to validate the installation.');
            throw e;
        }
    }
    async validateProject(ui, checkSyntax) {
        const validateCmd = await this.installer.validateAgentCommand();
        if (!validateCmd) {
            return;
        }
        ui.status('Validating the AppMap agent...');
        let { stdout } = await this.validateAgent(ui, validateCmd);
        const validationResult = (0, ValidationResult_1.parseValidationResult)(stdout);
        const errors = (validationResult.errors || []).filter((e) => e.level === 'error');
        if (errors.length > 0) {
            throw new errors_1.ValidationError(errors.map(ValidationResult_1.formatValidationError).join('\n'));
        }
        const { schema } = validationResult;
        // If appmap-agent-validate returned a schema, and we're using an
        // existing appmap.yml, verify that the config matches the schema.
        if (schema && checkSyntax) {
            ui.status(`Checking the syntax of AppMap agent configuration...`);
            const config = this.loadConfig();
            const result = (0, validator_1.validateConfig)(schema, config);
            if (!result.valid) {
                const errors = result.errors;
                const lines = errors.cli.split('\n').slice(2, 4);
                // type in IOutputError is wrong, says the member is called dataPath?
                lines[1] += ` (${errors.js[0]['path']})`;
                throw new errors_1.ValidationError(`\n${this.configPath}:\n${lines.join('\n')}`);
            }
        }
        return validationResult;
    }
    async gitStatus(file) {
        let files = [];
        let params = ['status', '-s'];
        if (file !== undefined) {
            params.push(file);
        }
        let stdout = '';
        try {
            stdout = (0, commandRunner_1.runSync)(new commandStruct_1.default('git', params, this.installer.path));
        }
        catch (e) {
            const gitError = e.message.split('\n')[1];
            const gitStatus = `[git status failed, ${gitError}]`;
            // may want to print the error
        }
        if (stdout && stdout.length > 0) {
            // git status output looks like this:
            //  M Gemfile
            //  M Gemfile.lock
            // ?? appmap.yml
            const lines = stdout.split('\n');
            for (const line of lines) {
                const gitStatus = line.substring(0, 2);
                const file = line.substring(3);
                files.push({
                    file: file,
                    status: gitStatus,
                });
            }
        }
        return files;
    }
    async gitAdd(files) {
        let params = ['add'];
        for (const file of files) {
            params.push(file);
        }
        try {
            const stdout = (0, commandRunner_1.runSync)(new commandStruct_1.default('git', params, this.installer.path));
            return {
                success: true,
                errorMessage: '',
            };
        }
        catch (e) {
            const gitError = e.message.split('\n')[1];
            const gitAdd = `[git add failed, ${gitError}]`;
            // may want to print the error
            return {
                success: false,
                errorMessage: gitAdd,
            };
        }
    }
    async gitCommit(files, commitMessage) {
        let params = ['commit', '-m', commitMessage];
        for (const file of files) {
            params.push(file);
        }
        try {
            const stdout = (0, commandRunner_1.runSync)(new commandStruct_1.default('git', params, this.installer.path));
            return {
                success: true,
                errorMessage: '',
            };
        }
        catch (e) {
            const gitError = e.message.split('\n')[1];
            const gitCommit = `[git commit failed, ${gitError}]`;
            // may want to print the error
            return {
                success: false,
                errorMessage: gitCommit,
            };
        }
    }
    async commitConfiguration(ui, filesBefore) {
        const filesAfterGitStatus = await this.gitStatus();
        const filesAfter = [];
        for (const file of filesAfterGitStatus) {
            filesAfter.push(file.file);
        }
        let filesDiff = [];
        filesDiff = filesAfter.filter((file) => !filesBefore.includes(file));
        filesDiff.sort();
        if (filesDiff.length == 0)
            return false;
        let filesMessages = [];
        for (const file of filesDiff) {
            filesMessages.push(`  ${chalk_1.default.blue(file)}`);
        }
        const commit = await ui.commitConfiguration([
            `Commit these files to your repo so that everyone on your team can use AppMap`,
            `  without them having to repeat the setup process. Bring runtime code analysis`,
            `  to your whole team!`,
            filesMessages,
            '  ',
            '  Commit?',
        ]
            .flat()
            .join('\n'));
        if (commit) {
            // gitAdd is idempotent, and necessary to add to git appmap.yml,
            // Gemfile.lock etc. when the installer runs for the first time
            const addGitReturn = await this.gitAdd(filesDiff);
            if (!addGitReturn.success) {
                ui.error(addGitReturn.errorMessage);
            }
            const commitGitReturn = await this.gitCommit(filesDiff, `Configure AppMap for this project

AppMap is a free and open-source runtime code analysis tool.

AppMap has been installed and configured using the installation instructions at:
https://appmap.io/docs/install-appmap-agent.html using the automated
installer tool:
        npx @appland/appmap@latest install`);
            if (!commitGitReturn.success) {
                ui.error(commitGitReturn.errorMessage);
            }
            return commitGitReturn.success;
        }
        return false;
    }
    loadConfig() {
        // yaml.load returns undefined if the input string is empty
        const configContent = fs_1.default.readFileSync(this.configPath, 'utf8');
        return js_yaml_1.default.load(configContent) || {};
    }
    get configExists() {
        return fs_1.default.existsSync(this.configPath);
    }
    get configPath() {
        return (0, path_1.resolve)((0, path_1.join)(this.path, 'appmap.yml'));
    }
}
exports.default = AgentProcedure;
//# sourceMappingURL=agentProcedure.js.map