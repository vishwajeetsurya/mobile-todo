"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runSync = exports.run = exports.ProcessLog = void 0;
const child_process_1 = require("child_process");
const path_1 = __importDefault(require("path"));
const chalk_1 = __importDefault(require("chalk"));
const utils_1 = require("../../utils");
const errors_1 = require("../errors");
class ProcessLog {
    static log(command, childProcess) {
        var _a, _b;
        this.buffer = this.buffer.concat(`\n\nRunning command: \`${command}\`\n\n`);
        (_a = childProcess.stdout) === null || _a === void 0 ? void 0 : _a.on('data', (data) => {
            this.buffer = this.buffer.concat(data);
        });
        (_b = childProcess.stderr) === null || _b === void 0 ? void 0 : _b.on('data', (data) => {
            this.buffer = this.buffer.concat(data);
        });
    }
    static recordExit(program, code, signal) {
        this.buffer.concat(`\n\n'${program}' exited with code ${code}, signal ${signal}\n\n`);
    }
    // Return the current buffer and clear it for future use
    static consumeBuffer() {
        const buffer = this.buffer;
        this.buffer = '';
        return buffer;
    }
}
exports.ProcessLog = ProcessLog;
ProcessLog.buffer = '';
class CommandOutput {
    constructor() {
        this.chunks = [];
    }
    append(stream, data) {
        this.chunks.push({ stream, data });
    }
    get stdout() {
        return this.chunks
            .filter((chunk) => chunk.stream === 'stdout')
            .map((chunk) => chunk.data)
            .join('');
    }
    get stderr() {
        return this.chunks
            .filter((chunk) => chunk.stream === 'stderr')
            .map((chunk) => chunk.data)
            .join('');
    }
    get all() {
        return this.chunks.map((chunk) => chunk.data).join('');
    }
}
async function run(command) {
    return new Promise((resolve, reject) => {
        var _a, _b, _c, _d;
        const cp = (0, child_process_1.spawn)(command.program, command.args, {
            shell: true,
            env: command.environment,
            cwd: command.path,
        });
        let output = new CommandOutput();
        if ((0, utils_1.verbose)()) {
            console.log([
                `Running command: \`${chalk_1.default.yellow(command.toString())}\``,
                `cwd: ${chalk_1.default.yellow(path_1.default.resolve(command.path))}`,
                `environment: ${chalk_1.default.yellow(JSON.stringify(command.environment, undefined, 2))}`,
            ].join('\n'));
            (_a = cp.stderr) === null || _a === void 0 ? void 0 : _a.pipe(process.stderr);
            (_b = cp.stdout) === null || _b === void 0 ? void 0 : _b.pipe(process.stdout);
        }
        (_c = cp.stderr) === null || _c === void 0 ? void 0 : _c.on('data', (data) => {
            output.append('stderr', data.toString());
        });
        (_d = cp.stdout) === null || _d === void 0 ? void 0 : _d.on('data', (data) => {
            output.append('stdout', data.toString());
        });
        ProcessLog.log(command.toString(), cp);
        cp.on('error', (err) => {
            if (err['code'] === 'ENOENT') {
                reject(new errors_1.ChildProcessError(command.toString(), `${command.program} was not found. Verify the command can be found in your PATH and try again.`));
            }
            reject(err);
        });
        cp.on('exit', (code, signal) => {
            if ((0, utils_1.verbose)()) {
                console.log(`'${command.program}' exited with code ${code}`);
            }
            ProcessLog.recordExit(command.program, code, signal);
            if (code === 0) {
                return resolve({
                    stdout: output.stdout,
                    stderr: output.stderr,
                });
            }
            return reject(new errors_1.ChildProcessError(command.toString(), output.all, code));
        });
    });
}
exports.run = run;
function runSync(command) {
    const ret = (0, child_process_1.execSync)(command.toString(), {
        env: command.environment,
        cwd: command.path,
        stdio: 'pipe',
    });
    return ret.toString();
}
exports.runSync = runSync;
//# sourceMappingURL=commandRunner.js.map