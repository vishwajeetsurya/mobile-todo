"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = require("path");
const chalk_1 = __importDefault(require("chalk"));
const commandStruct_1 = __importDefault(require("./commandStruct"));
const utils_1 = require("../../utils");
const sourceUtil_1 = require("./sourceUtil");
const errors_1 = require("../errors");
const javaBuildToolInstaller_1 = __importDefault(require("./javaBuildToolInstaller"));
const gradleParser_1 = require("./gradleParser");
const encodedFile_1 = __importDefault(require("../../encodedFile"));
class GradleInstaller extends javaBuildToolInstaller_1.default {
    constructor(path) {
        super(GradleInstaller.identifier, path);
    }
    get language() {
        return 'java';
    }
    get appmap_dir() {
        return 'tmp/appmap';
    }
    get buildGradleFileName() {
        return 'build.gradle';
    }
    get buildGradleKtsFileName() {
        return 'build.gradle.kts';
    }
    get buildFile() {
        return this.buildGradleFileName;
    }
    get buildFilePath() {
        return (0, path_1.join)(this.path, this.identifyGradleFile);
    }
    /**
     * If a build.gradle.kts file is present in the project, the installer will
     * choose that file as the build file.
     * If not, the installer will pick the build.gradle.
     */
    get identifyGradleFile() {
        const buildGradleKtsExists = fs_1.default.existsSync((0, path_1.join)(this.path, this.buildGradleKtsFileName));
        return buildGradleKtsExists ? this.buildGradleKtsFileName : this.buildGradleFileName;
    }
    async printJarPathCommand() {
        return new commandStruct_1.default(await this.runCommand(), ['appmap-print-jar-path'], this.path);
    }
    async available() {
        return await (0, utils_1.exists)(this.buildFilePath);
    }
    async runCommand() {
        const ext = os_1.default.platform() === 'win32' ? '.bat' : '';
        const wrapperExists = await (0, utils_1.exists)((0, path_1.join)(this.path, `gradlew${ext}`));
        if (wrapperExists) {
            return `.${path_1.sep}gradlew${ext}`;
        }
        else if ((0, utils_1.verbose)()) {
            console.warn(`${chalk_1.default.yellow(`gradlew${ext} wrapper`)} not located, falling back to ${chalk_1.default.yellow(`gradle${ext}`)}`);
        }
        return 'gradle';
    }
    async verifyCommand() {
        return new commandStruct_1.default(await this.runCommand(), [
            'dependencyInsight',
            '--dependency',
            'com.appland:appmap-agent',
            '--configuration',
            'appmapAgent',
            '--stacktrace',
        ], this.path);
    }
    /**
     * Add the com.appland.appmap plugin to build.gradle.
     *
     * Start by looking for an existing plugins block. If found, add our plugin to
     * it. If there's no plugins block, look for a buildscript block. If found,
     * insert a new plugins block after it. (Gradle requires that the plugins
     * block appear after the buildscript block, and before any other blocks.)
     *
     * If there's no plugins block, and no buildscript block, append a new plugins
     * block.
     *
     * @returns {updatedSrc: string, offset: number} updatedSrc is the source
     * updated to reference the plugin, offset is the index in the original source
     * from which copying should continue
     */
    async insertPluginSpec(ui, buildFileSource, parseResult, whitespace) {
        const pluginSpec = this.selectPluginSpec();
        const lines = parseResult.plugins
            ? buildFileSource
                .substring(parseResult.plugins.lbrace + 1, parseResult.plugins.rbrace)
                .split('\n')
                .map((line) => line.trim())
                .filter((line) => line !== '')
            : [];
        const javaPresent = lines.some((line) => line.match(/^\s*id\s+["']\s*java/));
        if (!javaPresent) {
            const userWillContinue = await ui.continueWithoutJavaPlugin();
            if (!userWillContinue) {
                throw new errors_1.AbortError('no java plugin found');
            }
        }
        // Missing plugin block, so no java plugin, but the user opted to continue.
        if (!parseResult.plugins) {
            const pluginsBlock = `
plugins {
${whitespace.padLine(pluginSpec)}
}
`;
            const buildscriptEnd = parseResult.buildscript
                ? parseResult.buildscript.rbrace + 1
                : parseResult.startOffset;
            const updatedSrc = [buildFileSource.substring(0, buildscriptEnd), pluginsBlock].join(os_1.default.EOL);
            const offset = buildscriptEnd;
            return { updatedSrc, offset };
        }
        // Found plugin block, update it with plugin spec
        const existingIndex = lines.findIndex((line) => line.match(/com\.appland\.appmap/));
        if (existingIndex !== -1) {
            lines[existingIndex] = pluginSpec;
        }
        else {
            lines.push(pluginSpec);
        }
        const updatedSrc = [
            buildFileSource.substring(0, parseResult.plugins.lbrace + 1),
            lines.map((l) => whitespace.padLine(l)).join(os_1.default.EOL),
            '}',
        ].join(os_1.default.EOL);
        const offset = parseResult.plugins.rbrace + 1;
        return { updatedSrc, offset };
    }
    selectPluginSpec() {
        const pluginSpecKotlinSyntax = `id("com.appland.appmap") version "1.2.0"`;
        const pluginSpecGroovySyntax = `id 'com.appland.appmap' version '1.2.0'`;
        return this.identifyGradleFile.endsWith('.gradle.kts')
            ? pluginSpecKotlinSyntax
            : pluginSpecGroovySyntax;
    }
    /**
     * Ensure the build file contains a buildscript block with mavenCentral in its
     * repositories.
     *
     * Returns a portion of the updated source, including everything through the
     * rbrace of the buildscript block. Also returns the offset into the original
     * source from which copying should continue.
     */
    async insertRepository(ui, buildFileSource, updatedSrc, offset, parseResult, whitespace) {
        if (parseResult.mavenPresent) {
            // mavenPresent means there's already a repositories block with
            // mavenCentral in it, so just copy the rest of the original.
            return { updatedSrc, offset };
        }
        const addMavenCentral = await ui.addMavenCentral();
        if (!addMavenCentral) {
            return { updatedSrc, offset };
        }
        const mavenCentral = `mavenCentral()`;
        if (!parseResult.repositories) {
            const repositoriesBlock = `
repositories {
${whitespace.padLine(mavenCentral)}
}
`;
            updatedSrc += repositoriesBlock;
            return { updatedSrc, offset };
        }
        updatedSrc = [
            updatedSrc,
            buildFileSource.substring(offset, parseResult.repositories.rbrace),
            whitespace.padLine(mavenCentral),
        ].join('');
        offset = parseResult.repositories.rbrace - 1;
        return { updatedSrc, offset };
    }
    // TODO: validate the user's project before adding AppMap
    async checkConfigCommand(_ui) {
        return undefined;
    }
    async installAgent(ui) {
        const encodedFile = new encodedFile_1.default(this.buildFilePath);
        const buildFileSource = encodedFile.toString();
        const parser = new gradleParser_1.GradleParser();
        const parseResult = parser.parse(buildFileSource);
        parser.checkSyntax(parseResult);
        const whitespace = (0, sourceUtil_1.getWhitespace)(buildFileSource);
        let { updatedSrc, offset } = await this.insertPluginSpec(ui, buildFileSource, parseResult, whitespace);
        ({ updatedSrc, offset } = await this.insertRepository(ui, buildFileSource, updatedSrc, offset, parseResult, whitespace));
        updatedSrc += buildFileSource.substring(offset);
        encodedFile.write(updatedSrc);
    }
}
exports.default = GradleInstaller;
GradleInstaller.identifier = 'Gradle';
//# sourceMappingURL=gradleInstaller.js.map