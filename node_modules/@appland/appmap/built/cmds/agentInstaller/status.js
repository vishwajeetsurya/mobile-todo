"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const yargs_1 = __importDefault(require("yargs"));
const utils_1 = require("../../utils");
const chalk_1 = __importDefault(require("chalk"));
const userInteraction_1 = __importDefault(require("../userInteraction"));
const installers_1 = require("./installers");
const agentStatusProcedure_1 = __importDefault(require("./agentStatusProcedure"));
const projectConfiguration_1 = require("./projectConfiguration");
const installerUI_1 = __importDefault(require("./installerUI"));
exports.default = {
    command: 'status [directory]',
    aliases: ['s'],
    describe: 'Check the status of the current project for the AppMap language agent',
    builder(args) {
        // FIXME: This method takes advantage of the fact that each implementation returns a static string
        // as the installer name. In the future, this may not be the case. After all, `name` is a non-static
        // getter.
        const installerNames = installers_1.INSTALLERS.map((installer) => chalk_1.default.blue(installer.prototype.name)).join(', ');
        args.option('project-type', {
            describe: [
                'Specifies the status target. This may be a language or project framework. Case-insensitive.',
                `Supported project types: ${installerNames}`,
            ].join('\n'),
            type: 'string',
            default: undefined,
            alias: 'p',
        });
        args.positional('directory', {
            describe: 'directory to check',
            default: '.',
        });
        return args.strict();
    },
    async handler(args) {
        const { projectType, directory, verbose: isVerbose } = args;
        const installers = installers_1.INSTALLERS.map((constructor) => new constructor(directory));
        (0, utils_1.verbose)(isVerbose);
        const ui = new installerUI_1.default(false, { overwriteAppMapConfig: false });
        try {
            const [project] = await (0, projectConfiguration_1.getProjects)(ui, installers, directory, false, projectType);
            const statusProcedure = new agentStatusProcedure_1.default(project.selectedInstaller, directory);
            await statusProcedure.run(ui);
        }
        catch (e) {
            const err = e;
            userInteraction_1.default.error(err.message);
            yargs_1.default.exit(1, err);
        }
    },
};
//# sourceMappingURL=status.js.map