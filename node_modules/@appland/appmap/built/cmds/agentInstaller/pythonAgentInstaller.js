"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PipInstaller = exports.PipenvInstaller = exports.PoetryInstaller = void 0;
/* eslint-disable class-methods-use-this */
/* eslint-disable max-classes-per-file */
const chalk_1 = __importDefault(require("chalk"));
const glob_1 = require("glob");
const minimatch_1 = __importDefault(require("minimatch"));
const os_1 = __importDefault(require("os"));
const path_1 = require("path");
const semver_1 = __importDefault(require("semver"));
const encodedFile_1 = __importDefault(require("../../encodedFile"));
const utils_1 = require("../../utils");
const errors_1 = require("../errors");
const agentInstaller_1 = __importDefault(require("./agentInstaller"));
const commandRunner_1 = require("./commandRunner");
const commandStruct_1 = __importDefault(require("./commandStruct"));
const commandUtil_1 = require("./commandUtil");
const REGEX_PKG_DEPENDENCY = /^\s*appmap\s*[=>~]+=.*$/m;
// include .dev0 so pip will allow prereleases
const PKG_DEPENDENCY = 'appmap>=1.1.0.dev0';
class PythonInstaller extends agentInstaller_1.default {
    constructor(name, path) {
        super(name, path);
    }
    get language() {
        return 'python';
    }
    get appmap_dir() {
        return 'tmp/appmap';
    }
    get documentation() {
        return 'https://appland.com/docs/reference/appmap-python';
    }
    async environment() {
        // Python version is returned as a string similar to:
        // Python 3.7.0
        const version = await (0, commandUtil_1.getOutput)('python3', ['--version'], this.path);
        const pythonPath = await (0, commandUtil_1.getOutput)('python3', ['-c', 'import sys; print(sys.prefix)'], this.path);
        return {
            'Python version': version.ok ? version.output.split(/\s/)[1] : chalk_1.default.red(version.output),
            'Python package directory': pythonPath.ok ? pythonPath.output : chalk_1.default.red(pythonPath.output),
        };
    }
}
class PoetryInstaller extends PythonInstaller {
    constructor(path) {
        super(PoetryInstaller.identifier, path);
    }
    get buildFile() {
        return 'poetry.lock';
    }
    get buildFilePath() {
        return (0, path_1.join)(this.path, this.buildFile);
    }
    async available() {
        return (0, utils_1.exists)(this.buildFilePath);
    }
    async initCommand() {
        return new commandStruct_1.default('poetry', ['run', 'appmap-agent-init'], this.path);
    }
    async checkConfigCommand(_ui) {
        return new commandStruct_1.default('poetry', ['install', '--dry-run'], this.path);
    }
    async installAgent() {
        const cmd = new commandStruct_1.default('poetry', ['add', '--dev', '--allow-prereleases', 'appmap'], this.path);
        await (0, commandRunner_1.run)(cmd);
    }
    async verifyCommand() {
        return undefined;
    }
    async validateCommand() {
        return undefined;
    }
    async validateAgentCommand() {
        return undefined;
    }
}
exports.PoetryInstaller = PoetryInstaller;
PoetryInstaller.identifier = 'poetry';
class PipenvInstaller extends PythonInstaller {
    constructor(path) {
        super(PipenvInstaller.identifier, path);
    }
    get buildFile() {
        return 'Pipfile.lock';
    }
    get buildFilePath() {
        return (0, path_1.join)(this.path, this.buildFile);
    }
    async available() {
        const ret = await (0, utils_1.exists)(this.buildFilePath);
        return ret;
    }
    async initCommand() {
        return new commandStruct_1.default('pipenv', ['run', 'appmap-agent-init'], this.path);
    }
    async checkConfigCommand(_ui) {
        return new commandStruct_1.default('pipenv', ['install', '--dev'], this.path);
    }
    async installAgent(_ui) {
        const cmd = new commandStruct_1.default('pipenv', ['install', '--dev', '--pre', 'appmap'], this.path);
        await (0, commandRunner_1.run)(cmd);
    }
    async verifyCommand() {
        return undefined;
    }
    async validateCommand() {
        return undefined;
    }
    async validateAgentCommand() {
        return undefined;
    }
}
exports.PipenvInstaller = PipenvInstaller;
PipenvInstaller.identifier = 'pipenv';
class PipInstaller extends PythonInstaller {
    constructor(path) {
        super(PipInstaller.identifier, path);
        this._buildFile = 'requirements.txt';
    }
    get buildFile() {
        return this._buildFile;
    }
    get buildFilePath() {
        return (0, path_1.join)(this.path, this.buildFile);
    }
    async available() {
        return (0, utils_1.isFile)(this.buildFilePath);
    }
    findBuildFiles() {
        return glob_1.glob.sync('*requirements*.txt', {
            matchBase: true,
            cwd: this.path,
            nodir: true,
        });
    }
    async chooseBuildFile(ui, choices) {
        const defaultChoice = choices.filter((f) => (0, minimatch_1.default)(f, '*dev*', { matchBase: true }));
        const buildFile = await ui.pythonBuildFile(defaultChoice[0], choices);
        return (0, path_1.basename)(buildFile);
    }
    async resolveBuildFile(ui) {
        const choices = this.findBuildFiles();
        if (choices.length === 1) {
            return choices[0];
        }
        else {
            ui.message(`

This project contains multiple Pip requirements files. AppMap should only be
installed during development and testing, not when deploying in a production
environment.
`);
            return this.chooseBuildFile(ui, choices);
        }
    }
    async checkConfigCommand(ui) {
        this._buildFile = await this.resolveBuildFile(ui);
        let commandArgs = ['-m', 'pip', 'install', '-r', this.buildFile];
        let supportsDryRun;
        try {
            const pipVersionOutput = await (0, commandUtil_1.getOutput)('python3', ['-m', 'pip', '--version'], this.path);
            const pipVersion = semver_1.default.coerce(pipVersionOutput.output);
            if (!pipVersion) {
                throw new errors_1.UserConfigError('Could not detect pip version');
            }
            supportsDryRun = semver_1.default.satisfies(pipVersion, '>= 22.2.0');
        }
        catch (err) {
            throw new errors_1.UserConfigError(err);
        }
        if (supportsDryRun) {
            commandArgs.push('--dry-run');
        }
        return new commandStruct_1.default('python3', commandArgs, this.path);
    }
    async installAgent(_ui) {
        const encodedFile = new encodedFile_1.default(this.buildFilePath);
        let requirements = encodedFile.toString();
        const pkgExists = requirements.search(REGEX_PKG_DEPENDENCY) !== -1;
        if (pkgExists) {
            // Replace the existing package declaration entirely.
            requirements = requirements.replace(REGEX_PKG_DEPENDENCY, PKG_DEPENDENCY);
        }
        else {
            // Insert a new package declaration.
            // eslint-disable-next-line prefer-template
            requirements = PKG_DEPENDENCY + os_1.default.EOL + requirements;
        }
        encodedFile.write(requirements);
        const cmd = new commandStruct_1.default('python3', ['-m', 'pip', 'install', '-r', this.buildFile], this.path);
        await (0, commandRunner_1.run)(cmd);
    }
    async initCommand() {
        return new commandStruct_1.default('python3', ['-m', 'appmap.command.appmap_agent_init'], this.path);
    }
    async verifyCommand() {
        return undefined;
    }
    async validateCommand() {
        return undefined;
    }
    async validateAgentCommand() {
        return undefined;
    }
}
exports.PipInstaller = PipInstaller;
PipInstaller.identifier = 'pip';
//# sourceMappingURL=pythonAgentInstaller.js.map