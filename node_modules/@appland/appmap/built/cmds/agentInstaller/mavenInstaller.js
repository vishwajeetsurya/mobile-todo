"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const os_1 = __importDefault(require("os"));
const path_1 = require("path");
const jsdom_1 = require("jsdom");
const w3c_xmlserializer_1 = __importDefault(require("w3c-xmlserializer"));
const chalk_1 = __importDefault(require("chalk"));
const commandStruct_1 = __importDefault(require("./commandStruct"));
const utils_1 = require("../../utils");
const javaBuildToolInstaller_1 = __importDefault(require("./javaBuildToolInstaller"));
const encodedFile_1 = __importDefault(require("../../encodedFile"));
class MavenInstaller extends javaBuildToolInstaller_1.default {
    constructor(path) {
        super(MavenInstaller.identifier, path);
    }
    get language() {
        return 'java';
    }
    get appmap_dir() {
        return 'tmp/appmap';
    }
    get buildFile() {
        return 'pom.xml';
    }
    get buildFilePath() {
        return (0, path_1.join)(this.path, this.buildFile);
    }
    async available() {
        return await (0, utils_1.exists)(this.buildFilePath);
    }
    runCommand() {
        const ext = os_1.default.platform() === 'win32' ? '.cmd' : '';
        const wrapperExists = (0, fs_1.existsSync)((0, path_1.join)(this.path, `mvnw${ext}`));
        if (wrapperExists) {
            return `.${path_1.sep}mvnw${ext}`;
        }
        else if ((0, utils_1.verbose)()) {
            console.warn(`${chalk_1.default.yellow(`mvnw${ext} wrapper`)} not found, falling back to ${chalk_1.default.yellow(`mvn${ext}`)}`);
        }
        return `mvn${ext}`;
    }
    async verifyCommand() {
        return new commandStruct_1.default(this.runCommand(), ['-Dplugin=com.appland:appmap-maven-plugin', 'help:describe'], this.path);
    }
    async printJarPathCommand() {
        return new commandStruct_1.default(this.runCommand(), ['appmap:print-jar-path'], this.path);
    }
    // TODO: validate the user's project before adding AppMap
    async checkConfigCommand(_ui) {
        return undefined;
    }
    async installAgent(_ui) {
        const encodedFile = new encodedFile_1.default(this.buildFilePath);
        const buildFileSource = encodedFile.toString();
        const jsdom = new jsdom_1.JSDOM();
        const domParser = new jsdom.window.DOMParser();
        const doc = domParser.parseFromString(buildFileSource, 'text/xml');
        const pluginVersion = '1.3.0';
        const defaultns = 'http://maven.apache.org/POM/4.0.0';
        const createEmptySection = (tag, ns) => {
            const xmlString = `<${tag} xmlns="${ns}">
  </${tag}>
`;
            const xmlNode = domParser.parseFromString(xmlString, 'application/xml').getRootNode();
            return xmlNode.childNodes[0];
        };
        const projectSection = doc.evaluate('/project', doc, doc.createNSResolver(doc.getRootNode()), 9 /* FIRST_ORDERED_NODE_TYPE */).singleNodeValue;
        if (!projectSection) {
            // Doesn't make sense to be missing the <project> section
            throw new Error(`No project section found in ${this.buildFilePath}`);
        }
        const ns = projectSection.namespaceURI || defaultns;
        const pluginString = `
      <plugin xmlns="${ns}">
          <groupId>com.appland</groupId>
          <artifactId>appmap-maven-plugin</artifactId>
          <version>${pluginVersion}</version>
          <executions>
              <execution>
                  <phase>process-test-classes</phase>
                  <goals>
                      <goal>prepare-agent</goal>
                  </goals>
              </execution>
          </executions>
      </plugin>
`;
        let buildSection = doc.evaluate('/project/build', doc, doc.createNSResolver(doc.getRootNode()), 9).singleNodeValue;
        if (!buildSection) {
            buildSection = createEmptySection('build', ns);
            projectSection.appendChild(buildSection);
            projectSection.appendChild(doc.createTextNode(os_1.default.EOL));
        }
        let pluginsSection = doc.evaluate('/project/build/plugins', doc, doc.createNSResolver(doc.getRootNode()), 9).singleNodeValue;
        if (!pluginsSection) {
            pluginsSection = createEmptySection('plugins', ns);
            buildSection.appendChild(pluginsSection);
            buildSection.appendChild(doc.createTextNode(os_1.default.EOL));
        }
        const appmapPlugin = doc.evaluate(`/project/build/plugins/plugin[groupId/text() = 'com.appland' and artifactId/text() = 'appmap-maven-plugin']`, doc, doc.createNSResolver(doc.getRootNode()), 9).singleNodeValue;
        if (appmapPlugin) {
            let version = appmapPlugin.querySelector('version');
            if (!version) {
                version = doc.createElementNS(ns, 'version');
                appmapPlugin.appendChild(version);
            }
            version.textContent = pluginVersion;
        }
        else {
            const pluginNode = domParser.parseFromString(pluginString, 'application/xml').getRootNode();
            while (pluginNode.childNodes.length > 0) {
                const node = pluginNode.childNodes[0];
                pluginsSection.appendChild(node);
            }
            pluginsSection.appendChild(doc.createTextNode(os_1.default.EOL));
        }
        const serialized = (0, w3c_xmlserializer_1.default)(doc.getRootNode());
        encodedFile.write(serialized);
    }
}
exports.default = MavenInstaller;
MavenInstaller.identifier = 'Maven';
//# sourceMappingURL=mavenInstaller.js.map