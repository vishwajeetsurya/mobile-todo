"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const assert_1 = __importDefault(require("assert"));
const Reporter_1 = require("./Reporter");
const ReportTemplate_1 = require("../../report/ReportTemplate");
const ChangeReport_1 = require("../compare-report/ChangeReport");
const readIndexFile_1 = __importDefault(require("../inventory/readIndexFile"));
const loadReportTemplate_1 = __importDefault(require("../../report/loadReportTemplate"));
const urlHelpers_1 = __importDefault(require("../../report/urlHelpers"));
const helpers_1 = __importDefault(require("../../report/helpers"));
const handlebars_1 = require("handlebars");
async function buildReportData(inventoryReport, findingLimit) {
    const distinctRuleIds = new Set();
    const findingRules = inventoryReport.findings.reduce((acc, f) => {
        if (f.impactDomain && !distinctRuleIds.has(f.ruleId)) {
            distinctRuleIds.add(f.ruleId);
            acc.push({ ruleId: f.ruleId, impactDomain: f.impactDomain });
        }
        return acc;
    }, new Array());
    findingRules.sort((a, b) => a.ruleId.localeCompare(b.ruleId));
    const findingRuleCountByImpactDomain = findingRules.reduce((acc, rule) => {
        const { impactDomain: domain } = rule;
        if (domain) {
            if (!acc[domain])
                acc[domain] = 1;
            else
                acc[domain] = acc[domain] + 1;
        }
        return acc;
    }, {});
    const findingCount = inventoryReport.findings.length;
    const findings = inventoryReport.findings.slice(0, findingLimit);
    const scanResultsByAppMap = new Map();
    const loadScanResults = async (appmap) => {
        let scanResults = scanResultsByAppMap.get(appmap);
        if (scanResults)
            return scanResults;
        scanResults = (await (0, readIndexFile_1.default)(appmap, 'appmap-findings.json'));
        scanResultsByAppMap[appmap] = scanResults;
        return scanResults;
    };
    const lookupFinding = async (appmap, hash) => {
        const scanResults = await loadScanResults(appmap);
        const finding = scanResults.findings.find((finding) => finding.hash_v2 === hash);
        (0, assert_1.default)(finding);
        return finding;
    };
    const newFindings = [];
    for (const findingExample of findings) {
        const metadata = await (0, readIndexFile_1.default)(findingExample.appmap, 'metadata.json');
        const appmap = new ChangeReport_1.AppMap(findingExample.appmap, metadata);
        const finding = await lookupFinding(findingExample.appmap, findingExample.hash_v2);
        newFindings.push({ appmap, finding });
    }
    return {
        findingRules,
        findingRuleCountByImpactDomain,
        findingCount,
        findings: newFindings,
    };
}
class SummaryReporter {
    constructor(appmapURL, sourceURL) {
        this.appmapURL = appmapURL;
        this.sourceURL = sourceURL;
    }
    async generateReport(reportData) {
        (0, assert_1.default)(Reporter_1.TemplateDirectory);
        const templateText = await (0, loadReportTemplate_1.default)((0, path_1.join)(Reporter_1.TemplateDirectory, 'summary', 'summary.hbs'));
        const template = new ReportTemplate_1.ReportTemplate(templateText, Object.assign(Object.assign(Object.assign({}, SummaryReporter.helpers()), helpers_1.default), (0, urlHelpers_1.default)({ appmapURL: this.appmapURL, sourceURL: this.sourceURL })));
        const report = await buildReportData(reportData, 10);
        return template.generateMarkdown(report);
    }
    static helpers() {
        const rule_url = (rule) => {
            return new handlebars_1.SafeString(`[${rule}](https://appmap.io/docs/reference/rules/${rule})`);
        };
        const time_ago = (...dates) => {
            const firstDate = dates.find(Boolean);
            if (!firstDate)
                return 'an unknown time';
            const date = firstDate instanceof Date ? firstDate : new Date(firstDate);
            // Written by Copilot. Looks right to me.
            const seconds = Math.floor((new Date().getTime() - date.getTime()) / 1000);
            let interval = Math.floor(seconds / 31536000);
            if (interval > 1)
                return `${interval} years`;
            interval = Math.floor(seconds / 2592000);
            if (interval > 1)
                return `${interval} months`;
            interval = Math.floor(seconds / 86400);
            if (interval > 1)
                return `${interval} days`;
            interval = Math.floor(seconds / 3600);
            if (interval > 1)
                return `${interval} hours`;
            interval = Math.floor(seconds / 60);
            if (interval > 1)
                return `${interval} minutes`;
            return `${Math.floor(seconds)} seconds`;
        };
        return { rule_url, time_ago };
    }
}
exports.default = SummaryReporter;
//# sourceMappingURL=SummaryReporter.js.map