"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.downloadFile = exports.GitHubArchiveStore = exports.FileArchiveStore = void 0;
const glob_1 = require("glob");
const path_1 = require("path");
const util_1 = require("util");
const rest_1 = require("@octokit/rest");
const promises_1 = require("fs/promises");
const fs_1 = require("fs");
const os_1 = require("os");
const executeCommand_1 = require("../../lib/executeCommand");
const assert_1 = __importDefault(require("assert"));
const https_1 = require("https");
class FileArchiveStore {
    constructor(directory) {
        this.directory = directory;
    }
    async revisionsAvailable() {
        const parseArchivePath = (path) => {
            var _a;
            // Example archive path: .appmap/archive/full/2c51afaae3cc355e4bac499e9b68ea1d3dc1b36a.tar
            // Extract archive type and revision from the path
            const archiveTokens = path.split('/');
            const revision = (_a = archiveTokens.pop()) === null || _a === void 0 ? void 0 : _a.split('.')[0];
            const type = archiveTokens.pop();
            (0, assert_1.default)(type && revision);
            return { id: path, type, revision };
        };
        const loadDirectory = async (directory) => {
            const resolvedDir = (0, path_1.resolve)(process.cwd(), directory);
            return (await (0, util_1.promisify)(glob_1.glob)((0, path_1.join)(resolvedDir, '*.tar')))
                .map(parseArchivePath)
                .reduce((memo, entry) => (memo.set(entry.id, parseArchivePath(entry.id)), memo), new Map());
        };
        const full = await loadDirectory((0, path_1.join)(this.directory, 'full'));
        const incremental = await loadDirectory((0, path_1.join)(this.directory, 'incremental'));
        return { full, incremental };
    }
    // The archive is already stored in the file system, so just return the path.
    async fetch(archiveId) {
        return archiveId;
    }
}
exports.FileArchiveStore = FileArchiveStore;
class GitHubArchiveStore {
    constructor(repository, token) {
        this.repository = repository;
        this.token = token;
        const tokens = repository.split('/');
        if (tokens.length < 2)
            throw new Error(`Invalid repository name: ${repository}`);
        this.repo = tokens.pop().split('.')[0];
        this.owner = tokens.pop();
        this.octokit = new rest_1.Octokit({
            auth: this.token,
        });
    }
    async revisionsAvailable() {
        const { owner, repo } = this;
        const result = {
            full: new Map(),
            incremental: new Map(),
        };
        for (let page = 1;; page++) {
            const response = (await this.octokit.rest.actions.listArtifactsForRepo({
                owner,
                repo,
                page,
                per_page: 100,
            })).data;
            if (response.artifacts.length === 0)
                break;
            for (const artifact of response.artifacts) {
                // TODO: Use id or node_id?
                const { id, name } = artifact;
                // Example archive name: appmap-archive-full_2c51afaae3cc355e4bac499e9b68ea1d3dc1b36a.tar
                // Extract archive type and revision from the name
                const matchResult = /appmap-archive-(\w+)_(\w+)\.tar/.exec(name);
                if (!matchResult)
                    continue;
                let archives;
                const archiveType = matchResult[1];
                const revision = matchResult[2];
                if (archiveType === 'full') {
                    archives = result.full;
                }
                else if (archiveType === 'incremental') {
                    archives = result.incremental;
                }
                if (archives)
                    archives.set(id.toString(), {
                        id: id.toString(),
                        type: archiveType,
                        revision,
                    });
                else
                    console.warn(`Unknown archive type '${archiveType}' in artifact '${name}'`);
            }
        }
        return result;
    }
    async fetch(archiveId) {
        const { owner, repo } = this;
        const { url: artifactUrl } = await this.octokit.rest.actions.downloadArtifact({
            owner,
            repo,
            artifact_id: parseInt(archiveId, 10),
            archive_format: 'zip',
        });
        (0, assert_1.default)(artifactUrl, `No location header in response for artifact ${archiveId}`);
        const tempDir = await (0, promises_1.mkdtemp)((0, path_1.join)((0, os_1.tmpdir)(), 'appmap-'));
        process.on('exit', () => (0, promises_1.rm)(tempDir, { recursive: true, force: true }));
        const tempFile = (0, path_1.join)(tempDir, 'archive.zip');
        await downloadFile(new URL(artifactUrl), tempFile);
        await (0, executeCommand_1.executeCommand)(`unzip -o -d ${tempDir} ${tempFile}`);
        const filesAvailable = await (0, util_1.promisify)(glob_1.glob)([tempDir, '**', '*.tar'].join('/'), {
            dot: true,
        });
        if (filesAvailable.length === 0)
            throw new Error(`No *.tar found in GitHub artifact ${archiveId}`);
        if (filesAvailable.length > 1)
            throw new Error(`Multiple *.tar found in GitHub artifact ${archiveId}`);
        return filesAvailable.pop();
    }
}
exports.GitHubArchiveStore = GitHubArchiveStore;
async function downloadFile(url, path) {
    const file = (0, fs_1.createWriteStream)(path);
    return new Promise((resolve, reject) => {
        (0, https_1.get)(url, function (response) {
            response.pipe(file);
            file.on('finish', () => {
                file.close();
                resolve();
            });
        }).on('error', function (err) {
            (0, promises_1.unlink)(path);
            reject(err);
        });
    });
}
exports.downloadFile = downloadFile;
//# sourceMappingURL=archiveStore.js.map