"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = exports.builder = exports.describe = exports.command = void 0;
const assert_1 = __importDefault(require("assert"));
const fs_1 = require("fs");
const glob_1 = require("glob");
const path_1 = require("path");
const util_1 = require("util");
const handleWorkingDirectory_1 = require("../../lib/handleWorkingDirectory");
const utils_1 = require("../../utils");
const archiveStore_1 = require("./archiveStore");
const gitAncestors_1 = __importDefault(require("./gitAncestors"));
const gitRevision_1 = __importDefault(require("./gitRevision"));
const unpackArchive_1 = __importDefault(require("./unpackArchive"));
exports.command = 'restore';
exports.describe = 'Restore the most current available AppMap data from available archives';
const builder = (args) => {
    args.option('directory', {
        describe: 'program working directory',
        type: 'string',
        alias: 'd',
    });
    args.option('revision', {
        describe: `revision to restore`,
        type: 'string',
        alias: 'r',
    });
    args.option('output-dir', {
        describe: 'directory in which to restore the data. Default: .appmap/work/<revision>',
        type: 'string',
    });
    args.option('archive-dir', {
        describe: 'directory in which the archives are stored',
        type: 'string',
        default: '.appmap/archive',
    });
    args.option('github-repo', {
        describe: 'Fetch AppMap archives from artifacts on a GitHub repository. GITHUB_TOKEN must be set for this option to work.',
        type: 'string',
    });
    args.option('exact', {
        describe: 'fail unless the specific revision requested is available to be restored',
        type: 'boolean',
        default: false,
    });
    args.option('check', {
        describe: 'only check to see if the specific revision requested is available to be restored',
        type: 'boolean',
        default: false,
    });
    return args.strict();
};
exports.builder = builder;
const handler = async (argv) => {
    (0, utils_1.verbose)(argv.verbose);
    (0, handleWorkingDirectory_1.handleWorkingDirectory)(argv.directory);
    const { revision: revisionArg, outputDir: outputDirArg, githubRepo, archiveDir, exact, check, } = argv;
    const revision = revisionArg !== undefined ? revisionArg.toString() : await (0, gitRevision_1.default)();
    const outputDir = outputDirArg || (0, path_1.join)('.appmap', 'work', revision);
    if ((0, fs_1.existsSync)(outputDir))
        throw new Error(`Output directory ${outputDir} already exists`);
    console.log(`Restoring AppMaps of revision ${revision} to ${outputDir}`);
    let archiveStore;
    if (githubRepo) {
        const token = process.env.GITHUB_TOKEN;
        if (!token)
            throw new Error('GITHUB_TOKEN must be set to use the --github-repo option');
        archiveStore = new archiveStore_1.GitHubArchiveStore(githubRepo, token);
    }
    else {
        archiveStore = new archiveStore_1.FileArchiveStore(archiveDir);
    }
    const archivesAvailable = await archiveStore.revisionsAvailable();
    if ((0, utils_1.verbose)())
        console.debug(`Found ${(0, util_1.inspect)(archivesAvailable)} AppMap archives`);
    let ancestors;
    let mostRecentArchiveAvailable = [
        ...archivesAvailable.full.values(),
    ].find((archive) => archive.revision === revision);
    if (mostRecentArchiveAvailable) {
        console.log(`Found exact match full AppMap archive ${revision}`);
        if (check) {
            console.log(`Check option is enabled, not continuing to download.`);
            process.exit(0);
        }
    }
    else {
        ancestors = await (0, gitAncestors_1.default)(revision);
        {
            const ancestorIndex = ancestors.reduce((memo, revision, index) => ((memo[revision] = index), memo), {});
            let mostRecentAncestorIndex;
            for (const archive of archivesAvailable.full.values()) {
                const index = ancestorIndex[archive.revision];
                if (index !== undefined &&
                    (mostRecentAncestorIndex === undefined || index < mostRecentAncestorIndex)) {
                    mostRecentAncestorIndex = index;
                    mostRecentArchiveAvailable = archive;
                }
            }
        }
        if (!mostRecentArchiveAvailable)
            throw new Error(`No full AppMap archive found in the ancestry of ${revision}`);
    }
    console.log(`Using revision ${mostRecentArchiveAvailable.revision} as the baseline`);
    const fullArchivePath = await archiveStore.fetch(mostRecentArchiveAvailable.id);
    console.log(`Restoring full archive revision '${mostRecentArchiveAvailable.revision}' from '${fullArchivePath}' to '${outputDir}'`);
    await (0, unpackArchive_1.default)(outputDir, fullArchivePath);
    let restoredRevision = mostRecentArchiveAvailable.revision;
    const restoredRevisions = [restoredRevision];
    if (mostRecentArchiveAvailable.revision !== revision) {
        (0, assert_1.default)(ancestors);
        const baseRevisionIndex = ancestors.indexOf(mostRecentArchiveAvailable.revision);
        (0, assert_1.default)(baseRevisionIndex !== -1);
        const ancestorsAfterBaseRevision = new Set(ancestors.slice(0, baseRevisionIndex));
        const incrementalArchivesAvailable = (await (0, util_1.promisify)(glob_1.glob)((0, path_1.join)(archiveDir, 'incremental', '*.tar'))).filter((archive) => {
            const revision = (0, path_1.basename)(archive, '.tar');
            return ancestorsAfterBaseRevision.has(revision);
        });
        console.log(`Applying incremental archives ${incrementalArchivesAvailable.join(', ')}`);
        for (const archive of incrementalArchivesAvailable) {
            const incrementalRevision = (0, path_1.basename)(archive, '.tar');
            restoredRevision = incrementalRevision;
            restoredRevisions.push(restoredRevision);
            await (0, unpackArchive_1.default)(outputDir, archive);
        }
    }
    if (exact) {
        if (restoredRevisions[restoredRevisions.length - 1] !== revision) {
            throw new Error(`Unable to restore specific revision ${revision}; applied ${restoredRevisions.join(', ')}.`);
        }
    }
    console.log(`Restore complete`);
};
exports.handler = handler;
//# sourceMappingURL=restore.js.map