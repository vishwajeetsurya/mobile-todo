"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.index = void 0;
const processAppMapDir_1 = __importDefault(require("../../lib/processAppMapDir"));
const utils_1 = require("../../utils");
const path_1 = require("path");
const promises_1 = require("fs/promises");
const emitUsage_1 = __importDefault(require("../../lib/emitUsage"));
async function index(workerPool, maxAppMapSizeInBytes, appMapDir, oversizedAppMaps, failedTests) {
    const task = (file) => ({
        name: 'index',
        verbose: (0, utils_1.verbose)(),
        appmapFile: file,
        maxSize: maxAppMapSizeInBytes,
    });
    const startTime = new Date().getTime();
    let sampleMetadata;
    let totalEvents = 0;
    const result = await (0, processAppMapDir_1.default)('Indexing AppMaps', workerPool, task, appMapDir, undefined, async (_appmap, { result: { metadata, numEvents } }) => {
        if (!sampleMetadata)
            sampleMetadata = metadata;
        totalEvents += numEvents;
    });
    if (sampleMetadata) {
        await (0, emitUsage_1.default)(appMapDir, totalEvents, result.numProcessed, sampleMetadata);
    }
    const elapsed = new Date().getTime() - startTime;
    console.log(`Indexed ${result.numProcessed} AppMaps in ${elapsed}ms`);
    for (const file of result.oversized)
        oversizedAppMaps.add(file);
    const metadataFiles = await (0, utils_1.findFiles)(appMapDir, (file) => (0, path_1.basename)(file) === 'metadata.json');
    for (const file of metadataFiles) {
        const metadata = JSON.parse(await (0, promises_1.readFile)(file, 'utf-8'));
        const appmapFile = [(0, path_1.dirname)(file), '.appmap.json'].join('');
        if (metadata.test_status === 'failed')
            failedTests.add(appmapFile);
    }
}
exports.index = index;
//# sourceMappingURL=index.js.map