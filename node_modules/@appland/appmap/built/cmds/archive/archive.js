"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = exports.builder = exports.describe = exports.command = exports.PackageVersion = exports.ArchiveVersion = void 0;
const child_process_1 = require("child_process");
const path_1 = require("path");
const handleWorkingDirectory_1 = require("../../lib/handleWorkingDirectory");
const locateAppMapDir_1 = require("../../lib/locateAppMapDir");
const utils_1 = require("../../utils");
const promises_1 = require("fs/promises");
const fileSizeFilter_1 = require("../../lib/fileSizeFilter");
const loadAppMapConfig_1 = __importDefault(require("../../lib/loadAppMapConfig"));
const fingerprinter_1 = require("../../fingerprint/fingerprinter");
const chalk_1 = __importDefault(require("chalk"));
const gitRevision_1 = __importDefault(require("./gitRevision"));
const analyze_1 = __importDefault(require("./analyze"));
const parseFilterArgs_1 = __importDefault(require("./parseFilterArgs"));
const os_1 = require("os");
const console_1 = require("console");
const buildWorkerPool_1 = __importDefault(require("./buildWorkerPool"));
const _1 = require(".");
const fs_1 = require("fs");
const generateOpenAPI_1 = __importDefault(require("./generateOpenAPI"));
// ## 1.3.0
//
// * AppMap scanner is run on all AppMaps, with an appmap-findings.json file stored in each index directory.
//
// ## 1.2.0
//
// * Update format of compare fliters.
//
// ## 1.1.1
//
// * SQL actions in sequence diagram - digest is a fixed value if the SQL string is truncated.
//
// ## 1.1.0
//
// * Added appMapFilter to the archive metadata.
exports.ArchiveVersion = '1.3.0';
exports.PackageVersion = {
    name: '@appland/appmap',
    version: process.env.npm_package_version,
};
exports.command = 'archive';
exports.describe = 'Build an AppMap archive from a directory containing AppMaps';
const builder = (args) => {
    args.option('directory', {
        describe: 'program working directory',
        type: 'string',
        alias: 'd',
    });
    args.option('type', {
        describe: 'archive type',
        choices: ['full', 'incremental', 'auto'],
        default: 'auto',
        alias: 't',
    });
    args.option('revision', {
        describe: `revision identifier.
    
If not explicitly specified, the current git revision will be used.
When this command is used in an CI server, it's best to explicitly the provide the revision
from an environment variable provided by the CI system, such as GITHUB_HEAD_SHA, because the
commit of the current git revision may not be the one that triggered the build.`,
        type: 'string',
        alias: 'r',
    });
    args.option('output-dir', {
        describe: `directory in which to save the output file. By default, it's .appmap/archive/<type>.`,
        type: 'string',
    });
    args.option('output-file', {
        describe: 'output file name. Default output name is <revision>.tar',
        type: 'string',
        alias: 'f',
    });
    args.option('analyze', {
        describe: 'whether to analyze the AppMaps',
        type: 'boolean',
        alias: 'index',
        default: true,
    });
    args.option('max-size', {
        describe: 'maximum AppMap size that will be processed, in filesystem-reported MB',
        default: fileSizeFilter_1.DefaultMaxAppMapSizeInMB,
    });
    args.option('filter', {
        describe: 'filter to apply to AppMaps when normalizing them into sequence diagrams',
        type: 'string',
        multiple: true,
    });
    args.option('thread-count', {
        describe: 'Number of worker threads to use when analyzing AppMaps',
        type: 'number',
    });
    return args.strict();
};
exports.builder = builder;
const handler = async (argv) => {
    let finalizers = [];
    (0, utils_1.verbose)(argv.verbose);
    if (!process.env.npm_package_version)
        console.log(`Note: The AppMap archive won't contain the version of @appland/appmap because process.env.npm_package_version is not available.`);
    const { maxSize, analyze: doAnalyze, type: typeArg, revision: revisionArg, outputFile: outputFileNameArg, outputDir: outputDirArg, filter: filterArg, threadCount: threadCountArg, } = argv;
    (0, handleWorkingDirectory_1.handleWorkingDirectory)(argv.directory);
    const workingDirectory = process.cwd();
    const appmapConfig = await (0, loadAppMapConfig_1.default)();
    if (!appmapConfig)
        throw new Error(`Unable to load appmap.yml config file`);
    const appMapDir = await (0, locateAppMapDir_1.locateAppMapDir)();
    const threadCount = threadCountArg || (0, os_1.cpus)().length;
    const compareConfig = appmapConfig.compare;
    const compareFilter = (compareConfig === null || compareConfig === void 0 ? void 0 : compareConfig.filter) || {};
    if (filterArg)
        (0, parseFilterArgs_1.default)(compareFilter, typeof filterArg === 'string' ? [filterArg] : filterArg);
    const maxAppMapSizeInBytes = Math.round(parseFloat(maxSize) * 1024 * 1024);
    console.log(`Building '${typeArg}' archive from ${appMapDir}`);
    const revision = revisionArg !== undefined ? revisionArg : await (0, gitRevision_1.default)();
    console.log(`Building archive of revision ${revision}`);
    const versions = { archive: exports.ArchiveVersion, index: fingerprinter_1.VERSION };
    if (exports.PackageVersion.version)
        versions[exports.PackageVersion.name] = exports.PackageVersion.version;
    const failedTests = new Set();
    const oversizedAppMaps = new Set();
    if (doAnalyze) {
        (0, console_1.warn)(`Analyzing AppMaps using ${threadCount} worker threads`);
        const workerPool = (0, buildWorkerPool_1.default)(threadCount);
        // Index all AppMaps first, so that we can determine which AppMaps are failed tests.
        // If there are test failures, perform a limited analysis that only includes sequence diagrams
        // of the failed tests. Otherwise, perform a full analysis.
        //
        // Scanner findings are not meaningful for failed tests, so we skip doing that
        // work and avoid misleading or confusing the user.
        try {
            await (0, _1.index)(workerPool, maxAppMapSizeInBytes, appMapDir, oversizedAppMaps, failedTests);
            let doScan = true;
            if (failedTests.size > 0) {
                (0, console_1.warn)(`${failedTests.size} AppMaps are failed tests. Analysis which depends on all tests passing will be skipped.`);
                doScan = false;
            }
            else {
                (0, console_1.log)(`No AppMaps are failed tests, so all AppMaps will be analyzed.`);
            }
            await (0, analyze_1.default)(workerPool, maxAppMapSizeInBytes, compareFilter, appMapDir, oversizedAppMaps, doScan);
        }
        finally {
            finalizers.push(workerPool.close());
        }
    }
    else {
        await (0, generateOpenAPI_1.default)(appMapDir, maxAppMapSizeInBytes);
    }
    process.chdir(appMapDir);
    const metadata = {
        versions,
        workingDirectory,
        appMapDir,
        commandArguments: argv,
        revision,
        timestamp: Date.now().toString(),
        failedTests: [...failedTests].sort(),
        oversizedAppMaps: [...oversizedAppMaps].sort(),
        config: appmapConfig,
    };
    let type;
    if (await (0, utils_1.exists)('appmap_archive.json')) {
        const existingMetadata = JSON.parse(await (0, promises_1.readFile)('appmap_archive.json', 'utf8'));
        const { revision: baseRevision } = existingMetadata;
        if (typeArg === 'auto') {
            console.log(`The AppMap directory contains appmap_archive.json, so the archive type will be 'incremental'.
The base revision is ${baseRevision}.`);
        }
        if (typeArg === 'full') {
            console.warn(chalk_1.default.yellow(`\nThe AppMap directory contains appmap_archive.json, so it looks like the directory contains incremental AppMaps
that build on revision ${baseRevision}. However, you've specified --type=full. You should
remove appmap_archive.json if your intention is to build a full archive. Otherwise, use --type=auto or --type=incremental.\n`));
            type = 'full';
        }
        else {
            metadata.baseRevision = baseRevision;
            type = 'incremental';
        }
    }
    else {
        if (typeArg === 'auto') {
            console.log(`The AppMap directory does not contain appmap_archive.json, so the archive type will be 'full'.`);
        }
        else if (typeArg === 'incremental') {
            throw new Error(`AppMap directory does not contain appmap_archive.json, but you've specified --type=incremental.
The base revision cannot be determined, so either use --type=auto or --type=full.`);
        }
        type = 'full';
    }
    await new Promise((resolveCB, rejectCB) => {
        (0, child_process_1.exec)(`tar czf appmaps.tar.gz --exclude openapi.yml --exclude appmaps.tar.gz --exclude appmap_archive.json *`, (error) => {
            if (error)
                return rejectCB(error);
            resolveCB();
        });
    });
    process.on('exit', () => (0, promises_1.unlink)('appmaps.tar.gz'));
    await (0, promises_1.writeFile)('appmap_archive.json', JSON.stringify(metadata, null, 2));
    const outputFileName = outputFileNameArg || `${revision}.tar`;
    const defaultOutputDir = () => (0, path_1.join)('.appmap', 'archive', type);
    const outputDir = outputDirArg || defaultOutputDir();
    await (0, promises_1.mkdir)((0, path_1.resolve)(workingDirectory, outputDir), { recursive: true });
    {
        let tarCommand = `tar cf ${(0, path_1.join)((0, path_1.resolve)(workingDirectory, outputDir), outputFileName)} appmap_archive.json appmaps.tar.gz`;
        if ((0, fs_1.existsSync)('openapi.yml'))
            tarCommand += ' openapi.yml';
        await new Promise((resolveCB, rejectCB) => {
            (0, child_process_1.exec)(tarCommand, (error) => {
                if (error)
                    return rejectCB(error);
                resolveCB();
            });
        });
    }
    console.log(`Created AppMap archive ${(0, path_1.join)(outputDir, outputFileName)}`);
    await Promise.all(finalizers);
};
exports.handler = handler;
//# sourceMappingURL=archive.js.map