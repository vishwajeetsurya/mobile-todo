"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterFindings = void 0;
const console_1 = require("console");
const ReportSection_1 = require("./ReportSection");
class FailedTestsPreprocessor {
    constructor(report) {
        this.report = report;
    }
    get numElements() {
        return this.report.testFailures.length;
    }
    prune(numElements) {
        return { testFailures: this.report.testFailures.slice(0, numElements) };
    }
}
class OpenAPIDiffPreprocessor {
    constructor(openapiDiff) {
        this.openapiDiff = openapiDiff;
    }
    get numElements() {
        return this.openapiDiff.differenceCount;
    }
    prune(numElements) {
        const openapiDiff = Object.assign({}, this.openapiDiff);
        let numRemaining = numElements;
        {
            numRemaining -= openapiDiff.breakingDifferences.length;
            openapiDiff.breakingDifferences = openapiDiff.breakingDifferences.slice(0, numElements);
        }
        if (numRemaining > 0) {
            numRemaining -= openapiDiff.nonBreakingDifferences.length;
            openapiDiff.nonBreakingDifferences = openapiDiff.nonBreakingDifferences.slice(0, numElements);
        }
        else {
            openapiDiff.nonBreakingDifferences = [];
        }
        if (numRemaining > 0) {
            numRemaining -= openapiDiff.unclassifiedDifferences.length;
            openapiDiff.unclassifiedDifferences = openapiDiff.unclassifiedDifferences.slice(0, numElements);
        }
        else {
            openapiDiff.unclassifiedDifferences = [];
        }
        return { openapiDiff };
    }
}
class SQLDiffPreprocessor {
    constructor(sqlDiff) {
        this.sqlDiff = sqlDiff;
    }
    get numElements() {
        return (this.sqlDiff.newQueries.length +
            this.sqlDiff.removedQueries.length +
            this.sqlDiff.newTables.length +
            this.sqlDiff.removedTables.length);
    }
    prune(numElements) {
        const sqlDiff = Object.assign({}, this.sqlDiff);
        const keys = ['newQueries', 'removedQueries', 'newTables', 'removedTables'];
        for (const key of keys) {
            let numRemaining = numElements;
            if (numRemaining > 0) {
                numRemaining -= sqlDiff[key].length;
                sqlDiff[key] = sqlDiff[key].slice(0, numElements);
            }
            else {
                sqlDiff[key] = [];
            }
        }
        return { sqlDiff };
    }
}
const SECTION_INCLUDE_DOMAINS = {
    'performance-problems': ['Performance'],
    'security-flaws': ['Security'],
};
const SECTION_EXCLUDE_DOMAINS = {
    'code-antipatterns': ['Security', 'Performance'],
};
function filterFindings(findings, section) {
    const includeDomains = SECTION_INCLUDE_DOMAINS[section];
    const excludeDomains = SECTION_EXCLUDE_DOMAINS[section];
    return findings.filter((finding) => (!includeDomains || includeDomains.includes(finding.finding.impactDomain || 'Stability')) &&
        (!(excludeDomains === null || excludeDomains === void 0 ? void 0 : excludeDomains.includes(finding.finding.impactDomain || 'Stability'))));
}
exports.filterFindings = filterFindings;
class FindingDiffPreprocessor {
    constructor(findingDiff, section) {
        this.findingDiff = findingDiff;
        this.section = section;
        this.newFindings = filterFindings(this.findingDiff.newFindings || [], section);
        this.resolvedFindings = filterFindings(this.findingDiff.resolvedFindings || [], section);
    }
    get numElements() {
        return this.newFindings.length + this.resolvedFindings.length;
    }
    prune(numElements) {
        const findingDiff = { newFindings: this.newFindings, resolvedFindings: this.resolvedFindings };
        let numRemaining = numElements;
        {
            numRemaining -= findingDiff.newFindings.length;
            findingDiff.newFindings = findingDiff.newFindings.slice(0, numElements);
        }
        if (numRemaining > 0) {
            numRemaining -= findingDiff.resolvedFindings.length;
            findingDiff.resolvedFindings = findingDiff.resolvedFindings.slice(0, numElements);
        }
        else {
            findingDiff.resolvedFindings = [];
        }
        return { findingDiff };
    }
}
class NewAppMapsPreprocessor {
    constructor(report) {
        this.report = report;
    }
    get numElements() {
        return this.report.newAppMaps.length;
    }
    prune(numElements) {
        return {
            newAppMaps: this.report.newAppMaps.slice(0, numElements),
        };
    }
}
class RemovedAppMapsPreprocessor {
    constructor(report) {
        this.report = report;
    }
    get numElements() {
        return this.report.removedAppMaps.length;
    }
    prune(numElements) {
        return {
            removedAppMaps: this.report.removedAppMaps.slice(0, numElements),
        };
    }
}
class ChangedAppMapsPreprocessor {
    constructor(report) {
        this.report = report;
    }
    get numElements() {
        return Object.keys(this.report.changedAppMaps).length;
    }
    prune(numElements) {
        const retainKeys = Object.keys(this.report.changedAppMaps).slice(0, numElements);
        return {
            changedAppMaps: retainKeys.reduce((memo, key) => ((memo[key] = this.report.changedAppMaps[key]), memo), {}),
        };
    }
}
function buildPreprocessor(section, report) {
    switch (section) {
        case ReportSection_1.Section.FailedTests:
            return new FailedTestsPreprocessor(report);
        case ReportSection_1.Section.OpenAPIDiff:
            return report.openapiDiff ? new OpenAPIDiffPreprocessor(report.openapiDiff) : undefined;
        case ReportSection_1.Section.SecurityFlaws:
        case ReportSection_1.Section.CodeAntiPatterns:
        case ReportSection_1.Section.PerformanceProblems:
            return report.findingDiff
                ? new FindingDiffPreprocessor(report.findingDiff, section)
                : undefined;
        case ReportSection_1.Section.NewAppMaps:
            return new NewAppMapsPreprocessor(report);
        case ReportSection_1.Section.RemovedAppMaps:
            return new RemovedAppMapsPreprocessor(report);
        case ReportSection_1.ExperimentalSection.ChangedAppMaps:
            return new ChangedAppMapsPreprocessor(report);
        case ReportSection_1.ExperimentalSection.SQLDiff:
            return report.sqlDiff ? new SQLDiffPreprocessor(report.sqlDiff) : undefined;
        default:
            (0, console_1.warn)(`No Preprocessor for section ${section}`);
    }
}
exports.default = buildPreprocessor;
//# sourceMappingURL=Preprocessor.js.map