"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FindingDiff = exports.OpenAPIDiff = exports.TestFailure = exports.AppMap = void 0;
const assert_1 = __importDefault(require("assert"));
const sql_formatter_1 = require("sql-formatter");
const RevisionName_1 = require("../../diffArchive/RevisionName");
const executeCommand_1 = require("../../lib/executeCommand");
const utils_1 = require("../../utils");
const normalizeAppMapId_1 = __importDefault(require("../../lib/normalizeAppMapId"));
const formatAPILocation_1 = __importDefault(require("./formatAPILocation"));
function sqlFormat(query) {
    try {
        return (0, sql_formatter_1.format)(query);
    }
    catch (e) {
        return query;
    }
}
class AppMap {
    constructor(
    // id is a unique identifier for the AppMap. It's essentially the path to the AppMap
    // index directory, relative to the appmap_dir. For example, for an AppMap file
    // 'tmp/appmap/minitest/Test_user.appmap.json', the id is 'minitest/Test_user'.;
    id, metadata, changed, sourceDiff) {
        this.id = id;
        this.metadata = metadata;
        this.changed = changed;
        this.sourceDiff = sourceDiff;
    }
    // Gets the recorder-assigned name for the AppMap. This should be the metadata.name field, which is
    // normally constructed from the name of the test function and its context functions/blocks. If
    // that is missing for some reason, we'll use metadata.source_location.
    get name() {
        return this.metadata.name || this.sourceLocation || '<anonymous AppMap>';
    }
    get isTest() {
        return this.metadata.recorder.type === 'tests' || this.metadata.test_status !== undefined;
    }
    get recorderName() {
        return this.metadata.recorder.name;
    }
    get displayName() {
        return this.name.replaceAll(/(\w)_(\w)/g, '$1 $2').replaceAll(/\s+/g, ' ');
    }
    get sourceLocation() {
        return this.metadata.source_location;
    }
    get failureMessage() {
        var _a;
        return (_a = this.metadata.test_failure) === null || _a === void 0 ? void 0 : _a.message;
    }
    get failureLocation() {
        var _a;
        return (_a = this.metadata.test_failure) === null || _a === void 0 ? void 0 : _a.location;
    }
}
exports.AppMap = AppMap;
class TestFailure {
    constructor(appmap, testSnippet) {
        this.appmap = appmap;
        this.testLocation = appmap.sourceLocation;
        this.failureMessage = appmap.failureMessage;
        this.failureLocation = appmap.failureLocation;
        const { failureLocation } = this.appmap;
        if (this.appmap.failureLocation) {
            if (testSnippet) {
                const [, lineno] = (failureLocation || '').split(':');
                // Insert the line marker '>' into the code fragment.
                const codeFragment = testSnippet.codeFragment
                    .split('\n')
                    .map((line, index) => `${(index + testSnippet.startLine).toString() === lineno ? '> ' : '  '} ${index + testSnippet.startLine}: ${line}`)
                    .join('\n');
                this.testSnippet = {
                    codeFragment,
                    language: testSnippet.language,
                    startLine: testSnippet.startLine,
                };
            }
        }
    }
}
exports.TestFailure = TestFailure;
class OpenAPIDiff {
    constructor(differenceCount, apiDiff, sourceDiff) {
        var _a, _b, _c, _d, _e;
        this.differenceCount = differenceCount;
        this.sourceDiff = sourceDiff;
        this.breakingDifferenceCount = apiDiff.breakingDifferencesFound
            ? (_a = apiDiff.breakingDifferences) === null || _a === void 0 ? void 0 : _a.length
            : 0;
        this.nonBreakingDifferenceCount = ((_b = apiDiff.nonBreakingDifferences) === null || _b === void 0 ? void 0 : _b.length) || 0;
        const wordify = (s) => s.replace(/([-_])/g, ' ').toLowerCase();
        const capitalize = (s) => s.charAt(0).toUpperCase() + s.slice(1);
        const explainAPIChange = (change) => {
            var _a;
            const { action, entity, sourceSpecEntityDetails, destinationSpecEntityDetails } = change;
            const entityTokens = entity.split('.');
            const title = [capitalize(wordify(action)), ...entityTokens.map(wordify)].join(' ');
            let location = (_a = [...sourceSpecEntityDetails, ...destinationSpecEntityDetails].find((spec) => spec.location)) === null || _a === void 0 ? void 0 : _a.location;
            if (location)
                location = (0, formatAPILocation_1.default)(location);
            return {
                title,
                location: location || 'an undefined URL location',
                sourceSpecEntityDetails: change.sourceSpecEntityDetails,
                destinationSpecEntityDetails: change.destinationSpecEntityDetails,
            };
        };
        this.breakingDifferences = apiDiff.breakingDifferencesFound
            ? (_c = apiDiff.breakingDifferences) === null || _c === void 0 ? void 0 : _c.map(explainAPIChange)
            : [];
        this.nonBreakingDifferences = (_d = apiDiff.nonBreakingDifferences) === null || _d === void 0 ? void 0 : _d.map(explainAPIChange);
        this.unclassifiedDifferences = (_e = apiDiff.unclassifiedDifferences) === null || _e === void 0 ? void 0 : _e.map(explainAPIChange);
    }
}
exports.OpenAPIDiff = OpenAPIDiff;
class FindingDiff {
    constructor(newFindings, resolvedFindings) {
        this.newFindings = newFindings;
        this.resolvedFindings = resolvedFindings;
    }
}
exports.FindingDiff = FindingDiff;
class ChangeReport {
    constructor(testFailures, newAppMaps, removedAppMaps, changedAppMaps, openapiDiff, sqlDiff, findingDiff, warnings = [], pruned = false) {
        this.testFailures = testFailures;
        this.newAppMaps = newAppMaps;
        this.removedAppMaps = removedAppMaps;
        this.changedAppMaps = changedAppMaps;
        this.openapiDiff = openapiDiff;
        this.sqlDiff = sqlDiff;
        this.findingDiff = findingDiff;
        this.warnings = warnings;
        this.pruned = pruned;
    }
    static async build(changeReportData) {
        var _a, _b, _c;
        const metadata = (revision, appmap) => {
            const appmapId = (0, normalizeAppMapId_1.default)(appmap);
            const metadata = changeReportData.appMapMetadata[revision][appmapId];
            (0, assert_1.default)(metadata, `Missing metadata for ${revision} ${appmapId}`);
            return metadata;
        };
        const changedAppMapSet = changeReportData.changedAppMaps.reduce((memo, change) => (memo.add((0, normalizeAppMapId_1.default)(change.appmap)), memo), new Set());
        const sourceDiffs = changeReportData.changedAppMaps.reduce((memo, change) => {
            if (change.sourceDiff)
                memo.set((0, normalizeAppMapId_1.default)(change.appmap), change.sourceDiff);
            return memo;
        }, new Map());
        const appmap = (revision, appmapId) => {
            appmapId = (0, normalizeAppMapId_1.default)(appmapId);
            const sourceDiff = sourceDiffs.get(appmapId);
            return new AppMap(appmapId, metadata(revision, appmapId), changedAppMapSet.has(appmapId), sourceDiff);
        };
        // Resolve changedAppMap entry for a test failure. Note that this will not help much
        // with new test cases that fail, but it will help with modified tests that fail.
        const testFailures = changeReportData.testFailures.map((failure) => {
            return new TestFailure(appmap(RevisionName_1.RevisionName.Head, failure.appmap), failure.testSnippet);
        });
        // Remove the empty sequence diagram diff snippet - which can't be reasonably rendered.
        delete changeReportData.sequenceDiagramDiff[''];
        let apiDiff;
        if (changeReportData.apiDiff) {
            const differenceCount = (changeReportData.apiDiff.breakingDifferencesFound
                ? (_a = changeReportData.apiDiff.breakingDifferences) === null || _a === void 0 ? void 0 : _a.length
                : 0) +
                (((_b = changeReportData.apiDiff.nonBreakingDifferences) === null || _b === void 0 ? void 0 : _b.length) || 0) +
                (((_c = changeReportData.apiDiff.unclassifiedDifferences) === null || _c === void 0 ? void 0 : _c.length) || 0);
            let sourceDiff;
            if (differenceCount > 0) {
                sourceDiff = (await (0, executeCommand_1.executeCommand)(`diff -u base/openapi.yml head/openapi.yml`, (0, utils_1.verbose)(), (0, utils_1.verbose)(), (0, utils_1.verbose)(), [0, 1])).trim();
            }
            apiDiff = new OpenAPIDiff(differenceCount, changeReportData.apiDiff, sourceDiff);
        }
        let findingDiff;
        if (changeReportData.findingDiff) {
            const buildFindings = (key, revisionName) => {
                (0, assert_1.default)(changeReportData.findingDiff);
                return changeReportData.findingDiff[key].map((finding) => {
                    // This is a special case where the appmapId in the finding has the .appmap.json
                    // extension, which is non-standard from how we do it elsewhere.
                    let appmapId = finding.appMapFile;
                    if (appmapId.endsWith('.appmap.json'))
                        appmapId = appmapId.slice(0, appmapId.length - '.appmap.json'.length);
                    return {
                        appmap: appmap(revisionName, (0, normalizeAppMapId_1.default)(appmapId)),
                        finding,
                    };
                });
            };
            const newFindings = buildFindings('new', RevisionName_1.RevisionName.Head);
            const resolvedFindings = buildFindings('resolved', RevisionName_1.RevisionName.Base);
            findingDiff = new FindingDiff(newFindings, resolvedFindings);
        }
        let sqlDiff;
        if (changeReportData.sqlDiff) {
            const newQueries = changeReportData.sqlDiff.newQueries.map((newQuery) => {
                const appmaps = newQuery.appmaps.map((appmapId) => appmap(RevisionName_1.RevisionName.Head, (0, normalizeAppMapId_1.default)(appmapId)));
                return {
                    query: sqlFormat(newQuery.query),
                    appmaps,
                    sourceLocations: newQuery.sourceLocations,
                };
            });
            sqlDiff = {
                newQueries,
                removedQueries: changeReportData.sqlDiff.removedQueries.map(sqlFormat),
                newTables: changeReportData.sqlDiff.newTables.map(sqlFormat),
                removedTables: changeReportData.sqlDiff.removedTables.map(sqlFormat),
            };
        }
        const newAppMaps = changeReportData.newAppMaps.map((appmapId) => appmap(RevisionName_1.RevisionName.Head, (0, normalizeAppMapId_1.default)(appmapId)));
        const removedAppMaps = changeReportData.removedAppMaps.map((appmapId) => appmap(RevisionName_1.RevisionName.Base, (0, normalizeAppMapId_1.default)(appmapId)));
        const changedAppMaps = Object.keys(changeReportData.sequenceDiagramDiff).reduce((memo, key) => {
            const appmaps = changeReportData.sequenceDiagramDiff[key].map((appmapId) => appmap(RevisionName_1.RevisionName.Head, (0, normalizeAppMapId_1.default)(appmapId)));
            memo[key] = appmaps;
            return memo;
        }, {});
        const warnings = changeReportData.warnings
            ? Object.keys(changeReportData.warnings).reduce((memo, field) => {
                (0, assert_1.default)(changeReportData.warnings);
                const warnings = changeReportData.warnings[field] || [];
                for (const message of warnings) {
                    memo.push({ field, message });
                }
                return memo;
            }, new Array())
            : [];
        return new ChangeReport(testFailures, newAppMaps, removedAppMaps, changedAppMaps, apiDiff, sqlDiff, findingDiff, warnings);
    }
}
exports.default = ChangeReport;
//# sourceMappingURL=ChangeReport.js.map