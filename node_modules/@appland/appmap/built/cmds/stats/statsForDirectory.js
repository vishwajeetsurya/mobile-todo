"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.statsForDirectory = exports.sizeInMB = void 0;
const fs = __importStar(require("fs"));
const userInteraction_1 = __importDefault(require("../userInteraction"));
const telemetry_1 = __importDefault(require("../../telemetry"));
const utils_1 = require("../../utils");
const models_1 = require("@appland/models");
const chalk_1 = __importDefault(require("chalk"));
const path_1 = require("path");
const MINIMUM_APPMAP_SIZE = (1024 * 1024) / 1;
function sizeInMB(size) {
    return Number((size / 1000 / 1000).toFixed(1));
}
exports.sizeInMB = sizeInMB;
async function statsForDirectory(appMapDir, format, limit, handlerCaller = 'from_stats') {
    async function calculateAppMapSizes(appMapDir) {
        const appMapSizes = {};
        // This function is too verbose to be useful in this context.
        const v = (0, utils_1.verbose)();
        (0, utils_1.verbose)(false);
        await (0, utils_1.findFiles)(appMapDir, '.appmap.json', (fileName) => {
            const stats = fs.statSync(fileName);
            appMapSizes[fileName] = {
                path: (0, path_1.relative)(appMapDir, fileName),
                size: stats.size,
            };
        });
        (0, utils_1.verbose)(v);
        return appMapSizes;
    }
    async function sortAppMapSizes(appMapSizes) {
        let appMapSizesArray = [];
        for (const key in appMapSizes) {
            appMapSizesArray.push({
                path: appMapSizes[key].path,
                size: appMapSizes[key].size,
            });
        }
        return appMapSizesArray.sort((a, b) => b.size - a.size);
    }
    async function calculateExecutionTimes(appMapDir) {
        // now that all functions were collected, index them by function
        // name, not by <thread_id,parent_id>
        let totalFunctionExecutionTimes = {};
        // This function is too verbose to be useful in this context.
        const v = (0, utils_1.verbose)();
        (0, utils_1.verbose)(false);
        // Note that event#elapsed time does NOT include instrumentation overhead.
        // So, instrumentation / elapsed can theoretically be greater than 1.
        let totalTime = 0;
        await (0, utils_1.findFiles)(appMapDir, '.appmap.json', (fileName) => {
            const file = fs.readFileSync(fileName, 'utf-8');
            const appmapData = JSON.parse(file.toString());
            const appmap = (0, models_1.buildAppMap)(appmapData).build();
            appmap.events.forEach((event) => {
                if (event.isCall()) {
                    const eventReturn = event.returnEvent;
                    if (!eventReturn)
                        return;
                    const name = event.codeObject.fqid;
                    let elapsedInstrumentationTime = eventReturn.elapsedInstrumentationTime || 0;
                    let path = '';
                    // some paths are library functions but don't start with /. i.e.:
                    // <internal:pack>
                    // OpenSSL::Cipher#decrypt
                    // Kernel#eval
                    if (event.definedClass &&
                        event.path &&
                        (event.path.startsWith('/') ||
                            event.path.startsWith('<') ||
                            event.path.includes('::') ||
                            event.path.startsWith('Kernel'))) {
                        // Absolute path names generally signify a library function.
                        // Send library function data to help optimize AppMap;
                        // don't send user function data.
                        path = event.path;
                    }
                    // Total up the elapsed time of root events.
                    if (!event.parent && eventReturn.elapsedTime) {
                        totalTime += eventReturn.elapsedTime;
                    }
                    const existingRecord = totalFunctionExecutionTimes[name];
                    if (!existingRecord) {
                        totalFunctionExecutionTimes[name] = {
                            path,
                            numberOfCalls: 1,
                            elapsedInstrumentationTime,
                        };
                    }
                    else {
                        existingRecord.numberOfCalls += 1;
                        existingRecord.elapsedInstrumentationTime += elapsedInstrumentationTime;
                        if (existingRecord.path === '')
                            existingRecord.path = path;
                    }
                }
            });
        });
        (0, utils_1.verbose)(v);
        // convert hash to array
        let flatFunctionExecutionTimes = [];
        for (const name in totalFunctionExecutionTimes) {
            flatFunctionExecutionTimes.push({
                name: name,
                elapsedInstrumentationTime: totalFunctionExecutionTimes[name].elapsedInstrumentationTime,
                numberOfCalls: totalFunctionExecutionTimes[name].numberOfCalls,
                path: totalFunctionExecutionTimes[name].path,
            });
        }
        return { totalTime, functions: flatFunctionExecutionTimes };
    }
    async function sortExecutionTimes(functionExecutionTimes) {
        // sort the array
        return functionExecutionTimes.sort((a, b) => b.elapsedInstrumentationTime - a.elapsedInstrumentationTime);
    }
    async function showStats() {
        let biggestAppMapSizes = [];
        // column names in JSON files use snakecase
        let slowestExecutionTimes = [];
        try {
            userInteraction_1.default.status = `Computing AppMap stats...`;
            const appMapSizes = await calculateAppMapSizes(appMapDir);
            const sortedAppMapSizes = await sortAppMapSizes(appMapSizes);
            userInteraction_1.default.success();
            userInteraction_1.default.progress('');
            userInteraction_1.default.progress(chalk_1.default.underline(`Largest AppMaps (which are bigger than ${MINIMUM_APPMAP_SIZE / 1024}kb)`));
            sortedAppMapSizes
                .filter((appmap) => appmap.size > MINIMUM_APPMAP_SIZE)
                .slice(0, limit)
                .forEach((appmap) => {
                biggestAppMapSizes.push({
                    size: appmap.size,
                    path: appmap.path,
                });
            });
            if (format === 'json') {
                console.log(JSON.stringify(biggestAppMapSizes));
            }
            else {
                biggestAppMapSizes.forEach((appmap) => {
                    console.log(sizeInMB(appmap.size) + 'MB ' + appmap.path);
                });
            }
            userInteraction_1.default.progress('');
            userInteraction_1.default.status = `Computing functions with highest AppMap overhead...`;
            const executionTimes = await calculateExecutionTimes(appMapDir);
            const sortedExecutionTimes = await sortExecutionTimes(executionTimes.functions);
            let totalInstrumentationTime = 0;
            sortedExecutionTimes.forEach((time) => (totalInstrumentationTime += time.elapsedInstrumentationTime));
            userInteraction_1.default.success();
            userInteraction_1.default.progress('');
            // if there are no instrumentation data don't show this report
            if (sortedExecutionTimes.length > 0 &&
                sortedExecutionTimes[0].elapsedInstrumentationTime === 0) {
                console.log("These AppMaps don't contain function overhead data. Please update your appmap package to the latest version.");
            }
            else {
                sortedExecutionTimes.slice(0, limit).forEach((executionTime) => {
                    slowestExecutionTimes.push({
                        elapsed_instrumentation_time_total: Number(executionTime.elapsedInstrumentationTime.toFixed(6)),
                        num_calls: executionTime.numberOfCalls,
                        name: executionTime.name,
                        path: executionTime.path,
                    });
                });
                if (format === 'json') {
                    console.log(JSON.stringify(slowestExecutionTimes));
                }
                else {
                    userInteraction_1.default.progress(chalk_1.default.underline(`Total instrumentation time`));
                    console.log(`${Math.round(totalInstrumentationTime * 1000)}ms`);
                    userInteraction_1.default.progress('');
                    userInteraction_1.default.progress(chalk_1.default.underline(`Functions with highest AppMap overhead`));
                    console.log(chalk_1.default.underline([
                        'Time'.padStart(9),
                        '%'.padStart(5),
                        'Count'.padStart(7),
                        'Function name'.padEnd(30),
                    ].join(' | ')));
                    slowestExecutionTimes.forEach((executionTime) => {
                        const displayMs = [
                            Math.round(executionTime.elapsed_instrumentation_time_total * 1000).toString(),
                            'ms',
                        ].join('');
                        const displayPercent = `${(Math.round((executionTime.elapsed_instrumentation_time_total / totalInstrumentationTime) * 1000) / 10).toLocaleString('en-us', { maximumFractionDigits: 2, minimumFractionDigits: 0 })}%`;
                        console.log([
                            displayMs.padStart(9),
                            displayPercent.padStart(5),
                            executionTime.num_calls.toString().padStart(7),
                            executionTime.name.split(':').slice(1).join(':'),
                        ].join(' | '));
                    });
                }
            }
            let telemetryMetrics = {};
            let telemetryMetricsCounter = 1;
            biggestAppMapSizes.forEach((appmap) => {
                telemetryMetrics[`biggestAppmaps_${telemetryMetricsCounter}`] = appmap.size;
                telemetryMetricsCounter += 1;
            });
            telemetryMetricsCounter = 1;
            slowestExecutionTimes.forEach((executionTime) => {
                telemetryMetrics[`slowestInstrumentationTimesTotal_${telemetryMetricsCounter}`] =
                    executionTime.elapsed_instrumentation_time_total;
                telemetryMetrics[`slowestInstrumentationTimesPath_${telemetryMetricsCounter}`] =
                    executionTime.path;
                telemetryMetricsCounter += 1;
            });
        }
        catch (err) {
            let errorMessage = err.toString();
            if (err instanceof Error) {
                telemetry_1.default.sendEvent({
                    name: `stats:${handlerCaller}:error`,
                    properties: {
                        errorMessage,
                        errorStack: err.stack,
                    },
                });
            }
        }
        return [biggestAppMapSizes, slowestExecutionTimes];
    }
    return await showStats();
}
exports.statsForDirectory = statsForDirectory;
//# sourceMappingURL=statsForDirectory.js.map