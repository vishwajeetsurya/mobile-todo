"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = exports.builder = exports.describe = exports.command = void 0;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const chalk_1 = __importDefault(require("chalk"));
const statsForDirectory_1 = require("./statsForDirectory");
const statsForMap_1 = require("./statsForMap");
const locateAppMapDir_1 = require("../../lib/locateAppMapDir");
const utils_1 = require("../../utils");
const handleWorkingDirectory_1 = require("../../lib/handleWorkingDirectory");
exports.command = 'stats [directory]';
exports.describe = 'Show statistics about events from an AppMap or from all AppMaps in a directory';
const LIMIT_DEFAULT = 10;
async function locateAppMapFile(userInput, appmapDir) {
    let extension = '.appmap.json';
    if (userInput.endsWith('.appmap.json')) {
        extension = '';
    }
    else if (userInput.endsWith('.appmap')) {
        extension = '.json';
    }
    const mapFile = userInput + extension;
    // if --appmap-file is a valid exact path, then return it
    // or resolve cwd and --appmap-file and check for an exact match
    const absoluteUserInput = path_1.default.resolve(process.cwd(), mapFile);
    if ((0, fs_1.existsSync)(absoluteUserInput))
        return absoluteUserInput;
    // resolve --appmap-dir against CWD. If it's an absolute path, it'll remain unchanged.
    // If it's relative, it'll be resolved against CWD.
    const absoluteAppmapDir = path_1.default.resolve(process.cwd(), appmapDir);
    const searchPath = path_1.default.join(absoluteAppmapDir, mapFile);
    if ((0, fs_1.existsSync)(searchPath))
        return searchPath;
    console.error(chalk_1.default.red('No matching AppMap found'));
    return;
}
const builder = (args) => {
    args.option('directory', {
        describe: 'program working directory',
        type: 'string',
        alias: 'd',
    });
    args.option('appmap-dir', {
        describe: 'directory to recursively inspect for AppMaps',
    });
    args.option('format', {
        describe: 'How to format the output',
        choices: ['json', 'text'],
        alias: 'f',
        default: 'text',
    });
    args.option('limit', {
        describe: 'Number of methods to display',
        type: 'number',
        alias: 'l',
        default: LIMIT_DEFAULT,
    });
    args.option('appmap-file', {
        describe: 'AppMap to analyze',
        type: 'string',
        alias: 'a',
    });
    return args.strict();
};
exports.builder = builder;
async function handler(argv, handlerCaller = 'from_stats') {
    (0, utils_1.verbose)(argv.verbose);
    (0, handleWorkingDirectory_1.handleWorkingDirectory)(argv.directory);
    let appmapDir;
    try {
        appmapDir = await (0, locateAppMapDir_1.locateAppMapDir)(argv.appmapDir);
    }
    catch (e) {
        appmapDir = process.cwd();
    }
    const { format, limit, appmapFile } = argv;
    if (appmapFile) {
        const fileToAnalyze = await locateAppMapFile(appmapFile, appmapDir);
        if (!fileToAnalyze)
            return;
        console.warn(chalk_1.default.yellow(`Analyzing AppMap: ${fileToAnalyze}\n`));
        return await (0, statsForMap_1.statsForMap)(format, limit, fileToAnalyze);
    }
    return await (0, statsForDirectory_1.statsForDirectory)(appmapDir, format, limit, handlerCaller);
}
exports.handler = handler;
exports.default = {
    command: exports.command,
    describe: exports.describe,
    builder: exports.builder,
    handler: handler,
};
//# sourceMappingURL=stats.js.map