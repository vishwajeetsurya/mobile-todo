"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = exports.builder = exports.describe = exports.command = void 0;
const yargs_1 = __importDefault(require("yargs"));
const path_1 = require("path");
const promises_1 = require("fs/promises");
const fs_1 = require("fs");
const handleWorkingDirectory_1 = require("../../lib/handleWorkingDirectory");
const utils_1 = require("../../utils");
const console_1 = require("console");
const assert_1 = __importDefault(require("assert"));
const locateAppMapDir_1 = require("../../lib/locateAppMapDir");
const buildReport_1 = require("./buildReport");
exports.command = 'inventory [output-file]';
exports.describe = 'Generate a JSON report describing the contents of a repository.';
const builder = (args) => {
    args.positional('output-file', {
        type: 'string',
        describe: `output file to write the JSON report. If this option is not provided, the report is written to stdout`,
        demandOption: false,
    });
    args.option('directory', {
        describe: 'program working directory',
        type: 'string',
        alias: 'd',
    });
    args.option('appmap-dir', {
        describe: 'directory to recursively inspect for AppMaps',
    });
    args.option('resource-tokens', {
        describe: `number of path tokens to include in the 'by resource' output`,
        type: 'number',
        default: 2,
    });
    args.option('resource-tokens', {
        describe: `number of path tokens to include in the 'by resource' output`,
        type: 'number',
        default: 2,
    });
    args.option('large-appmaps', {
        describe: `number of largest AppMaps to report`,
        type: 'number',
        default: 20,
    });
    args.option('frequent-functions', {
        describe: `number of most frequently occurring functions to report (this is an estimate based on inspecting the large AppMaps)`,
        type: 'number',
        default: 50,
    });
    return args.strict();
};
exports.builder = builder;
const handler = async (argv) => {
    (0, utils_1.verbose)(argv.verbose);
    const { outputFile, directory, resourceTokens, frequentFunctions: frequentFunctionLimit, largeAppmaps: largeAppMapLimit, } = argv;
    (0, assert_1.default)(resourceTokens);
    (0, assert_1.default)(typeof resourceTokens === 'number');
    (0, assert_1.default)(resourceTokens > 0);
    (0, handleWorkingDirectory_1.handleWorkingDirectory)(directory);
    if (!outputFile) {
        (0, console_1.warn)(`No output file specified. Report JSON will be written to stdout.`);
    }
    const appmapDir = await (0, locateAppMapDir_1.locateAppMapDir)(argv.appmapDir);
    if (!(0, fs_1.existsSync)((0, path_1.join)(appmapDir, 'appmap_archive.json'))) {
        (0, console_1.warn)(`No appmap_archive.json found in ${appmapDir}`);
        (0, console_1.warn)(`Run 'appmap archive' to index and analyze the AppMaps, then run this command again`);
        yargs_1.default.exit(1, new Error('No appmap_archive.json found'));
    }
    const appmaps = await (0, utils_1.findFiles)(appmapDir, '.appmap.json');
    if (appmaps.length === 0) {
        (0, console_1.warn)(`No AppMaps found in ${appmapDir}`);
        return;
    }
    (0, console_1.warn)(`Building inventory data from ${appmaps.length} AppMaps in ${appmapDir}`);
    const report = await (0, buildReport_1.buildReport)(appmapDir, appmaps, {
        resourceTokens: resourceTokens + 1 /* The url '/' is actually 2 tokens, so add 1 to the user input */,
        frequentFunctionLimit,
        largeAppMapLimit,
    });
    const reportJSONStr = JSON.stringify(report, null, 2);
    if (outputFile) {
        await (0, promises_1.writeFile)(outputFile, reportJSONStr);
    }
    else {
        console.log(reportJSONStr);
    }
};
exports.handler = handler;
//# sourceMappingURL=inventory.js.map