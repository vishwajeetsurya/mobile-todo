"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildReport = void 0;
const DependencyMap_1 = __importDefault(require("./DependencyMap"));
const collectMetadata_1 = __importDefault(require("./analyzers/collectMetadata"));
const collectHTTPServerRequests_1 = __importDefault(require("./analyzers/collectHTTPServerRequests"));
const collectSQLQueries_1 = __importDefault(require("./analyzers/collectSQLQueries"));
const collectHTTPClientRequests_1 = __importDefault(require("./analyzers/collectHTTPClientRequests"));
const collectPackageDependencies_1 = require("./analyzers/collectPackageDependencies");
const collectSQLTables_1 = require("./analyzers/collectSQLTables");
const collectLabels_1 = require("./analyzers/collectLabels");
const collectRoutes_1 = __importDefault(require("./analyzers/collectRoutes"));
const collectAppMapSize_1 = __importDefault(require("./analyzers/collectAppMapSize"));
const collectFunctionOccurances_1 = __importDefault(require("./analyzers/collectFunctionOccurances"));
const path_1 = require("path");
const console_1 = require("console");
const readIndexFile_1 = __importDefault(require("./readIndexFile"));
const collectFindings_1 = __importDefault(require("./analyzers/collectFindings"));
async function buildReport(appmapDir, appmaps, options) {
    const appmapCountByRecorderName = {};
    const appmapCountByHTTPServerRequestCount = {};
    const appmapCountBySQLQueryCount = {};
    const clientRouteCountByResource = {};
    const uniquePackageDependencies = new DependencyMap_1.default();
    const sqlTables = new Set();
    const labels = new Set();
    const routeCountByResource = {};
    const routeCountByContentType = {};
    const findings = [];
    const appmapSize = {};
    const analyzers = [
        (0, collectMetadata_1.default)(appmapCountByRecorderName),
        (0, collectHTTPServerRequests_1.default)(appmapCountByHTTPServerRequestCount),
        (0, collectSQLQueries_1.default)(appmapCountBySQLQueryCount),
        (0, collectHTTPClientRequests_1.default)(clientRouteCountByResource, options.resourceTokens),
        (0, collectPackageDependencies_1.collectPackageDependencies)(uniquePackageDependencies),
        (0, collectSQLTables_1.collectSQLTables)(sqlTables),
        (0, collectLabels_1.collectLabels)(labels),
        (0, collectFindings_1.default)(findings),
        (0, collectAppMapSize_1.default)(appmapSize),
    ];
    for (const appmap of appmaps) {
        const metadata = await (0, readIndexFile_1.default)(appmap, 'metadata.json');
        // If the metadata file is missing, skip this appmap. It's probably been skipped
        // by the indexer because it's too large.
        if (!metadata)
            continue;
        for (const analyzer of analyzers) {
            try {
                await analyzer(appmap);
            }
            catch (e) {
                (0, console_1.warn)(`Error analyzing ${appmap}: ${e}`);
            }
        }
    }
    const uniqueFindings = [];
    {
        findings.sort((a, b) => b.modifiedDate.getTime() - a.modifiedDate.getTime());
        const findingHashes = new Set();
        for (const finding of findings) {
            if (!findingHashes.has(finding.hash_v2)) {
                uniqueFindings.push(finding);
                findingHashes.add(finding.hash_v2);
            }
        }
    }
    const largeAppMaps = {};
    {
        const appmaps = Object.keys(appmapSize);
        appmaps.sort((a, b) => appmapSize[b] - appmapSize[a]);
        appmaps.slice(0, options.largeAppMapLimit).reduce((acc, appmap) => {
            acc[appmap] = appmapSize[appmap];
            return acc;
        }, largeAppMaps);
    }
    const frequentFunctions = {};
    {
        const functionOccurrances = {};
        {
            const analyzer = (0, collectFunctionOccurances_1.default)(functionOccurrances);
            for (const appmap of Object.keys(largeAppMaps)) {
                await analyzer(appmap);
            }
        }
        const functions = Object.keys(functionOccurrances);
        functions.sort((a, b) => functionOccurrances[b].count - functionOccurrances[a].count);
        functions.slice(0, options.frequentFunctionLimit).reduce((acc, fn) => {
            acc[fn] = functionOccurrances[fn];
            return acc;
        }, frequentFunctions);
    }
    const openapiFile = (0, path_1.join)(appmapDir, 'openapi.yml');
    await (0, collectRoutes_1.default)(openapiFile, options.resourceTokens, routeCountByResource, routeCountByContentType);
    return {
        appmapCountByRecorderName,
        appmapCountByHTTPServerRequestCount,
        appmapCountBySQLQueryCount,
        routeCountByResource,
        routeCountByContentType,
        clientRouteCountByResource,
        labels: [...labels].sort(),
        sqlTables: [...sqlTables].sort(),
        packages: [
            ...new Set(uniquePackageDependencies.dependencies.map((d) => [d.caller, d.callee]).flat()),
        ].sort(),
        packageDependencies: uniquePackageDependencies.dependencies,
        findings: uniqueFindings,
        largeAppMaps,
        frequentFunctions,
    };
}
exports.buildReport = buildReport;
//# sourceMappingURL=buildReport.js.map