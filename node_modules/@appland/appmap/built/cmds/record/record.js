"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../../utils");
const runCommand_1 = __importDefault(require("../runCommand"));
const showAppMap_1 = __importDefault(require("../open/showAppMap"));
const process_1 = require("process");
const initial_1 = __importStar(require("./state/initial"));
const recordContext_1 = __importDefault(require("./recordContext"));
const configuration_1 = __importDefault(require("./configuration"));
const StatsCommand = require('../stats/stats');
const openTicket_1 = __importDefault(require("../../lib/ticket/openTicket"));
const userInteraction_1 = __importDefault(require("../userInteraction"));
const makeRequest_1 = require("./makeRequest");
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = require("fs");
exports.default = {
    command: 'record [mode]',
    describe: 'Create an AppMap via interactive recording, aka remote recording.',
    builder: (args) => {
        args.positional('mode', {
            type: 'string',
            choices: ['test', 'remote'],
        });
        args.option('directory', {
            describe: 'Working directory for the command.',
            type: 'string',
            alias: 'd',
        });
        args.option('appmap-config', {
            describe: 'AppMap config file to check for default options.',
            type: 'string',
            alias: 'c',
        });
        return args.strict();
    },
    handler: async (argv) => {
        (0, utils_1.verbose)(argv.verbose);
        const commandFn = async () => {
            const { directory, appmapConfig } = argv;
            if (directory) {
                if ((0, utils_1.verbose)())
                    console.log(`Using working directory ${directory}`);
                if ((0, fs_1.existsSync)(directory)) {
                    // statSync follows symlinks
                    if (!(0, fs_1.statSync)(directory).isDirectory()) {
                        userInteraction_1.default.error(`${directory} is not a directory.`);
                        return null;
                    }
                }
                else {
                    userInteraction_1.default.error(`Directory ${directory} does not exist.`);
                    return null;
                }
                (0, process_1.chdir)(directory);
            }
            const configuration = new configuration_1.default(appmapConfig);
            const recordContext = new recordContext_1.default(configuration);
            await recordContext.initialize();
            const { mode } = argv;
            async function initialState() {
                if (mode) {
                    recordContext.recordMethod = mode;
                    return (0, initial_1.createState)(mode);
                }
                else {
                    return initial_1.default;
                }
            }
            let state = await initialState();
            while (state && typeof state === 'function') {
                if ((0, utils_1.verbose)())
                    console.warn(`Entering state: ${state.name}`);
                let errorMessage;
                let newState;
                try {
                    newState = await state(recordContext);
                }
                catch (err) {
                    errorMessage = err.toString();
                    // TODO: consider making this more general, to open a ticket when any Error occurs.
                    if (err instanceof makeRequest_1.RemoteRecordingError) {
                        // If a request to the remote-recording endpoint fails, an AppMap won't be created, i.e.
                        // the final AppMap count will match the initial count.
                        recordContext.appMapCount = recordContext.initialAppMapCount;
                        await handleRemoteError(err);
                        break;
                    }
                    throw err;
                }
                finally {
                    const properties = recordContext.properties();
                    if (errorMessage) {
                        properties.errorMessage = errorMessage;
                    }
                }
                state = newState;
            }
            if (typeof state === 'string') {
                await (0, showAppMap_1.default)(state);
            }
            await StatsCommand.handler(argv, 'from_record');
        };
        return (0, runCommand_1.default)('record', commandFn);
    },
};
async function handleRemoteError(err) {
    userInteraction_1.default.error(`Something went wrong when ${err.description}:
HTTP status: ${err.statusCode}
HTTP request: ${err.method} ${err.path}
`);
    const message = `Would you like to see the server's response?`;
    const result = await userInteraction_1.default.prompt({
        name: 'showResponse',
        type: 'confirm',
        message,
        prefix: chalk_1.default.red('!'),
    }, { supressSpinner: true });
    const { showResponse } = result;
    if (showResponse) {
        userInteraction_1.default.error(err.message);
    }
    await (0, openTicket_1.default)(err.toString());
}
//# sourceMappingURL=record.js.map