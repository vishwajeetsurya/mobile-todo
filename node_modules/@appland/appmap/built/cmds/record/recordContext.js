"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RecordProcessResult = void 0;
const assert_1 = __importDefault(require("assert"));
const countAppMaps_1 = __importDefault(require("./action/countAppMaps"));
const configuration_1 = require("./configuration");
class RecordProcessResult {
    constructor(_env, command, exitCode, output) {
        this._env = _env;
        this.command = command;
        this.exitCode = exitCode;
        this.output = output;
    }
    get env() {
        return Object.fromEntries(Object.entries(this._env).filter(([k, _]) => {
            return k.startsWith('APPMAP') && !k.includes('KEY');
        }));
    }
}
exports.RecordProcessResult = RecordProcessResult;
class RecordContext {
    constructor(configuration) {
        this.configuration = configuration;
    }
    async initialize() {
        await this.configuration.read();
        this.appMapDir = this.configuration.configOption('appmap_dir', '.');
        this.initialAppMapCount = await (0, countAppMaps_1.default)(this.appMapDir);
    }
    properties() {
        const result = {};
        if (this.recordMethod)
            result.recordMethod = this.recordMethod;
        if (this.url)
            result.url = this.url;
        if (this.testCommands)
            result.testCommands = this.testCommands.join('; ');
        if (this.results) {
            result.exitCodes = this.exitCodes.map(String).join(', ');
            result.log = this.results
                .map((r) => [r.command, JSON.stringify(r.env), r.output].join('\n===\n'))
                .join('\n=====\n');
        }
        return result;
    }
    metrics() {
        const result = {};
        if (this.maxTime)
            result.maxTime = this.maxTime;
        if (this.initialAppMapCount !== undefined) {
            result.initialAppMapCount = this.initialAppMapCount;
        }
        if (this.appMapCount !== undefined) {
            result.appMapCount = this.appMapCount;
        }
        if (this.appMapEventCount !== undefined) {
            result.appMapEventCount = this.appMapEventCount;
        }
        return result;
    }
    populateURL() {
        this.url = this.configuration.locationString();
    }
    populateTestCommands() {
        this.testCommands = this.configuration.configOption('test_recording.test_commands', []).map(configuration_1.TestCommand.toString);
    }
    async populateMaxTime() {
        this.maxTime = this.configuration.setting('test_recording.max_time', 30);
    }
    async populateAppMapCount() {
        (0, assert_1.default)(this.appMapDir);
        const appMapCount = await (0, countAppMaps_1.default)(this.appMapDir);
        this.appMapCount = appMapCount;
    }
    // Return the number of AppMaps created during this recording
    get appMapsCreated() {
        if (this.initialAppMapCount === undefined || this.appMapCount === undefined) {
            throw new Error(`Counts uninitialized, initialAppMapCount: ${this.initialAppMapCount} appMapCount: ${this.appMapCount}`);
        }
        return this.appMapCount - this.initialAppMapCount;
    }
    get results() {
        return this._results;
    }
    addResult(result) {
        if (!this._results) {
            this._results = [];
        }
        this._results.push(result);
    }
    // The following are only available once the test commands have finished. Check to see whether
    // this.results is defined before calling any of them.
    get exitCodes() {
        if (!this.results)
            throw new Error('Internal Error, no results yet');
        return this.results.map((r) => r.exitCode);
    }
    // Return the number of failures that occurred during this recording
    get failures() {
        if (!this.results)
            throw new Error('Internal Error, no results yet');
        return this.exitCodes.reduce((acc, c) => acc + (c !== 0 ? 1 : 0), 0);
    }
    get output() {
        if (!this.results)
            throw new Error('Internal Error, no results yet');
        return this.results.map((r) => r.output);
    }
}
exports.default = RecordContext;
//# sourceMappingURL=recordContext.js.map