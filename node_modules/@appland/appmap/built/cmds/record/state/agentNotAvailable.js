"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NextStepChoices = void 0;
const openTicket_1 = __importStar(require("../../../lib/ticket/openTicket"));
const userInteraction_1 = __importDefault(require("../../userInteraction"));
const configureRemainingRequestOptions_1 = __importDefault(require("../action/configureRemainingRequestOptions"));
const detectProcessCharacteristics_1 = __importDefault(require("../action/detectProcessCharacteristics"));
const continueWithRequestOptionConfiguration_1 = __importStar(require("../prompt/continueWithRequestOptionConfiguration"));
const abort_1 = __importDefault(require("./abort"));
const agentProcessNotRunning_1 = __importDefault(require("./agentProcessNotRunning"));
const record_remote_1 = __importDefault(require("./record_remote"));
exports.NextStepChoices = {
    CONFIGURE: { name: 'Configure the path and protocol', value: 'configure' },
    RELAUNCH: { name: 'Re-launch the server', value: 'relaunch' },
    SUPPORT: { name: 'Contact support', value: 'support' },
};
// The agent was not reachable using the configured settings. This may be because:
// * The agent process isn't running.
// * The agent process is running, but the agent isn't reachable (e.g. security filter?).
// * The host/port parameters are wrong.
// * The host/port parameters are right, but the agent URL is different than the default.
async function agentNotAvailable(recordContext) {
    var _a;
    if (!(await (0, detectProcessCharacteristics_1.default)(recordContext))) {
        if ((await (0, continueWithRequestOptionConfiguration_1.default)(recordContext)) ===
            continueWithRequestOptionConfiguration_1.ConfigurationAction.HostAndPort)
            return agentProcessNotRunning_1.default;
    }
    userInteraction_1.default.progress(`
You've confirmed that your application process is running, but I'm unable to connect to the AppMap agent over HTTP. There are three common reasons for this:

1) The agent is enabled and reachable, but it's mounted to a non-root URL path (e.g. /myapp), or the application server is only requesting HTTPS connections.
2) The agent isn't configured to accept connections in this process. For example, the app isn't running with APPMAP=true (Ruby, Python), or the app isn't running with the AppMap agent enabled (Java).
3) The agent is enabled, but HTTP requests to the agent are being blocked by some application or framework code; for example, a security filter.

For case (1), you can configure the application URL path and protocol.

For case (2), you'll need to re-launch the server with the agent enabled.

For case (3), you should contact AppMap support for help with troubleshooting.
`);
    const { option } = await userInteraction_1.default.prompt({
        type: 'list',
        name: 'option',
        message: 'Which would you like to do?',
        choices: Object.values(exports.NextStepChoices),
    });
    switch (option) {
        case exports.NextStepChoices.CONFIGURE.value:
            await (0, configureRemainingRequestOptions_1.default)(recordContext);
            recordContext.populateURL();
            break;
        case exports.NextStepChoices.RELAUNCH.value:
            await userInteraction_1.default.continue('Press enter when the server has been restarted');
            break;
        case exports.NextStepChoices.SUPPORT.value: {
            const details = ((_a = recordContext.remoteError) === null || _a === void 0 ? void 0 : _a.toString()) || '';
            await (0, openTicket_1.default)(details, openTicket_1.DEFAULT_HELP_MSG, false);
            return abort_1.default; // We're done
            break;
        }
    }
    return record_remote_1.default;
}
exports.default = agentNotAvailable;
//# sourceMappingURL=agentNotAvailable.js.map