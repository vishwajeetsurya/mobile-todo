"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const process_1 = require("process");
const utils_1 = require("../../utils");
const userInteraction_1 = __importDefault(require("../userInteraction"));
const recordContext_1 = require("./recordContext");
let TestCommands = [];
let TestCaseProcesses = [];
const DiagnosticCommands = {
    Gemfile: ['ruby -v', 'bundle info rails', 'bundle info actionpack'],
};
class TestCaseRecording {
    static async start({ configuration }) {
        TestCaseProcesses.forEach((process) => {
            if (process.pid)
                (0, process_1.kill)(process.pid);
        });
        TestCommands = [];
        TestCaseProcesses = [];
        let testCommands = configuration.configOption('test_recording.test_commands', []);
        if (testCommands.length === 0)
            throw new Error(`No test commands are configured`);
        if ((0, utils_1.verbose)()) {
            const pathExists = await Promise.all(Object.keys(DiagnosticCommands).map(async (path) => await (0, utils_1.exists)(path)));
            const diagnosticCommands = Object.keys(DiagnosticCommands)
                .filter((_, idx) => pathExists[idx])
                .map((path) => DiagnosticCommands[path])
                .flat();
            await Promise.all(diagnosticCommands.map((cmd) => {
                return new Promise((resolve) => {
                    const args = cmd.split(' ');
                    const process = (0, child_process_1.spawn)(args[0], args.slice(1), {
                        shell: true,
                        stdio: ['ignore', 'inherit', 'inherit'],
                    });
                    process.on('error', resolve);
                    process.on('exit', resolve);
                });
            }));
        }
        TestCommands = testCommands;
    }
    static async waitFor(ctx) {
        let maxTime = ctx.configuration.setting('test_recording.max_time', -1);
        if (maxTime === -1)
            maxTime = undefined;
        if (maxTime)
            userInteraction_1.default.progress(`Running tests for up to ${maxTime} seconds`);
        let waitTime = maxTime;
        async function waitForProcess(childProcess) {
            const commandStr = childProcess.spawnargs.join(' ');
            const startTime = Date.now();
            return new Promise((resolve) => {
                var _a, _b, _c, _d;
                let reported = false;
                let interruptTimeout;
                function interrupt() {
                    if (childProcess.pid) {
                        userInteraction_1.default.progress(`Stopping test command after ${maxTime} seconds: ${commandStr}`);
                        (0, process_1.kill)(childProcess.pid, 'SIGTERM');
                    }
                }
                const output = [];
                function report(exitCode) {
                    if (reported)
                        return;
                    reported = true;
                    const elapsed = Date.now() - startTime;
                    if (waitTime) {
                        waitTime -= elapsed / 1000;
                    }
                    if (interruptTimeout)
                        clearTimeout(interruptTimeout);
                    if (exitCode && exitCode !== 0) {
                        userInteraction_1.default.progress(`
Test command failed with status code ${exitCode}: ${commandStr}`);
                    }
                    resolve({ exitCode, output: output.join() });
                }
                if (childProcess.exitCode)
                    return report(childProcess.exitCode);
                const onData = (data) => {
                    output.push(data.toString());
                };
                (_a = childProcess.stdout) === null || _a === void 0 ? void 0 : _a.pipe(process.stdout);
                (_b = childProcess.stderr) === null || _b === void 0 ? void 0 : _b.pipe(process.stderr);
                (_c = childProcess.stdout) === null || _c === void 0 ? void 0 : _c.on('data', onData);
                (_d = childProcess.stderr) === null || _d === void 0 ? void 0 : _d.on('data', onData);
                childProcess.on('exit', report);
                if (waitTime) {
                    interruptTimeout = setTimeout(interrupt, waitTime * 1000);
                }
            });
        }
        for (const cmd of TestCommands) {
            cmd.env || (cmd.env = {});
            userInteraction_1.default.progress(`Running test command: ${TestCaseRecording.envString(cmd.env)}${cmd.command}`);
            const args = cmd.command.split(' ');
            const env = Object.assign(process.env, cmd.env);
            const proc = (0, child_process_1.spawn)(args[0], args.slice(1), {
                env,
                shell: true,
                stdio: ['ignore'],
            });
            const { exitCode, output } = await waitForProcess(proc);
            ctx.addResult(new recordContext_1.RecordProcessResult(env, cmd.command, exitCode, output));
        }
    }
    static envString(env) {
        const str = Object.keys(env).length > 0
            ? Object.keys(env)
                .sort()
                .map((key) => [key, env[key]].join('='))
                .join(' ')
            : undefined;
        return str ? `${str} ` : '';
    }
}
exports.default = TestCaseRecording;
//# sourceMappingURL=testCaseRecording.js.map