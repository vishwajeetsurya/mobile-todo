"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestCommand = void 0;
const assert_1 = __importDefault(require("assert"));
const promises_1 = require("fs/promises");
const js_yaml_1 = require("js-yaml");
const path_1 = require("path");
const testCaseRecording_1 = __importDefault(require("./testCaseRecording"));
class TestCommand {
    constructor(command, env = {}) {
        this.command = command;
        this.env = env;
    }
    static toString(cmd) {
        return `${testCaseRecording_1.default.envString(cmd.env)}${cmd.command}`;
    }
}
exports.TestCommand = TestCommand;
class Configuration {
    constructor(appMapFile, settingsFile) {
        this.configDirty = false;
        this.settingsDirty = false;
        this.appMapFile = appMapFile || 'appmap.yml';
        this.settingsFile = settingsFile || (0, path_1.join)(process.env.HOME || '', '.appmaprc');
    }
    async read() {
        this.config = (await readConfig(this.appMapFile)) || {};
        this.settings = (await readAllSettings(this.settingsFile))[this.settingsKey()] || {};
    }
    async write() {
        if (this.configDirty) {
            await (0, promises_1.writeFile)(this.appMapFile, (0, js_yaml_1.dump)(this.config));
            this.configDirty = false;
        }
        if (this.settingsDirty) {
            const all = await readAllSettings(this.settingsFile);
            (0, assert_1.default)(this.settings);
            all[this.settingsKey()] = this.settings;
            await (0, promises_1.writeFile)(this.settingsFile, (0, js_yaml_1.dump)(all));
            this.settingsDirty = false;
        }
    }
    configOption(path, defaultValue) {
        return findOption(this.config, path, defaultValue);
    }
    setConfigOption(path, value) {
        mergeConfigData(this.config, path, value);
        this.configDirty = true;
    }
    setting(path, defaultValue) {
        return findOption(this.settings, path, defaultValue);
    }
    setSetting(path, value) {
        mergeConfigData(this.settings, path, value);
        this.settingsDirty = true;
    }
    requestOptions() {
        const requestOptions = {};
        requestOptions.hostname = this.setting('remote_recording.host', 'localhost').toString();
        requestOptions.port = this.setting('remote_recording.port', 3000);
        requestOptions.path = this.configOption('remote_recording.path', '/').toString();
        requestOptions.protocol = this.configOption('remote_recording.protocol', 'http:').toString();
        return requestOptions;
    }
    locationString() {
        const ro = this.requestOptions();
        return `${ro.protocol}//${ro.hostname}:${ro.port}${ro.path}`;
    }
    settingsKey() {
        return (0, path_1.isAbsolute)(this.appMapFile) ? this.appMapFile : (0, path_1.join)(process.cwd(), this.appMapFile);
    }
}
exports.default = Configuration;
async function readConfig(path) {
    let fileContents;
    try {
        fileContents = await (0, promises_1.readFile)(path);
    }
    catch (_a) {
        return {};
    }
    let config;
    try {
        config = (0, js_yaml_1.load)(fileContents.toString());
    }
    catch (err) {
        console.warn(`Error parsing AppMap config file ${path}: ${err}`);
        config = {};
    }
    return config;
}
async function readAllSettings(path) {
    let settings;
    try {
        const fileContents = await (0, promises_1.readFile)(path);
        settings = (0, js_yaml_1.load)(fileContents.toString());
        // Make sure settings is an object.
        settings['test'];
    }
    catch (_a) {
        settings = {};
    }
    return settings;
}
function findOption(data, path, defaultValue) {
    if (!data)
        return defaultValue;
    const tokens = path.split('.');
    let entry = data;
    for (const token of tokens) {
        if (!entry)
            return defaultValue;
        entry = entry[token];
    }
    return entry || defaultValue;
}
function mergeConfigData(data, path, value) {
    const tokens = path.split('.');
    const lastToken = tokens.pop();
    let entry = data;
    for (const token of tokens) {
        if (!entry[token]) {
            entry[token] = {};
        }
        entry = entry[token];
    }
    if (typeof entry === 'object') {
        if (entry[lastToken] !== value) {
            entry[lastToken] = value;
        }
    }
}
//# sourceMappingURL=configuration.js.map