"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VERSION = void 0;
/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */
const path_1 = require("path");
const graceful_fs_1 = __importDefault(require("graceful-fs"));
const util_1 = require("util");
const models_1 = require("@appland/models");
const assert_1 = __importDefault(require("assert"));
const fileTooLargeError_1 = __importDefault(require("./fileTooLargeError"));
const utils_1 = require("../utils");
const canonicalize_1 = require("./canonicalize");
const appmapIndex_1 = __importDefault(require("./appmapIndex"));
const events_1 = __importDefault(require("events"));
const quotePath_1 = __importDefault(require("../lib/quotePath"));
const renameFile = (0, util_1.promisify)(graceful_fs_1.default.rename);
/**
 * CHANGELOG
 *
 * * # 1.4.0
 *
 * * Include parameter names in the index.
 *
 * * # 1.3.0
 *
 * * Include exceptions in the index.
 *
 * # 1.2.0
 *
 * * Drop fingerprint fields, as these are no longer used by downstream tools.
 *   Canonicalization via sequence diagram is now the preferred mechanism.
 *
 * # 1.1.4
 *
 * * Add missing status_code to normalized AppMaps.
 *
 * # 1.1.3
 *
 * * Removed ctime file. Use mtime to determine when the AppMap was last updated.
 * * Use higher precision for mtime.
 *
 * # 1.1.2
 *
 * * Reject large appmaps to avoid running out of system resources trying to process them.
 *
 * # 1.1.1
 *
 * * Fix parent assignment algorithm.
 *
 * # 1.1.0
 *
 * * Add httpClientRequests, httpServerRequests, labels, sqlNormalized, sqlTables.
 * * Add database_type to CodeObjectType.QUERY and store in metadata.json.
 * * Fix handling of parent assignment in normalization.
 * * sql can contain the analysis (action, tables, columns), and/or the normalized query string.
 */
exports.VERSION = '1.4.0';
const MAX_APPMAP_SIZE = 50 * 1024 * 1024;
class Fingerprinter extends events_1.default {
    constructor() {
        super(...arguments);
        /**
         * Whether to check if the version of the existing index is up to date.
         * When watching files for changes, it can be set to false after the initial
         * pass to avoid re-reading the same 'version' files over and over.
         */
        this.checkVersion = true;
        this.maxFileSizeInBytes = MAX_APPMAP_SIZE;
    }
    async fingerprint(appMapFileName) {
        var _a, _b;
        if ((0, utils_1.verbose)()) {
            console.log(`Indexing ${appMapFileName}`);
        }
        const index = new appmapIndex_1.default(appMapFileName);
        if (!(await index.initialize())) {
            return;
        }
        if ((!this.checkVersion || (await index.versionUpToDate(exports.VERSION))) &&
            (await index.indexUpToDate())) {
            if ((0, utils_1.verbose)()) {
                console.log('Index is up to date. Skipping...');
            }
            return;
        }
        if (this.maxFileSizeInBytes && index.appmapFileSize() > this.maxFileSizeInBytes)
            throw new fileTooLargeError_1.default(appMapFileName, index.appmapFileSize(), this.maxFileSizeInBytes);
        const appmapData = await index.loadAppMapData();
        if (!appmapData)
            return;
        const appmapDataWithoutMetadata = await index.loadAppMapData();
        if (!appmapDataWithoutMetadata)
            return;
        delete appmapDataWithoutMetadata.metadata;
        const appmap = (0, models_1.buildAppMap)(appmapData).normalize().build();
        const numEvents = appmap.events.length;
        // This field is deprecated, because for some change sets the Git status may be large and unweildy.
        // It's also not used anywhere else in the system, so we can just drop it.
        // Because the Git status field is optional anyway, the index version is not being changed for this.
        if ((_b = (_a = appmap === null || appmap === void 0 ? void 0 : appmap.metadata) === null || _a === void 0 ? void 0 : _a.git) === null || _b === void 0 ? void 0 : _b.status) {
            const git = appmap.metadata.git;
            delete git['status'];
        }
        await index.mkdir_p();
        await Promise.all(Object.keys(canonicalize_1.algorithms).map(async (algorithmName) => {
            const canonicalForm = (0, canonicalize_1.canonicalize)(algorithmName, appmap);
            const canonicalJSON = JSON.stringify(canonicalForm, null, 2);
            await index.writeFileAtomic(`canonical.${algorithmName}.json`, canonicalJSON);
        }));
        const tempAppMapFileName = (0, path_1.join)(index.indexDir, 'appmap.tmp');
        await index.writeFileAtomic((0, path_1.basename)(tempAppMapFileName), JSON.stringify(appmap, null, 2));
        const appMapIndexedAt = await (0, utils_1.mtime)(tempAppMapFileName);
        (0, assert_1.default)(appMapIndexedAt, `${tempAppMapFileName} should always exist and be a readable file`);
        await Promise.all([
            index.writeFileAtomic('version', exports.VERSION),
            index.writeFileAtomic('classMap.json', JSON.stringify(appmap.classMap, null, 2)),
            index.writeFileAtomic('metadata.json', JSON.stringify(appmap.metadata, null, 2)),
            index.writeFileAtomic('mtime', `${appMapIndexedAt}`),
        ]);
        // At this point, moving the AppMap file into place will trigger re-indexing.
        // But the mtime will match the file modification time, so the algorithm will
        // determine that the index is up-to-date.
        await renameFile(tempAppMapFileName, appMapFileName);
        // Note: don't remove or modify the output below,
        // it's machine-readable (see doc/index-verbose.md)
        if ((0, utils_1.verbose)())
            console.log(`Indexed ${(0, quotePath_1.default)((0, path_1.resolve)(appMapFileName))}`);
        const result = { path: appMapFileName, metadata: appmap.metadata, numEvents };
        this.emit('index', result);
        return result;
    }
}
exports.default = Fingerprinter;
//# sourceMappingURL=fingerprinter.js.map