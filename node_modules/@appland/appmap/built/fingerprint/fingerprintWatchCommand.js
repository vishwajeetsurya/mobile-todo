"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chokidar_1 = require("chokidar");
const fs_extra_1 = require("fs-extra");
const path_1 = __importStar(require("path"));
const eventAggregator_1 = __importDefault(require("../lib/eventAggregator"));
const utils_1 = require("../utils");
const fingerprintQueue_1 = __importDefault(require("./fingerprintQueue"));
const globber_1 = __importDefault(require("./globber"));
const telemetry_1 = __importDefault(require("../telemetry"));
const emitUsage_1 = __importDefault(require("../lib/emitUsage"));
const promises_1 = require("fs/promises");
const appmapIndex_1 = __importDefault(require("./appmapIndex"));
class FingerprintWatchCommand {
    get numProcessed() {
        return this._numProcessed;
    }
    set numProcessed(value) {
        this._numProcessed = value;
    }
    constructor(directory) {
        this.directory = directory;
        this._numProcessed = 0;
        this.unreadableFiles = new Set();
        this.symlinkLoopFiles = new Set();
        this.doReportUsage = false;
        this.pidfilePath = process.env.APPMAP_WRITE_PIDFILE && (0, path_1.join)(this.directory, 'index.pid');
        this.fpQueue = new fingerprintQueue_1.default();
        this.eventAggregator = new eventAggregator_1.default(async (events) => {
            if (this.doReportUsage)
                await this.reportUsage(events);
            this.numProcessed += events.length;
        });
        this.eventAggregator.attach(this.fpQueue.handler, 'index');
    }
    removePidfile() {
        if (this.pidfilePath) {
            console.log(`Removing ${this.pidfilePath}`);
            (0, fs_extra_1.removeSync)(this.pidfilePath);
            this.pidfilePath = undefined;
        }
    }
    async disableFileWatching() {
        var _a;
        if (this.watcher) {
            console.warn('Will disable file watching. File polling will stay enabled.');
            await ((_a = this.watcher) === null || _a === void 0 ? void 0 : _a.close());
            this.watcher = undefined;
            console.warn('File watching disabled.');
        }
    }
    getFilenameFromErrorMessage(errorMessage) {
        // The errorMessage must contain the filename within single quotes
        // and looks like this:
        // Error: UNKNOWN: unknown error, lstat 'c:\Users\Test\Programming\MyProject'
        let quoteStartIndex = errorMessage.indexOf(`'`);
        let quoteEndIndex = errorMessage.indexOf(`'`, quoteStartIndex + 1);
        return errorMessage.substring(quoteStartIndex + 1, quoteEndIndex);
    }
    isError(error, code) {
        const err = error;
        return err.code === code;
    }
    dontProcessFileAgain(error, filename, telemetryName, files) {
        console.warn(error.stack);
        telemetry_1.default.sendEvent({
            name: telemetryName,
            properties: {
                errorMessage: error.message,
                errorStack: error.stack,
            },
        });
        files.add(filename);
        console.warn('Will not read the file ' + filename + ' again.');
    }
    getToplevelSymbolicLink(filename) {
        // given a filename like '/tmp/topdir/dir1/point_up/dir1/point_up/dir1/point_up'
        // lastToken is set to 'point_up' (the actual symlink)
        // directoryPostfix is set to '/dir1/point_up'
        // topLevelSymbolicLink is set to '/tmp/topdir/dir1/point_up'
        const splitTokens = filename.split(path_1.default.sep);
        const lastToken = splitTokens[splitTokens.length - 1];
        const lastIndex = filename.lastIndexOf(lastToken);
        const secondToLastIndex = filename.lastIndexOf(lastToken, lastIndex - 1);
        const directoryPostfixLength = lastIndex - secondToLastIndex;
        const directoryPostfix = filename.substring(filename.length - directoryPostfixLength, filename.length);
        const splitDirectoryPostfix = filename.split(directoryPostfix);
        const toplevelSymbolicLink = splitDirectoryPostfix[0] + directoryPostfix;
        return toplevelSymbolicLink;
    }
    async watcherErrorFunction(error) {
        if (this.isError(error, 'ENOSPC')) {
            console.warn(error.stack);
            await this.disableFileWatching();
            telemetry_1.default.sendEvent({
                name: `index:watcher_error:enospc`,
                properties: {
                    errorMessage: error.message,
                    errorStack: error.stack,
                },
            });
        }
        else if (this.isError(error, 'EMFILE')) {
            // Don't crash if too many files are open. When the files close
            // the indexer will pick them up.
            console.warn(error.stack);
            await this.disableFileWatching();
            telemetry_1.default.sendEvent({
                name: `index:watcher_error:emfile`,
                properties: {
                    errorMessage: error.message,
                    errorStack: error.stack,
                },
            });
        }
        else if (this.isError(error, 'UNKNOWN') && error.message.includes('lstat')) {
            const filename = this.getFilenameFromErrorMessage(error.message);
            this.dontProcessFileAgain(error, filename, `index:watcher_error:unknown`, this.unreadableFiles);
        }
        else if (this.isError(error, 'ELOOP')) {
            const filename = this.getFilenameFromErrorMessage(error.message);
            const filenameTopLevelSymbolicLink = this.getToplevelSymbolicLink(filename);
            this.dontProcessFileAgain(error, filenameTopLevelSymbolicLink, `index:watcher_error:eloop`, this.symlinkLoopFiles);
        }
        else {
            // let it crash if it's some other error, to learn what the error is
            throw error;
        }
    }
    // Custom ignore function needed to skip unreadableFiles because
    // attempting to read them can block reading all files. It also
    // cuts down the watch tree to just what we need.
    ignored(targetPath) {
        ['/node_modules/', '/.git/'].forEach((pattern) => {
            if (targetPath.includes(pattern)) {
                return true;
            }
        });
        if (this.unreadableFiles.has(targetPath) || this.symlinkLoopFiles.has(targetPath)) {
            return true;
        }
        // Also make sure to not try to recurse down node_modules or .git
        const basename = path_1.default.basename(targetPath);
        return basename === 'node_modules' || basename === '.git';
    }
    async execute(statDelayMs, interval) {
        const glob = `${this.directory}/**/*.appmap.json`;
        this.watcher = new chokidar_1.FSWatcher({
            ignoreInitial: false,
            ignored: this.ignored.bind(this),
            ignorePermissionErrors: true,
        })
            .on('add', this.added.bind(this))
            .on('change', this.changed.bind(this))
            .on('unlink', this.removed.bind(this))
            .on('error', this.watcherErrorFunction.bind(this));
        const watchReady = new Promise((r) => { var _a; return (_a = this.watcher) === null || _a === void 0 ? void 0 : _a.once('ready', r); });
        this.watcher.add(glob);
        await watchReady;
        const scheduledPollerOptions = {};
        if (statDelayMs)
            scheduledPollerOptions.statDelayMs = statDelayMs;
        if (interval)
            scheduledPollerOptions.interval = interval;
        this.poller = new globber_1.default(glob, scheduledPollerOptions)
            .on('add', this.added.bind(this))
            .on('change', this.changed.bind(this))
            .on('unlink', this.removed.bind(this));
        const pollReady = new Promise((r) => { var _a; return (_a = this.poller) === null || _a === void 0 ? void 0 : _a.once('end', r); });
        this.poller.start();
        await pollReady;
        this.ready();
    }
    async close() {
        var _a, _b;
        await Promise.all([
            (_a = this.watcher) === null || _a === void 0 ? void 0 : _a.close(),
            (_b = this.poller) === null || _b === void 0 ? void 0 : _b.close(),
            this.eventAggregator.dispose(),
        ]);
        this.removePidfile();
        this.watcher = undefined;
        this.poller = undefined;
    }
    added(file) {
        if ((0, utils_1.verbose)())
            console.warn(`AppMap added: ${file}`);
        this.enqueue(file);
    }
    changed(file) {
        if ((0, utils_1.verbose)())
            console.warn(`AppMap changed: ${file}`);
        this.enqueue(file);
    }
    removed(file) {
        if ((0, utils_1.verbose)())
            console.warn(`AppMap removed: ${file}`);
        const { indexDir } = new appmapIndex_1.default(file);
        (0, promises_1.rm)(indexDir, { force: true, recursive: true });
    }
    ready() {
        if (this.pidfilePath) {
            (0, fs_extra_1.outputFileSync)(this.pidfilePath, `${process.pid}`);
            process.on('exit', this.removePidfile.bind(this));
        }
        if ((0, utils_1.verbose)()) {
            console.warn(`Watching appmaps in ${(0, path_1.resolve)(process.cwd(), this.directory)}`);
        }
    }
    enqueue(file) {
        // This shouldn't be necessary, but it's passing through the wrong file names.
        if (!file.includes('.appmap.json')) {
            return;
        }
        this.fpQueue.push(file);
    }
    async reportUsage(events) {
        const indexEvents = events.map(({ args: [event] }) => event);
        const { metadata, numEvents } = indexEvents.reduce((acc, { metadata, numEvents }) => ({
            metadata: [...acc.metadata, metadata],
            numEvents: acc.numEvents + numEvents,
        }), { metadata: [], numEvents: 0 });
        await (0, emitUsage_1.default)(this.directory, numEvents, metadata.length, metadata[0]);
    }
}
exports.default = FingerprintWatchCommand;
//# sourceMappingURL=fingerprintWatchCommand.js.map