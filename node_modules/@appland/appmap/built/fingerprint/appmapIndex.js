"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
const promises_1 = require("fs/promises");
const path_1 = require("path");
const semver_1 = require("semver");
const utils_1 = require("../utils");
/**
 * Raw AppMaps are processed into an index, which consists of:
 *
 * * `the-appmap.appmap.json` Canonicalized AppMap file (replaces the original AppMap).
 * * `the-appmap/version` Identifies the index algorithm version.
 * * `the-appmap/classMap.json` 'classMap' object extracted from the AppMap.
 * * `the-appmap/metadata.json` 'metadata' object extracted from the AppMap.
 * * `the-appmap/mtime` Time at which the AppMap was indexed.
 *
 * Other optional fields may be present as well.
 */
class AppMapIndex {
    /**
     * Constructs a new AppMapIndex. After calling the constructor, call `initialize`.
     *
     * @param appmapFileName The path to the AppMap file.
     * @see initialize
     */
    constructor(appmapFileName) {
        this.appmapFileName = appmapFileName;
        this.indexDir = (0, utils_1.baseName)(appmapFileName);
    }
    /**
     * Performs async operations needed to initialize the index. If this method returns false,
     * abort.
     */
    async initialize() {
        try {
            const stats = await (0, promises_1.stat)(this.appmapFileName);
            if (!stats.isFile())
                return false;
            this.appmapCreatedAt = stats.mtimeMs;
            this.size = stats.size;
        }
        catch (error) {
            console.log(`File ${this.appmapFileName} does not exist or is not a file.`);
            return false;
        }
        return true;
    }
    /**
     * Creates the index directory that will contain the processed files.
     */
    async mkdir_p() {
        await (0, promises_1.mkdir)(this.indexDir, { recursive: true });
    }
    /**
     * Creates a data file within the index directory.
     *
     * @param fileName The name of the file to write within the index directory.
     * @param data Raw data to store.
     */
    async writeFileAtomic(fileName, data) {
        (0, assert_1.default)(this.appmapCreatedAt);
        await (0, utils_1.writeFileAtomic)(this.indexDir, fileName, this.appmapCreatedAt.toString(), data);
    }
    /**
     * Loads the raw AppMap data that will be indexed.
     *
     * @returns the raw data of the AppMap file.
     */
    async loadAppMapData() {
        let appmapStr;
        try {
            appmapStr = await (0, promises_1.readFile)(this.appmapFileName, 'utf-8');
        }
        catch (e) {
            if (e.code === 'ENOENT') {
                console.log(`${this.appmapFileName} does not exist.`);
                return;
            }
            throw e;
        }
        if ((0, utils_1.verbose)()) {
            console.log(`Read ${appmapStr.length} bytes from ${this.appmapFileName}`);
        }
        let appmapData;
        try {
            appmapData = JSON.parse(appmapStr);
        }
        catch (err) {
            if (err instanceof SyntaxError) {
                // File may be in the process of writing.
                console.warn(`Error parsing JSON file ${this.appmapFileName} : ${err.message}`);
                return;
            }
            throw err;
        }
        if (!appmapData.metadata) {
            if ((0, utils_1.verbose)()) {
                console.warn(`${this.appmapFileName} has no metadata. Skipping...`);
            }
            return;
        }
        return appmapData;
    }
    /**
     * @returns number of bytes in the AppMap.
     */
    appmapFileSize() {
        (0, assert_1.default)(this.size);
        return this.size;
    }
    /**
     * Tests whether the existing index is using the current algorithm.
     *
     * @param requiredVersion The current version of the index algorithm.
     */
    async versionUpToDate(requiredVersion) {
        const versionFileName = (0, path_1.join)(this.indexDir, 'version');
        let versionStr;
        try {
            versionStr = await (0, promises_1.readFile)(versionFileName, 'utf-8');
        }
        catch (err) {
            if (err.code !== 'ENOENT') {
                throw err;
            }
        }
        if (!versionStr)
            return false;
        versionStr = versionStr.trim();
        if ((0, utils_1.verbose)()) {
            console.log(`${this.indexDir} index version is ${versionStr}`);
        }
        return (0, semver_1.satisfies)(versionStr, `>= ${requiredVersion}`);
    }
    /**
     * Tests whether the existing index is up to date with the raw AppMap data.
     */
    async indexUpToDate() {
        (0, assert_1.default)(this.appmapCreatedAt, `AppMap index is not initialized`);
        const mtimeFileName = (0, path_1.join)(this.indexDir, 'mtime');
        const indexedAt = await (0, utils_1.mtime)(mtimeFileName);
        if (!indexedAt)
            return false;
        if ((0, utils_1.verbose)()) {
            console.log(`${this.indexDir} created at ${this.appmapCreatedAt}, indexed at ${indexedAt}`);
        }
        return indexedAt >= this.appmapCreatedAt;
    }
}
exports.default = AppMapIndex;
//# sourceMappingURL=appmapIndex.js.map