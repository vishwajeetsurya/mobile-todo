"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const async_1 = require("async");
const fileTooLargeError_1 = __importDefault(require("./fileTooLargeError"));
const fingerprinter_1 = __importDefault(require("./fingerprinter"));
function isNodeError(error, code) {
    return error instanceof Error && (!code || error.code === code);
}
class FingerprintQueue {
    constructor(size = 2) {
        this.size = size;
        this.failOnError = true;
        this.pending = new Set();
        // eslint-disable-next-line no-use-before-define
        this.handler = new fingerprinter_1.default();
        this.queue = (0, async_1.queue)(async (appmapFileName) => {
            try {
                await this.handler.fingerprint(appmapFileName);
            }
            catch (e) {
                console.warn(`Error fingerprinting ${appmapFileName}: ${e}`);
            }
            this.pending.delete(appmapFileName);
        }, this.size);
        this.queue.drain(() => (this.handler.checkVersion = false));
        this.queue.error((error) => {
            if (error instanceof fileTooLargeError_1.default) {
                console.warn([
                    `Skipped: ${error.message}`,
                    'Tip: consider recording a shorter interaction or removing some classes from appmap.yml.',
                ].join('\n'));
            }
            else if (isNodeError(error, 'ENOENT')) {
                console.warn(`Skipped: ${error.path}\nThe file does not exist.`);
            }
            else if (this.failOnError) {
                this.lastError = error;
            }
            else {
                console.warn(`Skipped: ${error}`);
            }
        });
    }
    async process() {
        if (!this.queue.idle())
            await this.queue.drain();
        if (this.lastError)
            throw this.lastError;
    }
    push(job) {
        if (this.pending.has(job))
            return;
        this.pending.add(job);
        this.queue.push(job);
    }
}
exports.default = FingerprintQueue;
//# sourceMappingURL=fingerprintQueue.js.map