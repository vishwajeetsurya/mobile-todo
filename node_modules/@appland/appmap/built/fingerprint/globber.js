"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */
const console_1 = require("console");
const fs_1 = __importDefault(require("fs"));
const glob_1 = require("glob");
const stream_1 = require("stream");
const utils_1 = require("../utils");
class Globber extends stream_1.EventEmitter {
    constructor(pattern, { statDelayMs = 1, interval = 5000, fs = fs_1.default } = {}) {
        super();
        this.pattern = pattern;
        this.initialDone = false;
        this.running = false;
        this.mtimes = new Map();
        this.interval = interval;
        this.fs = fs;
        this.statDelayMs = statDelayMs;
    }
    scanNow() {
        (0, console_1.assert)(!this.currentGlob);
        this.timeout = undefined;
        this.currentGlob = new glob_1.Glob(this.pattern, {
            ignore: ['**/node_modules/**', '**/.git/**'],
            strict: false,
            silent: !(0, utils_1.verbose)(),
            cwd: process.cwd(),
            fs: this.fs,
        });
        this.currentGlob.on('end', this.scanEnd.bind(this));
    }
    start() {
        this.running = true;
        this.scanNow();
    }
    close() {
        if (this.currentGlob)
            this.currentGlob.abort();
        if (this.timeout)
            clearTimeout(this.timeout);
        this.running = false;
        this.currentGlob = undefined;
        this.timeout = undefined;
    }
    async scanEnd(found) {
        this.currentGlob = undefined;
        const { initialDone } = this;
        this.initialDone = true;
        const files = new Set(found);
        for (const f of this.mtimes.keys()) {
            if (!files.has(f))
                this.remove(f);
        }
        for (const file of found) {
            try {
                await this.statFile(file);
                if (initialDone)
                    await new Promise((r) => setTimeout(r, this.statDelayMs));
            }
            catch (e) {
                console.warn(e);
            }
        }
        this.emit('end');
        if (this.running)
            this.timeout = setTimeout(this.scanNow.bind(this), this.interval);
    }
    statFile(file) {
        return this.fs.promises.stat(file).then((stat) => this.update(file, stat), () => this.remove(file));
    }
    update(file, { mtimeMs }) {
        const oldTime = this.mtimes.get(file);
        if (oldTime === mtimeMs)
            return;
        this.mtimes.set(file, mtimeMs);
        const event = oldTime ? 'change' : 'add';
        this.emit(event, file);
    }
    remove(file) {
        this.mtimes.delete(file);
        this.emit('unlink', file);
    }
}
exports.default = Globber;
//# sourceMappingURL=globber.js.map