"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.appmapStatsV2 = exports.appmapStatsV1 = exports.collectStats = void 0;
const rpc_1 = require("@appland/rpc");
const utils_1 = require("../../utils");
const promises_1 = require("fs/promises");
const configuration_1 = __importDefault(require("../configuration"));
const path_1 = require("path");
async function getAppmapStats(appmapDirectory) {
    var _a;
    const packages = new Set();
    const classes = new Set();
    const routes = new Set();
    const tables = new Set();
    let numAppMaps = 0;
    const appmapDir = (0, path_1.join)(appmapDirectory.directory, (_a = appmapDirectory.appmapConfig.appmap_dir) !== null && _a !== void 0 ? _a : 'tmp/appmap');
    const collectStrings = (values) => {
        return async (file) => {
            for (const value of JSON.parse(await (0, promises_1.readFile)(file, 'utf-8')))
                values.add(value);
        };
    };
    await (0, utils_1.processNamedFiles)(appmapDir, 'canonical.packages.json', collectStrings(packages));
    await (0, utils_1.processNamedFiles)(appmapDir, 'canonical.classes.json', collectStrings(classes));
    await (0, utils_1.processNamedFiles)(appmapDir, 'canonical.httpServerRequests.json', async (file) => {
        for (const value of JSON.parse(await (0, promises_1.readFile)(file, 'utf-8')))
            routes.add(value.route);
    });
    await (0, utils_1.processNamedFiles)(appmapDir, 'canonical.sqlTables.json', collectStrings(tables));
    await (0, utils_1.processNamedFiles)(appmapDir, 'metadata.json', async () => numAppMaps++);
    return {
        name: appmapDirectory.appmapConfig.name || appmapDirectory.directory,
        directory: appmapDirectory.directory,
        packages: Array.from(packages).sort(),
        classes: Array.from(classes).sort(),
        routes: Array.from(routes).sort(),
        tables: Array.from(tables).sort(),
        numAppMaps,
    };
}
async function collectStats(preloadedAppMapDirectories) {
    const appmapDirectories = preloadedAppMapDirectories !== null && preloadedAppMapDirectories !== void 0 ? preloadedAppMapDirectories : (await (0, configuration_1.default)().appmapDirectories());
    const stats = await Promise.all(appmapDirectories.map((appmapDir) => getAppmapStats(appmapDir)));
    return stats.sort((a, b) => a.name.localeCompare(b.name));
}
exports.collectStats = collectStats;
function appmapStatsV1() {
    return {
        name: ['appmap.stats', rpc_1.AppMapRpc.Stats.V1.Method],
        async handler() {
            const stats = await collectStats();
            return stats.reduce((acc, { packages, classes, routes, tables, numAppMaps }) => {
                acc.packages.push(...packages);
                acc.classes.push(...classes);
                acc.routes.push(...routes);
                acc.tables.push(...new Set(tables));
                acc.numAppMaps += numAppMaps;
                return acc;
            }, {
                packages: [],
                classes: [],
                routes: [],
                tables: [],
                numAppMaps: 0,
            });
        },
    };
}
exports.appmapStatsV1 = appmapStatsV1;
function appmapStatsV2() {
    return {
        name: rpc_1.AppMapRpc.Stats.V2.Method,
        async handler() {
            const stats = await collectStats();
            return stats.map((stat) => (Object.assign(Object.assign({}, stat), { directory: undefined })));
        },
    };
}
exports.appmapStatsV2 = appmapStatsV2;
//# sourceMappingURL=stats.js.map