"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.explainStatusHandler = exports.explainHandler = exports.Explain = exports.DEFAULT_TOKEN_LIMIT = void 0;
const chalk_1 = __importDefault(require("chalk"));
const events_1 = __importDefault(require("events"));
const console_1 = require("console");
const path_1 = require("path");
const client_1 = require("@appland/client");
const rpc_1 = require("@appland/rpc");
const rpc_2 = require("../rpc");
const collectContext_1 = __importDefault(require("./collectContext"));
const configuration_1 = __importDefault(require("../configuration"));
const projectInfo_1 = __importDefault(require("../../cmds/navie/projectInfo"));
const help_1 = __importDefault(require("../../cmds/navie/help"));
const llmConfiguration_1 = require("../llmConfiguration");
const aiEnvVar_1 = __importDefault(require("../../cmds/index/aiEnvVar"));
const report_fetch_error_1 = __importDefault(require("./navie/report-fetch-error"));
const searchStatusByUserMessageId = new Map();
exports.DEFAULT_TOKEN_LIMIT = 12000;
class Explain extends events_1.default {
    constructor(appmapDirectories, projectDirectories, question, codeSelection, appmaps, status, codeEditor) {
        super();
        this.appmapDirectories = appmapDirectories;
        this.projectDirectories = projectDirectories;
        this.question = question;
        this.codeSelection = codeSelection;
        this.appmaps = appmaps;
        this.status = status;
        this.codeEditor = codeEditor;
    }
    async explain(navie) {
        navie.on('ack', (userMessageId, threadId) => {
            // threadId is now pre-allocated by the enrollConversationThread call
            // It may be falsey because errors in enrollConversationThread are logged but do not
            // block the rest of the procedure.
            if (!this.status.threadId)
                this.status.threadId = threadId;
            this.emit('ack', userMessageId, threadId);
        });
        navie.on('token', (token, _messageId) => {
            var _a;
            (_a = this.status).explanation || (_a.explanation = []);
            this.status.explanation.push(token);
        });
        navie.on('complete', () => {
            this.status.step = rpc_1.ExplainRpc.Step.COMPLETE;
            this.emit('complete');
        });
        navie.on('error', (err) => {
            this.status.step = rpc_1.ExplainRpc.Step.ERROR;
            const rpcError = rpc_2.RpcError.fromException(err);
            if (!this.status.err)
                this.status.err = {
                    code: rpcError.code,
                    message: rpcError.message,
                    stack: err.stack,
                    cause: err.cause,
                };
            this.emit('error', rpcError);
        });
        if (!this.status.threadId) {
            const thread = await (0, report_fetch_error_1.default)('enrollConversationThread', () => this.enrollConversationThread(navie));
            if (thread) {
                this.conversationThread = thread;
                this.status.threadId = thread.id;
                if (!thread.permissions.useNavieAIProxy) {
                    (0, console_1.warn)(`Use of Navie AI proxy is forbidden by your organization policy.\nYou can ignore this message if you're using your own AI API key or connecting to your own model.`);
                }
            }
        }
        await navie.ask(this.status.threadId, this.question, this.codeSelection);
    }
    async searchContext(data) {
        const { vectorTerms } = data;
        let { tokenCount } = data;
        this.status.vectorTerms = vectorTerms;
        if (data.labels)
            this.status.labels = data.labels;
        const labels = data.labels || [];
        if (!tokenCount) {
            (0, console_1.warn)(chalk_1.default.bold(`Warning: Token limit not set, defaulting to ${exports.DEFAULT_TOKEN_LIMIT}`));
            tokenCount = exports.DEFAULT_TOKEN_LIMIT;
        }
        if (!vectorTerms || vectorTerms.length === 0) {
            (0, console_1.warn)(chalk_1.default.bold(`Warning: No keywords provided, context result may be unpredictable`));
        }
        const keywords = [...vectorTerms];
        if (labels.find((label) => label.name === 'architecture' && label.weight === 'high') ||
            labels.find((label) => label.name === 'overview' && label.weight === 'high')) {
            keywords.push('architecture');
            keywords.push('design');
            keywords.push('readme');
            keywords.push('about');
            keywords.push('overview');
            for (const dir of this.projectDirectories) {
                keywords.push((0, path_1.basename)(dir));
            }
        }
        // TODO: For 'troubleshoot', include log information
        this.status.step = rpc_1.ExplainRpc.Step.SEARCH_APPMAPS;
        // TODO: More accurate char limit? Probably doesn't matter because they will be
        // pruned by the client AI anyway.
        // The meaning of tokenCount is "try and get at least this many tokens"
        const charLimit = tokenCount * 3;
        const searchResult = await (0, collectContext_1.default)(this.appmapDirectories.map((dir) => dir.directory), this.projectDirectories, this.appmaps, keywords, charLimit);
        this.status.searchResponse = searchResult.searchResponse;
        this.status.contextResponse = searchResult.context;
        this.status.step = rpc_1.ExplainRpc.Step.EXPLAIN;
        return searchResult.context;
    }
    async projectInfoContext() {
        return await (0, projectInfo_1.default)(this.codeEditor);
    }
    helpContext(data) {
        return (0, help_1.default)(data);
    }
    async enrollConversationThread(navie) {
        const modelParameters = Object.assign(Object.assign({}, (0, llmConfiguration_1.getLLMConfiguration)()), { provider: navie.providerName });
        const aiKeyName = (0, aiEnvVar_1.default)();
        if (aiKeyName)
            modelParameters.aiKeyName = aiKeyName;
        const configurationDirectories = await (0, configuration_1.default)().appmapDirectories();
        const directories = configurationDirectories.map((dir) => {
            var _a;
            const result = {
                hasAppMapConfig: dir.appmapConfig !== undefined,
            };
            if ((_a = dir.appmapConfig) === null || _a === void 0 ? void 0 : _a.language) {
                result.language = dir.appmapConfig.language;
            }
            return result;
        });
        const projectParameters = {
            directoryCount: configurationDirectories.length,
            directories,
        };
        if (this.codeEditor)
            projectParameters.codeEditor = this.codeEditor;
        try {
            return await client_1.AI.createConversationThread({ modelParameters, projectParameters });
        }
        catch (err) {
            (0, console_1.warn)(`Failed to create conversation thread`);
            (0, console_1.warn)(err);
            return undefined;
        }
    }
}
exports.Explain = Explain;
async function explain(navieProvider, question, codeSelection, appmaps, threadId, codeEditor) {
    const status = {
        step: rpc_1.ExplainRpc.Step.NEW,
        threadId,
    };
    const appmapDirectories = await (0, configuration_1.default)().appmapDirectories();
    const { projectDirectories } = (0, configuration_1.default)();
    const explain = new Explain(appmapDirectories, projectDirectories, question, codeSelection, appmaps, status, codeEditor);
    const invokeContextFunction = async (data) => {
        const type = data['type'];
        const fnName = [type, 'Context'].join('');
        (0, console_1.warn)(`Explain received context request: ${type}`);
        const fn = explain[fnName];
        if (!fn) {
            (0, console_1.warn)(`Explain context function ${fnName} not found`);
            return {};
        }
        try {
            return await fn.call(explain, data);
        }
        catch (e) {
            (0, console_1.warn)(`Explain context function ${fnName} threw an error:`);
            (0, console_1.warn)(e);
            return {};
        }
    };
    const contextProvider = async (data) => invokeContextFunction(data);
    const projectInfoProvider = async (data) => invokeContextFunction(data);
    const helpProvider = async (data) => invokeContextFunction(data);
    const navie = navieProvider(contextProvider, projectInfoProvider, helpProvider);
    return new Promise((resolve, reject) => {
        let isFirst = true;
        const first = () => {
            if (isFirst) {
                isFirst = false;
                return true;
            }
            return false;
        };
        // TODO: These could be collected into status errors
        explain.on('error', (err) => first() && reject(rpc_2.RpcError.fromException(err)));
        explain.on('ack', (userMessageId, threadId) => {
            status.threadId = threadId;
            const cleanupFn = () => searchStatusByUserMessageId.delete(userMessageId);
            setTimeout(cleanupFn, 1000 * 60 * 5).unref();
            searchStatusByUserMessageId.set(userMessageId, status);
            first() && resolve({ userMessageId, threadId });
        });
        // If the request completes here, consider it an error. This would mean that the
        // remote server terminated our connection early.
        explain.on('complete', () => {
            var _a;
            return first() &&
                reject(rpc_2.RpcError.fromException(new Error(((_a = status.explanation) === null || _a === void 0 ? void 0 : _a.join('')) || 'The response completed unexpectedly')));
        });
        explain.explain(navie).catch((err) => first() && reject(rpc_2.RpcError.fromException(err)));
    });
}
const explainHandler = (navieProvider, codeEditor) => {
    return {
        name: rpc_1.ExplainRpc.ExplainFunctionName,
        handler: async (options) => await explain(navieProvider, options.question, options.codeSelection, options.appmaps, options.threadId, codeEditor),
    };
};
exports.explainHandler = explainHandler;
const explainStatusHandler = () => {
    return {
        name: rpc_1.ExplainRpc.ExplainStatusFunctionName,
        handler: async (options) => {
            const searchStatus = searchStatusByUserMessageId.get(options.userMessageId);
            if (!searchStatus)
                throw new rpc_2.RpcError(404, `No search request with id ${options.userMessageId}`);
            return searchStatus;
        },
    };
};
exports.explainStatusHandler = explainStatusHandler;
//# sourceMappingURL=explain.js.map