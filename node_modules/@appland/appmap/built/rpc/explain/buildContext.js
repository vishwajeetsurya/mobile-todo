"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const models_1 = require("@appland/models");
const assert_1 = __importDefault(require("assert"));
const sequenceDiagram_1 = require("../appmap/sequenceDiagram");
const lookupSourceCode_1 = __importDefault(require("./lookupSourceCode"));
const console_1 = require("console");
const navie_1 = require("@appland/navie");
/**
 * Processes search results to build sequence diagrams, code snippets, and code object sets. This is the format
 * expected by the Navie AI.
 *
 * Given a list of search results, `buildContext` asynchronously:
 *
 * - Generates sequence diagrams for each result using event data and a filtered appmap,
 *   formatting the output as PlantUML and storing it in an array. The filtered sequence diagram
 *   includes only the code objects associated with the events in the search result, and their near neighbors.
 *
 * - Collects and de-duplicates code snippets tied to specific events' locations, storing them in a map with the location as the key.
 *
 * - Gathers a set of unique code objects identified by their fully qualified identifiers (fqid) from the events.
 *   These code objects are most commonly SQL queries and HTTP requests (client and server), since code snipptes are stored separately.
 *   The term "data requests" is being phased in to replace "codeObjects".
 */
async function buildContext(searchResults) {
    const sequenceDiagrams = new Array();
    const codeSnippets = new Array();
    const dataRequests = new Array();
    const codeSnippetLocations = new Set();
    const dataRequestContent = new Set();
    const appmapLocation = (appmap, event) => {
        const appmapFile = [appmap, 'appmap.json'].join('.');
        const tokens = [appmapFile];
        if (event === null || event === void 0 ? void 0 : event.eventIds.length)
            tokens.push(String(event.eventIds[0]));
        return tokens.join(':');
    };
    const buildSequenceDiagram = async (result) => {
        const codeObjects = result.events.map((event) => event.fqid);
        const appmapFilter = new models_1.AppMapFilter();
        appmapFilter.declutter.context.on = true;
        appmapFilter.declutter.context.names = codeObjects;
        const filterState = (0, models_1.serializeFilter)(appmapFilter);
        const plantUML = await (0, sequenceDiagram_1.handler)(result.appmap, {
            filter: filterState,
            format: 'plantuml',
            formatOptions: { disableMarkup: true },
        });
        (0, assert_1.default)(typeof plantUML === 'string');
        sequenceDiagrams.push({
            directory: result.directory,
            location: appmapLocation(result.appmap),
            type: navie_1.ContextV2.ContextItemType.SequenceDiagram,
            content: plantUML,
            score: result.score,
        });
    };
    const examinedLocations = new Set();
    for (const result of searchResults) {
        try {
            await buildSequenceDiagram(result);
        }
        catch (e) {
            (0, console_1.warn)(`Failed to build sequence diagram for ${result.appmap}`);
            (0, console_1.warn)(e);
        }
        for (const event of result.events) {
            if (!event.location) {
                if (!dataRequestContent.has(event.fqid)) {
                    dataRequestContent.add(event.fqid);
                    dataRequests.push({
                        directory: result.directory,
                        location: appmapLocation(result.appmap, event),
                        type: navie_1.ContextV2.ContextItemType.DataRequest,
                        content: event.fqid,
                        score: event.score,
                    });
                }
                continue;
            }
            if (examinedLocations.has(event.location))
                continue;
            examinedLocations.add(event.location);
            if (codeSnippetLocations.has(event.location))
                continue;
            codeSnippetLocations.add(event.location);
            const snippets = await (0, lookupSourceCode_1.default)(result.directory, event.location);
            if (snippets) {
                codeSnippets.push({
                    directory: result.directory,
                    type: navie_1.ContextV2.ContextItemType.CodeSnippet,
                    location: event.location,
                    content: snippets.join('\n'),
                    score: event.score,
                });
            }
        }
    }
    return [...sequenceDiagrams, ...codeSnippets, ...dataRequests];
}
exports.default = buildContext;
//# sourceMappingURL=buildContext.js.map