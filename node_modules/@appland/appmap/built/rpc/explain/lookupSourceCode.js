"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LANGUAGE_BY_FILE_EXTENSION = void 0;
const chalk_1 = __importDefault(require("chalk"));
const console_1 = require("console");
const promises_1 = require("fs/promises");
const glob_1 = require("glob");
const text_splitter_1 = require("langchain/text_splitter");
const utils_1 = require("../../utils");
const util_1 = require("util");
exports.LANGUAGE_BY_FILE_EXTENSION = {
    '.js': 'js',
    '.ts': 'js',
    '.jsx': 'js',
    '.tsx': 'js',
    '.java': 'java',
    '.py': 'python',
    '.rb': 'ruby',
};
// TODO: Look up different types of files
const scannedExtensions = new Set();
let FILE_NAMES = new Set();
// TODO: Return source code up to the next location in the class map.
// TODO: Reverse-strip comment that follow the function.
async function lookupSourceCode(directory, location) {
    if ((0, utils_1.verbose)())
        (0, console_1.warn)(chalk_1.default.gray(`Looking up source code for ${location}`));
    const [requestedFileName, lineNoStr] = location.split(':');
    const extension = requestedFileName.slice(requestedFileName.lastIndexOf('.'));
    if (!scannedExtensions.has(extension)) {
        scannedExtensions.add(extension);
        // dot: true is present to include the .tox directory for Python
        const fileNames = await (0, util_1.promisify)(glob_1.glob)(`${directory}/**/*${extension}`, {
            dot: true,
            ignore: [
                '**/node_modules/**',
                '**/vendor/**',
                '**/tmp/**',
                '**/build/**',
                '**/dist/**',
                '**/target/**',
                '**/.git/**',
            ],
        });
        if ((0, utils_1.verbose)())
            (0, console_1.warn)(chalk_1.default.gray(`Found ${fileNames.length} files with extension "${extension}"`));
        for (const fileName of fileNames) {
            FILE_NAMES.add(fileName);
        }
    }
    const candidates = Array.from(FILE_NAMES).filter((candidate) => candidate.endsWith(requestedFileName));
    if (candidates.length === 0) {
        (0, console_1.warn)(chalk_1.default.gray(`File not found in the workspace: ${requestedFileName}`));
        return;
    }
    candidates.sort((a, b) => a.length - b.length);
    const fileName = candidates[0];
    if (!(await (0, utils_1.exists)(fileName))) {
        (0, console_1.warn)(chalk_1.default.gray(`File ${fileName} does not exist`));
        return;
    }
    const fileContent = await (0, promises_1.readFile)(fileName, 'utf-8');
    if (!lineNoStr)
        return [fileContent];
    let lineNo = parseInt(lineNoStr, 10);
    if (lineNo <= 0)
        return [fileContent];
    const fileExtension = fileName.slice(fileName.lastIndexOf('.'));
    const language = exports.LANGUAGE_BY_FILE_EXTENSION[fileExtension];
    let splitter;
    if (language) {
        splitter = text_splitter_1.RecursiveCharacterTextSplitter.fromLanguage(language, {
            chunkOverlap: 0,
            chunkSize: 500,
        });
    }
    else {
        splitter = new text_splitter_1.RecursiveCharacterTextSplitter({
            chunkOverlap: 0,
            chunkSize: 250,
        });
    }
    const chunks = await splitter.createDocuments([fileContent]);
    const matches = chunks.filter((chunk) => chunk.metadata.loc.lines.from <= lineNo && chunk.metadata.loc.lines.to >= lineNo);
    if ((0, utils_1.verbose)())
        (0, console_1.warn)(chalk_1.default.gray(`Obtained ${matches.length} source code chunks for ${location}`));
    return matches.map((match) => match.pageContent);
}
exports.default = lookupSourceCode;
//# sourceMappingURL=lookupSourceCode.js.map