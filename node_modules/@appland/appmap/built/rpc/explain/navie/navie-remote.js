"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const console_1 = require("console");
const events_1 = __importDefault(require("events"));
const client_1 = require("@appland/client");
const navie_1 = require("@appland/navie");
const utils_1 = require("../../../utils");
const assert_1 = __importDefault(require("assert"));
class RemoteNavie extends events_1.default {
    constructor(contextProvider, projectInfoProvider, helpProvider) {
        super();
        this.contextProvider = contextProvider;
        this.projectInfoProvider = projectInfoProvider;
        this.helpProvider = helpProvider;
    }
    get providerName() {
        return 'remote';
    }
    setOption(key, _value) {
        throw new Error(`RemoteNavie does not support option '${key}'`);
    }
    async ask(threadId, question, codeSelection) {
        (await client_1.AI.connect({
            onAck: (userMessageId, threadId) => {
                if ((0, utils_1.verbose)())
                    (0, console_1.warn)(`Explain received ack (userMessageId=${userMessageId}, threadId=${threadId})`);
                this.emit('ack', userMessageId, threadId);
            },
            onToken: (token, _messageId) => {
                this.emit('token', token);
            },
            onRequestContext: async (data) => {
                try {
                    if (data.type === 'search') {
                        const { version } = data;
                        const isVersion1 = !version || version === 1;
                        // ContextV2.ContextRequest is a superset of ContextV1.ContextRequest, so whether the input
                        // version is V1 or V2, we can treat it as V2.
                        const contextRequestV2 = data;
                        const responseV2 = await this.contextProvider(Object.assign(Object.assign({}, contextRequestV2), { type: 'search', version: 2 }));
                        if (isVersion1) {
                            // Adapt from V2 response back to V1. Some data may be lost in this process.
                            const responseV1 = {
                                sequenceDiagrams: responseV2
                                    .filter((item) => item.type === navie_1.ContextV2.ContextItemType.SequenceDiagram)
                                    .map((item) => item.content),
                                codeSnippets: responseV2
                                    .filter((item) => item.type === navie_1.ContextV2.ContextItemType.CodeSnippet)
                                    .reduce((acc, item) => {
                                    (0, assert_1.default)(item.type === navie_1.ContextV2.ContextItemType.CodeSnippet);
                                    if (navie_1.ContextV2.isFileContextItem(item)) {
                                        acc[item.location] = item.content;
                                    }
                                    return acc;
                                }, {}),
                                codeObjects: responseV2
                                    .filter((item) => item.type === navie_1.ContextV2.ContextItemType.DataRequest)
                                    .map((item) => item.content),
                            };
                            return responseV1;
                        }
                        else {
                            return responseV2;
                        }
                    }
                    if (data.type === 'projectInfo') {
                        return ((await this.projectInfoProvider(data)) || {});
                    }
                    if (data.type === 'help') {
                        return (await this.helpProvider(data)) || {};
                    }
                    else {
                        (0, console_1.warn)(`Unhandled context request type: ${data.type}`);
                        // A response is required from this function.
                        return {};
                    }
                }
                catch (e) {
                    (0, console_1.warn)(`Explain context function ${JSON.stringify(data)} threw an error: ${e}`);
                    // TODO: Report an error object instead?
                    return {};
                }
            },
            onComplete: () => {
                if ((0, utils_1.verbose)())
                    (0, console_1.warn)(`Explain is complete`);
                this.emit('complete');
            },
            onError: (err) => {
                if ((0, utils_1.verbose)())
                    (0, console_1.warn)(`Error handled by Explain: ${err}`);
                this.emit('error', err);
            },
        })).inputPrompt({ question: question, codeSelection: codeSelection }, { threadId, tool: 'explain' });
    }
}
exports.default = RemoteNavie;
//# sourceMappingURL=navie-remote.js.map