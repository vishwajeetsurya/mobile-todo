"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _LocalNavie_instances, _LocalNavie_skipTelemetry, _LocalNavie_reportConfigTelemetry;
Object.defineProperty(exports, "__esModule", { value: true });
const console_1 = require("console");
const events_1 = __importDefault(require("events"));
const promises_1 = require("fs/promises");
const crypto_1 = require("crypto");
const path_1 = require("path");
const os_1 = require("os");
const navie_1 = require("@appland/navie");
const telemetry_1 = __importDefault(require("../../../telemetry"));
const client_1 = require("@appland/client");
const report_fetch_error_1 = __importDefault(require("./report-fetch-error"));
const assert_1 = __importDefault(require("assert"));
class LocalHistory {
    constructor(threadId) {
        this.threadId = threadId;
    }
    async saveMessage(message) {
        if (!['user', 'assistant'].includes(message.role))
            throw new Error(`Invalid message role for conversation history : ${message.role}`);
        await this.initHistory();
        const timestampNumber = Date.now();
        const historyFile = (0, path_1.join)(this.historyDir, `${timestampNumber}.json`);
        await (0, promises_1.writeFile)(historyFile, JSON.stringify(message, null, 2));
    }
    async restoreMessages() {
        await this.initHistory();
        const historyFiles = (await (0, promises_1.readdir)(this.historyDir)).sort();
        const history = [];
        for (const historyFile of historyFiles) {
            const historyPath = (0, path_1.join)(this.historyDir, historyFile);
            const historyString = await (0, promises_1.readFile)(historyPath, 'utf-8');
            const message = JSON.parse(historyString);
            // Fix messages that were miscategorized.
            if (message.role === 'system') {
                message.role = 'assistant';
            }
            history.push(message);
        }
        return history;
    }
    async initHistory() {
        await (0, promises_1.mkdir)(this.historyDir, { recursive: true });
    }
    get historyDir() {
        return (0, path_1.join)((0, os_1.homedir)(), '.appmap', 'navie', 'history', this.threadId);
    }
}
const OPTION_SETTERS = {
    tokenLimit: (navieOptions, value) => {
        navieOptions.tokenLimit = typeof value === 'string' ? parseInt(value, 10) : value;
    },
    temperature: (navieOptions, value) => {
        navieOptions.temperature = typeof value === 'string' ? parseFloat(value) : value;
    },
    modelName: (navieOptions, value) => {
        navieOptions.modelName = String(value);
    },
    explainMode: () => {
        (0, console_1.warn)(`Option 'explainMode' is deprecated and will be ignored`);
    },
};
class LocalNavie extends events_1.default {
    constructor(contextProvider, projectInfoProvider, helpProvider) {
        super();
        this.contextProvider = contextProvider;
        this.projectInfoProvider = projectInfoProvider;
        this.helpProvider = helpProvider;
        _LocalNavie_instances.add(this);
        this.navieOptions = new navie_1.Navie.NavieOptions();
        _LocalNavie_skipTelemetry.set(this, !telemetry_1.default.enabled);
    }
    get providerName() {
        return 'local';
    }
    setOption(key, value) {
        const setter = OPTION_SETTERS[key];
        if (setter) {
            setter(this.navieOptions, value);
        }
        else {
            throw new Error(`LocalNavie does not support option '${key}'`);
        }
    }
    async ask(threadId, question, codeSelection) {
        var _a, e_1, _b, _c;
        var _d, _e, _f, _g;
        if (!threadId) {
            (0, console_1.warn)(`[local-navie] No threadId provided for question. Allocating a new threadId.`);
            // eslint-disable-next-line no-param-reassign
            threadId = (0, crypto_1.randomUUID)();
        }
        let userMessageId;
        {
            const userMessage = {
                questionLength: question.length,
            };
            if (codeSelection)
                userMessage.codeSelectionLength = codeSelection.length;
            userMessageId =
                (_e = (_d = (await (0, report_fetch_error_1.default)('createUserMessage', () => ((0, assert_1.default)(threadId), client_1.AI.createUserMessage(threadId, userMessage))))) === null || _d === void 0 ? void 0 : _d.id) !== null && _e !== void 0 ? _e : (0, crypto_1.randomUUID)();
        }
        let agentMessageId;
        {
            const agentMessage = {};
            agentMessageId =
                (_g = (_f = (await (0, report_fetch_error_1.default)('createAgentMessage', () => ((0, assert_1.default)(threadId), client_1.AI.createAgentMessage(threadId, agentMessage))))) === null || _f === void 0 ? void 0 : _f.id) !== null && _g !== void 0 ? _g : (0, crypto_1.randomUUID)();
        }
        const history = new LocalHistory(threadId);
        __classPrivateFieldGet(this, _LocalNavie_instances, "m", _LocalNavie_reportConfigTelemetry).call(this);
        (0, console_1.log)(`[local-navie] Processing question ${userMessageId} in thread ${threadId}`);
        this.emit('ack', userMessageId, threadId);
        const clientRequest = {
            question,
            codeSelection,
        };
        const messages = await history.restoreMessages();
        await history.saveMessage({ content: question, role: 'user' });
        const startTime = Date.now();
        const navieFn = (0, navie_1.navie)(clientRequest, this.contextProvider, this.projectInfoProvider, this.helpProvider, this.navieOptions, messages);
        let agentName;
        let classification;
        navieFn.on('event', (event) => this.emit('event', event));
        navieFn.on('agent', (agent) => (agentName = agent));
        navieFn.on('classification', (labels) => (classification = labels));
        const response = new Array();
        try {
            for (var _h = true, _j = __asyncValues(navieFn.execute()), _k; _k = await _j.next(), _a = _k.done, !_a;) {
                _c = _k.value;
                _h = false;
                try {
                    const token = _c;
                    response.push(token);
                    this.emit('token', token, agentMessageId);
                }
                finally {
                    _h = true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_h && !_a && (_b = _j.return)) await _b.call(_j);
            }
            finally { if (e_1) throw e_1.error; }
        }
        const endTime = Date.now();
        const duration = endTime - startTime;
        (0, console_1.warn)(`[local-navie] Completed question ${userMessageId} in ${duration}ms`);
        await history.saveMessage({ content: response.join(''), role: 'assistant' });
        {
            const userMessage = {
                agentName,
                classification,
            };
            await (0, report_fetch_error_1.default)('updateUserMessage', () => client_1.AI.updateUserMessage(userMessageId, userMessage));
        }
        {
            const agentMessage = {
                responseLength: response.join('').length,
                responseTime: duration,
            };
            await (0, report_fetch_error_1.default)('updateAgentMessage', () => client_1.AI.updateAgentMessage(agentMessageId, agentMessage));
        }
        this.emit('complete');
    }
}
exports.default = LocalNavie;
_LocalNavie_skipTelemetry = new WeakMap(), _LocalNavie_instances = new WeakSet(), _LocalNavie_reportConfigTelemetry = function _LocalNavie_reportConfigTelemetry() {
    if (__classPrivateFieldGet(this, _LocalNavie_skipTelemetry, "f"))
        return;
    telemetry_1.default.sendEvent({
        name: 'navie-local',
        properties: {
            modelName: this.navieOptions.modelName,
            azureVersion: process.env.AZURE_OPENAI_API_VERSION,
        },
    });
    __classPrivateFieldSet(this, _LocalNavie_skipTelemetry, true, "f");
};
//# sourceMappingURL=navie-local.js.map