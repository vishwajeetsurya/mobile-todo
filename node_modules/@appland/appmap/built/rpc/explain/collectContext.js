"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContextCollector = exports.SourceCollector = exports.EventCollector = exports.textSearchResultToRpcSearchResult = void 0;
const AppMapIndex_1 = __importDefault(require("../../fulltext/AppMapIndex"));
const FindEvents_1 = __importDefault(require("../../fulltext/FindEvents"));
const search_1 = require("../search/search");
const buildContext_1 = __importDefault(require("./buildContext"));
const console_1 = require("console");
const path_1 = require("path");
const navie_1 = require("@appland/navie");
const FileIndex_1 = require("../../fulltext/FileIndex");
const withIndex_1 = __importDefault(require("../../fulltext/withIndex"));
const SourceIndex_1 = require("../../fulltext/SourceIndex");
function textSearchResultToRpcSearchResult(eventResult) {
    const result = {
        fqid: eventResult.fqid,
        score: eventResult.score,
        eventIds: eventResult.eventIds,
    };
    if (eventResult.location)
        result.location = eventResult.location;
    if (eventResult.elapsed)
        result.elapsed = eventResult.elapsed;
    return result;
}
exports.textSearchResultToRpcSearchResult = textSearchResultToRpcSearchResult;
class EventCollector {
    constructor(query, appmapSearchResponse) {
        this.query = query;
        this.appmapSearchResponse = appmapSearchResponse;
        this.appmapIndexes = new Map();
    }
    async collectEvents(maxEvents) {
        const results = new Array();
        for (const result of this.appmapSearchResponse.results) {
            let { appmap } = result;
            if (!(0, path_1.isAbsolute)(appmap))
                appmap = (0, path_1.join)(result.directory, appmap);
            const eventsSearchResponse = await this.findEvents(appmap, maxEvents);
            results.push({
                appmap: appmap,
                directory: result.directory,
                events: eventsSearchResponse.results.map(textSearchResultToRpcSearchResult),
                score: result.score,
            });
        }
        const context = await (0, buildContext_1.default)(results);
        const contextSize = context.reduce((acc, item) => acc + item.content.length, 0);
        return { results, context, contextSize };
    }
    async appmapIndex(appmap) {
        let index = this.appmapIndexes.get(appmap);
        if (!index) {
            index = new FindEvents_1.default(appmap);
            await index.initialize();
            this.appmapIndexes.set(appmap, index);
        }
        return index;
    }
    async findEvents(appmap, maxResults) {
        if (appmap.endsWith('.appmap.json'))
            appmap = appmap.slice(0, -'.appmap.json'.length);
        const index = await this.appmapIndex(appmap);
        return index.search(this.query, { maxResults });
    }
}
exports.EventCollector = EventCollector;
const CHARS_PER_SNIPPET = 50;
class SourceCollector {
    constructor(keywords, fileSearchResponse) {
        this.keywords = keywords;
        this.fileSearchResponse = fileSearchResponse;
    }
    async collectContext(charLimit) {
        const sourceIndexDocuments = await (0, withIndex_1.default)('source', (indexFileName) => (0, SourceIndex_1.buildSourceIndex)(indexFileName, this.fileSearchResponse), (index) => index.search(this.keywords, Math.round(charLimit / CHARS_PER_SNIPPET)));
        const buildLocation = (doc) => {
            return `${doc.fileName}:${doc.from}-${doc.to}`;
        };
        return sourceIndexDocuments.map((doc) => ({
            directory: doc.directory,
            type: navie_1.ContextV2.ContextItemType.CodeSnippet,
            content: doc.content,
            location: buildLocation(doc),
        }));
    }
}
exports.SourceCollector = SourceCollector;
class ContextCollector {
    constructor(appmapDirectories, sourceDirectories, vectorTerms, charLimit) {
        this.appmapDirectories = appmapDirectories;
        this.sourceDirectories = sourceDirectories;
        this.vectorTerms = vectorTerms;
        this.charLimit = charLimit;
        this.query = vectorTerms.join(' ');
    }
    async collectContext() {
        const query = this.vectorTerms.join(' ');
        let appmapSearchResponse;
        if (this.appmaps) {
            const results = this.appmaps
                .map((appmap) => {
                const directory = this.appmapDirectories.find((dir) => appmap.startsWith(dir));
                if (!directory)
                    return undefined;
                return {
                    appmap,
                    directory,
                    score: 1,
                };
            })
                .filter(Boolean);
            appmapSearchResponse = {
                type: 'appmap',
                stats: {
                    max: 1,
                    mean: 1,
                    median: 1,
                    stddev: 0,
                },
                results,
                numResults: this.appmaps.length,
            };
        }
        else {
            // Search across all AppMaps, creating a map from AppMap id to AppMapSearchResult
            const searchOptions = {
                maxResults: search_1.DEFAULT_MAX_DIAGRAMS,
            };
            appmapSearchResponse = await AppMapIndex_1.default.search(this.appmapDirectories, query, searchOptions);
        }
        const fileSearchResponse = await (0, withIndex_1.default)('files', (indexFileName) => (0, FileIndex_1.buildFileIndex)(this.sourceDirectories, indexFileName), (index) => index.search(this.vectorTerms, search_1.DEFAULT_MAX_FILES));
        const eventsCollector = new EventCollector(this.query, appmapSearchResponse);
        const sourceCollector = new SourceCollector(this.vectorTerms, fileSearchResponse);
        let contextCandidate;
        let charCount = 0;
        let maxEventsPerDiagram = 5;
        (0, console_1.log)(`Requested char limit: ${this.charLimit}`);
        for (;;) {
            (0, console_1.log)(`Collecting context with ${maxEventsPerDiagram} events per diagram.`);
            contextCandidate = await eventsCollector.collectEvents(maxEventsPerDiagram);
            const codeSnippetCount = contextCandidate.context.filter((item) => item.type === navie_1.ContextV2.ContextItemType.CodeSnippet).length;
            let sourceContext = [];
            if (codeSnippetCount === 0) {
                sourceContext = await sourceCollector.collectContext(this.charLimit);
            }
            else {
                sourceContext = await sourceCollector.collectContext(this.charLimit / 4);
            }
            contextCandidate.context = contextCandidate.context.concat(sourceContext);
            const appliedContext = (0, navie_1.applyContext)(contextCandidate.context, this.charLimit);
            const appliedContextSize = appliedContext.reduce((acc, item) => acc + item.content.length, 0);
            contextCandidate.context = appliedContext;
            contextCandidate.contextSize = appliedContextSize;
            (0, console_1.log)(`Collected an estimated ${appliedContextSize} characters.`);
            if (appliedContextSize === charCount || appliedContextSize > this.charLimit) {
                break;
            }
            charCount = appliedContextSize;
            maxEventsPerDiagram = Math.ceil(maxEventsPerDiagram * 1.5);
            (0, console_1.log)(`Increasing max events per diagram to ${maxEventsPerDiagram}.`);
        }
        return {
            searchResponse: {
                results: contextCandidate.results,
                numResults: appmapSearchResponse.numResults,
            },
            context: contextCandidate.context,
        };
    }
}
exports.ContextCollector = ContextCollector;
async function collectContext(appmapDirectories, sourceDirectories, appmaps, vectorTerms, charLimit) {
    const contextCollector = new ContextCollector(appmapDirectories, sourceDirectories, vectorTerms, charLimit);
    if (appmaps)
        contextCollector.appmaps = appmaps;
    return await contextCollector.collectContext();
}
exports.default = collectContext;
//# sourceMappingURL=collectContext.js.map