"use strict";
// This function is used for a "one-shot" search in which the index us built, used, and discarded.
// Replace this with a persistent index file that can be used across multiple searches, and is
Object.defineProperty(exports, "__esModule", { value: true });
const promises_1 = require("fs/promises");
const os_1 = require("os");
const path_1 = require("path");
// synced with the file system as needed.
async function withIndex(indexName, builder, callback) {
    const tmpDir = await (0, promises_1.mkdtemp)((0, path_1.join)((0, os_1.tmpdir)(), `appmap-${indexName}-${new Date().getTime()}`));
    const indexFile = (0, path_1.join)(tmpDir, 'index.sqlite');
    const close = (index) => {
        try {
            index.close();
        }
        catch (err) {
            console.error(err);
        }
    };
    const cleanupDir = async () => await (0, promises_1.rm)(tmpDir, { recursive: true }).catch((err) => console.error(err));
    let index;
    try {
        index = await builder(indexFile);
        return await callback(index);
    }
    finally {
        if (index)
            close(index);
        await cleanupDir();
    }
}
exports.default = withIndex;
//# sourceMappingURL=withIndex.js.map