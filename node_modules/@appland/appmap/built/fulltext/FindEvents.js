"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const models_1 = require("@appland/models");
const console_1 = require("console");
const promises_1 = require("fs/promises");
const utils_1 = require("../utils");
const lunr_1 = __importDefault(require("lunr"));
const collectParameters_1 = require("./collectParameters");
const assert_1 = __importDefault(require("assert"));
const queryKeywords_1 = __importDefault(require("./queryKeywords"));
class FindEvents {
    constructor(appmapIndexDir) {
        this.appmapIndexDir = appmapIndexDir;
        this.indexItemsByFqid = new Map();
    }
    get appmapId() {
        return this.appmapIndexDir;
    }
    get appmap() {
        (0, assert_1.default)(this.filteredAppMap);
        return this.filteredAppMap;
    }
    async initialize() {
        const appmapFile = [this.appmapId, 'appmap.json'].join('.');
        const builder = (0, models_1.buildAppMap)().source(await (0, promises_1.readFile)(appmapFile, 'utf-8'));
        if (this.maxSize)
            builder.prune(this.maxSize);
        const baseAppMap = builder.build();
        if ((0, utils_1.verbose)())
            (0, console_1.log)(`[FindEvents] Built AppMap with ${baseAppMap.events.length} events.`);
        let filteredAppMap;
        if (this.filter) {
            if ((0, utils_1.verbose)())
                (0, console_1.warn)(`Applying custom AppMap filters.`);
            filteredAppMap = this.filter.filter(baseAppMap, []);
        }
        else {
            filteredAppMap = baseAppMap;
        }
        if ((0, utils_1.verbose)())
            (0, console_1.log)(`[FindEvents] Filtered AppMap has ${filteredAppMap.events.length} events.`);
        if ((0, utils_1.verbose)())
            (0, console_1.log)(`[FindEvents] Indexing events in AppMap ${this.appmapId}`);
        const indexEvent = (event, depth = 0) => {
            const co = event.codeObject;
            const parameters = (0, collectParameters_1.collectParameters)(event);
            if (!this.indexItemsByFqid.has(co.fqid)) {
                const item = {
                    fqid: co.fqid,
                    name: (0, queryKeywords_1.default)(co.id),
                    parameters: (0, queryKeywords_1.default)(parameters),
                    // TODO: Transform the location into keywords, then restore as the original location path.
                    // Currently, this field is not indexed.
                    location: co.location,
                    eventIds: [event.id],
                };
                if (event.elapsedTime)
                    item.elapsed = event.elapsedTime;
                this.indexItemsByFqid.set(co.fqid, item);
            }
            else {
                const existing = this.indexItemsByFqid.get(co.fqid);
                if (existing) {
                    existing.eventIds.push(event.id);
                    if (event.elapsedTime)
                        existing.elapsed = (existing.elapsed || 0) + event.elapsedTime;
                    for (const parameter of parameters)
                        if (!existing.parameters.includes(parameter))
                            existing.parameters.push(parameter);
                }
            }
            event.children.forEach((child) => indexEvent(child, depth + 1));
        };
        filteredAppMap.rootEvents().forEach((event) => indexEvent(event));
        this.filteredAppMap = filteredAppMap;
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        this.idx = (0, lunr_1.default)(function () {
            this.ref('fqid');
            this.field('name');
            this.field('parameters');
            this.tokenizer.separator = /[\s/\-_:#.]+/;
            self.indexItemsByFqid.forEach((item) => {
                let boost = 1;
                if (item.location)
                    boost += 1;
                if (item.eventIds.length > 1)
                    boost += 1;
                this.add(item, { boost });
            });
        });
    }
    search(search, options = {}) {
        (0, assert_1.default)(this.idx);
        let matches = this.idx.search((0, queryKeywords_1.default)(search).join(' '));
        const numResults = matches.length;
        if ((0, utils_1.verbose)())
            (0, console_1.log)(`[FindEvents] Got ${numResults} event matches for search "${search}" within AppMap "${this.appmapId}`);
        if (options.maxResults && numResults > options.maxResults) {
            if ((0, utils_1.verbose)())
                (0, console_1.log)(`[FindEvents] Limiting to the top ${options.maxResults} event matches within AppMap "${this.appmapId}"`);
            matches = matches.slice(0, options.maxResults);
        }
        const searchResults = matches.map((match) => {
            var _a;
            const indexItem = this.indexItemsByFqid.get(match.ref);
            (0, assert_1.default)(indexItem);
            const result = {
                appmap: this.appmapId,
                fqid: match.ref,
                score: match.score,
                elapsed: indexItem === null || indexItem === void 0 ? void 0 : indexItem.elapsed,
                eventIds: (_a = indexItem === null || indexItem === void 0 ? void 0 : indexItem.eventIds) !== null && _a !== void 0 ? _a : [],
            };
            if (indexItem === null || indexItem === void 0 ? void 0 : indexItem.location)
                result.location = indexItem.location;
            return result;
        });
        return { type: 'event', results: searchResults, numResults };
    }
}
exports.default = FindEvents;
//# sourceMappingURL=FindEvents.js.map