"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _SourceIndex_insert, _SourceIndex_indexChunks;
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildSourceIndex = exports.SourceIndex = void 0;
const text_splitter_1 = require("langchain/text_splitter");
const assert_1 = __importDefault(require("assert"));
const better_sqlite3_1 = __importDefault(require("better-sqlite3"));
const fs_1 = require("fs");
const utils_1 = require("../utils");
const promises_1 = require("fs/promises");
const path_1 = require("path");
const queryKeywords_1 = __importDefault(require("./queryKeywords"));
const TEXT_SPLITTER_LANGUAGE_EXTENSIONS = {
    cpp: ['cpp', 'h', 'hpp', 'c', 'cc', 'cxx', 'hxx'],
    go: ['go'],
    java: ['java', 'jsp', 'jspx'],
    js: ['js', 'ts', 'mjs', 'jsx', 'tsx', 'vue', 'svelte'],
    php: ['php'],
    proto: ['proto'],
    python: ['py'],
    rst: ['rst'],
    ruby: ['rb', 'haml', 'erb'],
    rust: ['rs'],
    scala: ['scala'],
    swift: ['swift'],
    markdown: ['md'],
    latex: ['tex'],
    html: ['html'],
    sol: ['sol'],
};
class SourceIndex {
    constructor(database) {
        this.database = database;
        _SourceIndex_insert.set(this, void 0);
        _SourceIndex_indexChunks.set(this, this.database.transaction((chunks, directory, fileName) => {
            for (const chunk of chunks) {
                const { from, to } = chunk.metadata.loc.lines;
                try {
                    if ((0, utils_1.verbose)())
                        console.log(`Indexing document ${fileName} from ${from} to ${to}`);
                    const terms = (0, queryKeywords_1.default)([chunk.pageContent]).join(' ');
                    __classPrivateFieldGet(this, _SourceIndex_insert, "f").run(directory, fileName, from, to, chunk.pageContent, terms);
                }
                catch (error) {
                    console.warn(`Error indexing document ${fileName} from ${from} to ${to}`);
                    console.warn(error);
                }
            }
        }));
        this.database.exec(`CREATE VIRTUAL TABLE code_snippets USING fts5(directory UNINDEXED, file_name UNINDEXED, from_line UNINDEXED, to_line UNINDEXED, snippet UNINDEXED, terms, tokenize = 'porter unicode61')`);
        this.database.pragma('journal_mode = OFF');
        this.database.pragma('synchronous = OFF');
        __classPrivateFieldSet(this, _SourceIndex_insert, this.database.prepare('INSERT INTO code_snippets (directory, file_name, from_line, to_line, snippet, terms) VALUES (?, ?, ?, ?, ?, ?)'), "f");
    }
    close() {
        this.database.close();
    }
    search(keywords, limit = 10) {
        const query = `SELECT directory, file_name, from_line, to_line, snippet, (rank * -1) score FROM code_snippets WHERE code_snippets MATCH ? ORDER BY rank LIMIT ?`;
        const searchExpr = (0, queryKeywords_1.default)(keywords).join(' OR ');
        const rows = this.database.prepare(query).all(searchExpr, limit);
        rows.forEach((row) => {
            if ((0, utils_1.verbose)())
                console.log(`[SourceIndex] Found row ${row.file_name}`);
        });
        return rows.map((row) => ({
            directory: row.directory,
            fileName: row.file_name,
            from: row.from_line,
            to: row.to_line,
            content: row.snippet,
            score: row.score,
        }));
    }
    async indexFiles(files) {
        for (const file of files) {
            await this.indexFile(file);
        }
    }
    async indexFile(file) {
        const { directory, fileName } = file;
        const extension = fileName.split('.').pop();
        const language = Object.keys(TEXT_SPLITTER_LANGUAGE_EXTENSIONS).find((language) => TEXT_SPLITTER_LANGUAGE_EXTENSIONS[language].includes(extension));
        let splitter;
        if (language) {
            splitter = text_splitter_1.RecursiveCharacterTextSplitter.fromLanguage(language);
        }
        else {
            if ((0, utils_1.verbose)())
                console.log(`No language found for file: ${fileName}`);
            splitter = new text_splitter_1.RecursiveCharacterTextSplitter();
        }
        const filePath = (0, path_1.join)(directory, fileName);
        let fileContents;
        try {
            fileContents = await (0, promises_1.readFile)(filePath, 'utf-8');
        }
        catch (error) {
            console.warn(`Error reading file ${filePath}`);
            console.warn(error);
            return;
        }
        const chunks = await splitter.createDocuments([fileContents]);
        __classPrivateFieldGet(this, _SourceIndex_indexChunks, "f").call(this, chunks, directory, fileName);
    }
}
exports.SourceIndex = SourceIndex;
_SourceIndex_insert = new WeakMap(), _SourceIndex_indexChunks = new WeakMap();
async function buildSourceIndex(indexFileName, files) {
    (0, assert_1.default)(!(0, fs_1.existsSync)(indexFileName), `Index file ${indexFileName} already exists`);
    const database = new better_sqlite3_1.default(indexFileName);
    const sourceIndex = new SourceIndex(database);
    await sourceIndex.indexFiles(files);
    console.log(`Wrote file index to ${indexFileName}`);
    return sourceIndex;
}
exports.buildSourceIndex = buildSourceIndex;
//# sourceMappingURL=SourceIndex.js.map