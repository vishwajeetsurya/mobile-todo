"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.reportMatches = exports.scoreMatches = exports.removeNonExistentMatches = void 0;
const path_1 = require("path");
const promises_1 = require("fs/promises");
const utils_1 = require("../utils");
const splitCamelized_1 = require("../lib/splitCamelized");
const console_1 = require("console");
const lunr_1 = __importDefault(require("lunr"));
const UpToDate_1 = __importDefault(require("../lib/UpToDate"));
const loadAppMapConfig_1 = __importDefault(require("../lib/loadAppMapConfig"));
const ref_1 = require("./ref");
const queryKeywords_1 = __importDefault(require("./queryKeywords"));
async function buildDocument(directory, metadataFile) {
    const metadata = JSON.parse(await (0, promises_1.readFile)(metadataFile, 'utf-8'));
    const indexDir = (0, path_1.dirname)(metadataFile);
    const classMap = JSON.parse(await (0, promises_1.readFile)((0, path_1.join)(indexDir, 'classMap.json'), 'utf-8'));
    const queries = new Array();
    const codeObjects = new Array();
    const routes = new Array();
    const externalRoutes = new Array();
    const collectFunction = (co) => {
        var _a;
        if (co.type === 'query')
            queries.push(co.name);
        else if (co.type === 'route')
            routes.push(co.name);
        else if (co.type === 'external-route')
            externalRoutes.push(co.name);
        else
            codeObjects.push(co.name);
        (_a = co.children) === null || _a === void 0 ? void 0 : _a.forEach((child) => {
            collectFunction(child);
        });
    };
    classMap.forEach((co) => collectFunction(co));
    const parameters = new Array();
    if (await (0, utils_1.exists)((0, path_1.join)(indexDir, 'canonical.parameters.json'))) {
        const canonicalParameters = JSON.parse(await (0, promises_1.readFile)((0, path_1.join)(indexDir, 'canonical.parameters.json'), 'utf-8'));
        canonicalParameters.forEach((cp) => {
            parameters.push((0, splitCamelized_1.splitCamelized)(cp));
        });
    }
    let appmapId = indexDir;
    if (appmapId.startsWith(directory))
        appmapId = appmapId.substring(directory.length + 1);
    const id = (0, ref_1.packRef)(directory, appmapId);
    return {
        id,
        name: (0, queryKeywords_1.default)(metadata.name),
        source_location: (0, queryKeywords_1.default)(metadata.source_location),
        code_objects: (0, queryKeywords_1.default)(codeObjects),
        queries: (0, queryKeywords_1.default)(queries),
        routes: (0, queryKeywords_1.default)(routes),
        external_routes: (0, queryKeywords_1.default)(externalRoutes),
        parameters: (0, queryKeywords_1.default)(parameters),
    };
}
async function buildIndex(directories) {
    var _a;
    const documents = new Array();
    if ((0, utils_1.verbose)())
        (0, console_1.log)(`[AppMapIndex] Adding AppMaps to full-text index`);
    const startTime = Date.now();
    for (const directory of directories) {
        const appmapConfig = await (0, loadAppMapConfig_1.default)((0, path_1.join)(directory, 'appmap.yml'));
        let appmapDir;
        if (appmapConfig) {
            appmapDir = (_a = appmapConfig.appmap_dir) !== null && _a !== void 0 ? _a : 'tmp/appmap';
        }
        if (!appmapDir) {
            if ((0, utils_1.verbose)())
                (0, console_1.log)(`[AppMapIndex] Skipping directory ${directory} because it does not contain an AppMap configuration`);
            continue;
        }
        await (0, utils_1.processNamedFiles)((0, path_1.join)(directory, appmapDir), 'metadata.json', async (metadataFile) => {
            documents.push(await buildDocument(directory, metadataFile));
        });
    }
    const idx = (0, lunr_1.default)(function () {
        this.ref('id');
        this.field('name');
        this.field('source_location');
        this.field('code_objects');
        this.field('queries');
        this.field('routes');
        this.field('external_routes');
        this.field('parameters');
        this.tokenizer.separator = /[\s/-_:#.]+/;
        for (const doc of documents)
            this.add(doc);
    });
    const endTime = Date.now();
    if ((0, utils_1.verbose)())
        (0, console_1.log)(`[AppMapIndex] Added ${documents.length} AppMaps to full-text index in ${endTime - startTime}ms`);
    return new AppMapIndex(directories, idx);
}
var ScoreStats;
(function (ScoreStats) {
    ScoreStats["StdDev"] = "stddev";
    ScoreStats["Mean"] = "mean";
    ScoreStats["Median"] = "median";
    ScoreStats["Max"] = "max";
})(ScoreStats || (ScoreStats = {}));
var ScoreFactors;
(function (ScoreFactors) {
    ScoreFactors["OutOfDateFactor"] = "stddev";
    ScoreFactors[ScoreFactors["OutOfDateMultipler"] = 0.5] = "OutOfDateMultipler";
})(ScoreFactors || (ScoreFactors = {}));
async function removeNonExistentMatches(matches) {
    const appmapExists = new Map();
    for (const match of matches) {
        const appmapDir = (0, ref_1.refToAppMapDir)(match.ref);
        const appmapFileName = [appmapDir, '.appmap.json'].join('');
        const doesExist = await (0, utils_1.exists)(appmapFileName);
        if (!doesExist) {
            if ((0, utils_1.verbose)())
                (0, console_1.warn)(`[AppMapIndex] AppMap ${appmapFileName} does not exist, but we got it as a search match.`);
        }
        appmapExists.set(match.ref, doesExist);
    }
    return matches.filter((match) => appmapExists.get(match.ref));
}
exports.removeNonExistentMatches = removeNonExistentMatches;
function scoreMatches(matches) {
    const scoreStats = new Map();
    if (!matches.length)
        return scoreStats;
    const numResults = matches.length;
    const maxScore = matches.reduce((acc, match) => Math.max(acc, match.score), 0);
    const medianScore = matches[Math.floor(numResults / 2)].score;
    const meanScore = matches.reduce((acc, match) => acc + match.score, 0) / numResults;
    const stddevScore = Math.sqrt(matches.reduce((acc, match) => acc + Math.pow(match.score, 2), 0) / numResults);
    if ((0, utils_1.verbose)()) {
        (0, console_1.log)(`[AppMapIndex] Score stats:`);
        (0, console_1.log)(`  Max:    ${maxScore}`);
        (0, console_1.log)(`  Median: ${medianScore}`);
        (0, console_1.log)(`  Mean:   ${meanScore}`);
        (0, console_1.log)(`  StdDev: ${stddevScore}`);
        (0, console_1.log)(`Number which are least 1 stddev above the mean: ${matches.filter((match) => match.score > meanScore + stddevScore).length}`);
        (0, console_1.log)(`Number which are at least 2 stddev above the mean: ${matches.filter((match) => match.score > meanScore + 2 * stddevScore).length}`);
        (0, console_1.log)(`Number which are at least 3 stddev above the mean: ${matches.filter((match) => match.score > meanScore + 3 * stddevScore).length}`);
    }
    scoreStats.set(ScoreStats.Max, maxScore);
    scoreStats.set(ScoreStats.Median, medianScore);
    scoreStats.set(ScoreStats.Mean, meanScore);
    scoreStats.set(ScoreStats.StdDev, stddevScore);
    return scoreStats;
}
exports.scoreMatches = scoreMatches;
async function downscoreOutOfDateMatches(scoreStats, matches, maxResults) {
    const sortedMatches = new Array();
    let i = 0;
    const finishedIterating = () => i >= matches.length;
    const matchBelowThreshold = () => {
        if (sortedMatches.length < maxResults)
            return false;
        const lastSortedMatch = sortedMatches[sortedMatches.length - 1];
        const match = matches[i];
        return match.score < lastSortedMatch.score;
    };
    const completed = () => finishedIterating() || matchBelowThreshold();
    while (!completed()) {
        const match = matches[i++];
        const downscore = scoreStats.get(ScoreStats.StdDev) * ScoreFactors.OutOfDateMultipler;
        const { directory, appmapId } = (0, ref_1.unpackRef)(match.ref);
        const upToDate = new UpToDate_1.default();
        upToDate.baseDir = directory;
        const outOfDateDependencies = await upToDate.isOutOfDate(appmapId);
        if (outOfDateDependencies) {
            if ((0, utils_1.verbose)()) {
                (0, console_1.log)(`[AppMapIndex] AppMap ${(0, ref_1.refToAppMapDir)(match.ref)} is out of date due to ${[
                    ...outOfDateDependencies,
                ]}. Downscoring by ${downscore}.`);
            }
            match.score -= downscore;
        }
        sortedMatches.push(match);
        sortedMatches.sort((a, b) => b.score - a.score);
    }
    return sortedMatches;
}
function reportMatches(matches, scoreStats, numResults) {
    const searchResults = matches.map((match) => {
        const { directory, appmapId } = (0, ref_1.unpackRef)(match.ref);
        return {
            appmap: appmapId,
            directory,
            score: match.score,
        };
    });
    return {
        type: 'appmap',
        results: searchResults,
        stats: [...scoreStats.keys()].reduce((acc, key) => {
            acc[key] = scoreStats.get(key);
            return acc;
        }, {}),
        numResults,
    };
}
exports.reportMatches = reportMatches;
class AppMapIndex {
    constructor(directories, idx) {
        this.directories = directories;
        this.idx = idx;
    }
    async search(search, options = {}) {
        let matches = this.idx.search((0, queryKeywords_1.default)(search).join(' '));
        matches = await removeNonExistentMatches(matches);
        const numResults = matches.length;
        if ((0, utils_1.verbose)())
            (0, console_1.log)(`[AppMapIndex] Got ${numResults} AppMap matches for search "${search}"`);
        const scoreStats = scoreMatches(matches);
        matches = await downscoreOutOfDateMatches(scoreStats, matches, options.maxResults || matches.length);
        if (options.maxResults && numResults > options.maxResults) {
            if ((0, utils_1.verbose)())
                (0, console_1.log)(`[FullText] Limiting to the top ${options.maxResults} matches`);
            matches = matches.slice(0, options.maxResults);
        }
        return reportMatches(matches, scoreStats, numResults);
    }
    static async search(appmapDirectories, search, options = {}) {
        const index = await buildIndex(appmapDirectories);
        return await index.search(search, options);
    }
}
exports.default = AppMapIndex;
//# sourceMappingURL=AppMapIndex.js.map