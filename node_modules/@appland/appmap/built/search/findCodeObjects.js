"use strict";
/* eslint-disable no-fallthrough */
/* eslint-disable consistent-return */
/* eslint-disable max-classes-per-file */
/* eslint-disable no-else-return */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const models_1 = require("@appland/models");
const promises_1 = require("fs/promises");
const path_1 = require("path");
const util_1 = require("util");
const utils_1 = require("../utils");
const descentCodeObjectMatcher_1 = __importDefault(require("./descentCodeObjectMatcher"));
const iterateCodeObjectMatcher_1 = __importDefault(require("./iterateCodeObjectMatcher"));
const matchSpec_1 = require("./matchSpec");
function parsePackage(functionId) {
    const packageTokens = functionId.split('/');
    return [
        // In the classMap, packages are sometimes split by '/' and appear nested.
        // Sometimes, the package name includes the '/' character, e.g. app/models,
        // as a single code object in the class map. So when searching for packages,
        // match either style. From a code standpoint, I've found this much simpler than
        // trying to handle different cases in the match spec.
        new matchSpec_1.FunctionMatchSpec([functionId], []),
        new matchSpec_1.FunctionMatchSpec(packageTokens, []),
    ];
}
function parseClass(functionId) {
    const packageTokens = functionId.split('/');
    if (packageTokens.length === 1) {
        return [];
    }
    const className = packageTokens.pop();
    const classNames = className.split('::');
    return [
        new matchSpec_1.FunctionMatchSpec([packageTokens.join('/')], classNames),
        new matchSpec_1.FunctionMatchSpec(packageTokens, classNames),
    ];
}
function parseFunction(functionId) {
    const packageTokens = functionId.split('/');
    if (packageTokens.length === 1) {
        return [];
    }
    const classAndFunction = packageTokens.length > 1 ? packageTokens.pop() : '';
    if (classAndFunction.includes('.')) {
        const [className, functionName] = classAndFunction.split('.');
        return [
            new matchSpec_1.FunctionMatchSpec([packageTokens.join('/')], className.split('::'), true, functionName),
            new matchSpec_1.FunctionMatchSpec(packageTokens, className.split('::'), true, functionName),
        ];
    }
    else if (classAndFunction.includes('#')) {
        const [className, functionName] = classAndFunction.split('#');
        return [
            new matchSpec_1.FunctionMatchSpec([packageTokens.join('/')], className.split('::'), false, functionName),
            new matchSpec_1.FunctionMatchSpec(packageTokens, className.split('::'), false, functionName),
        ];
    }
    return [];
}
function parseTable(tableName) {
    return [new matchSpec_1.TableMatchSpec(tableName)];
}
function parseHTTPServerRequest() {
    return [new matchSpec_1.HTTPServerRequestMatchSpec()];
}
function parseServerRoute(routeName) {
    return [new matchSpec_1.RouteMatchSpec(routeName)];
}
function parseExternalService() {
    return [new matchSpec_1.ExternalServiceMatchSpec()];
}
function parseExternalRoute(routeName) {
    return [new matchSpec_1.ClientRouteMatchSpec(routeName)];
}
function parseDatabase() {
    return [new matchSpec_1.DatabaseMatchSpec()];
}
function parseQuery(query) {
    return [new matchSpec_1.QueryMatchSpec(query)];
}
function buildCodeObjectMatcher(codeObjectId) {
    const tokens = codeObjectId.split(':');
    const type = tokens.shift();
    if (!type || tokens.length === 0) {
        return [];
    }
    const id = tokens.join(':');
    const isRegExpMatch = id.match(matchSpec_1.RegExpRegExp);
    if (isRegExpMatch) {
        const body = isRegExpMatch[1];
        const flags = isRegExpMatch[2];
        const pattern = new RegExp(body, flags);
        return [new iterateCodeObjectMatcher_1.default(type, pattern)];
    }
    else {
        const parsers = {
            package: parsePackage,
            class: parseClass,
            function: parseFunction,
            http: parseHTTPServerRequest,
            route: parseServerRoute,
            'external-service': parseExternalService,
            'external-route': parseExternalRoute,
            database: parseDatabase,
            query: parseQuery,
            table: parseTable,
        };
        const parser = parsers[type];
        if (!parser) {
            return [];
        }
        return parser(id).map((spec) => new descentCodeObjectMatcher_1.default(spec));
    }
}
/**
 * Find code objects and AppMaps in a directory that match search criteria.
 * Each search result consists of both the code object and the AppMap in which it was found.
 * These results can be further refined into specific events using FindEvents.
 */
class FindCodeObjects {
    constructor(appMapDir, codeObjectId) {
        this.appMapDir = appMapDir;
        this.codeObjectId = codeObjectId;
        this.matchers = buildCodeObjectMatcher(codeObjectId);
        if ((0, utils_1.verbose)()) {
            console.warn(`Searching for: ${(0, util_1.inspect)(this.matchers)}`);
        }
    }
    async find(
    // eslint-disable-next-line no-unused-vars
    fileCountFn = (_count) => { }, progressFn = () => { }) {
        // Scan classMaps to identify the AppMaps which contain the code object.
        // Scan those AppMaps for the code object events.
        // Retain the following context for each matching event:
        // * HTTP server request ancestor
        // * Parent calling function, class, and package
        // * Descendent SQL and HTTP client requests
        // Because matchers is an array, each one may return the same code object.
        const uniqueMatchIds = new Set();
        const matches = [];
        /**
         * Search a class map file for matching code objects.
         * Results are collected in +matches+.
         *
         * @param {string} fileName
         * @returns void
         */
        const checkClassMap = async (fileName) => {
            const indexDir = (0, path_1.dirname)(fileName);
            if ((0, path_1.basename)(indexDir) === 'Inventory') {
                return;
            }
            let appmapName = indexDir;
            if (indexDir.startsWith(process.cwd())) {
                appmapName = indexDir.substring(process.cwd().length + 1);
            }
            if ((0, utils_1.verbose)()) {
                console.warn(`Checking AppMap ${appmapName}`);
            }
            const buildCodeObject = (codeObject, parent) => {
                codeObject.parent = parent;
                const id = (0, models_1.codeObjectId)(codeObject).join('');
                codeObject.fqid = [codeObject.type, id].join(':');
                if (codeObject.children) {
                    codeObject.children.forEach((child) => buildCodeObject(child, codeObject));
                }
            };
            const classMap = JSON.parse(await (0, promises_1.readFile)(fileName, 'utf-8'));
            classMap.forEach((co) => buildCodeObject(co));
            this.matchers.forEach((matcher) => {
                let codeObjects;
                try {
                    codeObjects = matcher.matchClassMap(classMap);
                }
                catch (e) {
                    console.warn(e);
                    return;
                }
                for (const co of codeObjects) {
                    const matchKey = [appmapName, co.fqid].join('@');
                    if (uniqueMatchIds.has(matchKey))
                        return;
                    uniqueMatchIds.add(matchKey);
                    const match = {
                        appmap: appmapName,
                        codeObject: co,
                    };
                    if ((0, utils_1.verbose)()) {
                        console.warn(`Completed match: ${co.fqid}`);
                    }
                    matches.push(match);
                }
            });
            progressFn();
        };
        const options = new utils_1.ProcessFileOptions();
        options.fileCountFn = fileCountFn;
        await (0, utils_1.processFiles)(this.appMapDir, (file) => (0, path_1.basename)(file) === 'classMap.json', checkClassMap.bind(this), options);
        return matches;
    }
}
exports.default = FindCodeObjects;
//# sourceMappingURL=findCodeObjects.js.map