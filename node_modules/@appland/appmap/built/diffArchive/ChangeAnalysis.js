"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChangeAnalysisImpl = exports.analyzeChanges = exports.isChanged = exports.isAdded = void 0;
const promises_1 = require("fs/promises");
const path_1 = require("path");
const async_1 = require("async");
const assert_1 = __importDefault(require("assert"));
const console_1 = require("console");
const Paths_1 = require("../diffArchive/Paths");
const Digests_1 = require("../diffArchive/Digests");
const RevisionName_1 = require("../diffArchive/RevisionName");
const utils_1 = require("../utils");
const loadFindings_1 = __importDefault(require("./loadFindings"));
class ReferencedAppMaps {
    constructor() {
        this.referencedAppMaps = new Set();
    }
    add(revisionName, appmap) {
        (0, assert_1.default)(!appmap.endsWith('.appmap.json'), `AppMap ${appmap} must not have an extension`);
        this.referencedAppMaps.add((0, path_1.join)(revisionName, appmap));
    }
    test(revisionName, appmap) {
        (0, assert_1.default)(!appmap.endsWith('.appmap.json'), `AppMap ${appmap} must not have an extension`);
        return this.referencedAppMaps.has((0, path_1.join)(revisionName, appmap));
    }
}
// Gets a function that returns true if the given appmap is a test.
function isTest(revisionName, appMapMetadata) {
    return (appmap) => {
        const metadata = appMapMetadata[revisionName].get(appmap);
        return !!(metadata && metadata.recorder.type === 'tests');
    };
}
// Selects AppMaps that have stable names, and are not found in a base reference set.
function isAdded(referenceSet, isTestFn) {
    return (appmap) => isTestFn(appmap) && !referenceSet.has(appmap);
}
exports.isAdded = isAdded;
// Selects AppMaps that is present in the reference set, and have different digests.
function isChanged(referenceSet, isTestFn, digests) {
    return (appmap) => {
        const baseDigest = digests.appmapDigest(RevisionName_1.RevisionName.Base, appmap);
        const headDigest = digests.appmapDigest(RevisionName_1.RevisionName.Head, appmap);
        return (isTestFn(appmap) &&
            referenceSet.has(appmap) &&
            !!baseDigest &&
            !!headDigest &&
            baseDigest !== headDigest);
    };
}
exports.isChanged = isChanged;
async function analyzeChanges(workingDir, srcDir, baseRevision, headRevision) {
    const changeAnalysis = new ChangeAnalysisImpl(workingDir, srcDir, baseRevision, headRevision);
    await changeAnalysis.initialize();
    (0, assert_1.default)(changeAnalysis.baseManifest &&
        changeAnalysis.headManifest &&
        changeAnalysis.baseAppMaps &&
        changeAnalysis.headAppMaps &&
        changeAnalysis.appMapMetadata &&
        changeAnalysis.newAppMaps &&
        changeAnalysis.removedAppMaps &&
        changeAnalysis.changedAppMaps &&
        changeAnalysis.failedAppMaps);
    return {
        workingDir: changeAnalysis.workingDir,
        srcDir: changeAnalysis.srcDir,
        baseRevision: changeAnalysis.baseRevision,
        headRevision: changeAnalysis.headRevision,
        paths: changeAnalysis.paths,
        digests: changeAnalysis.digests,
        baseManifest: changeAnalysis.baseManifest,
        headManifest: changeAnalysis.headManifest,
        baseAppMaps: changeAnalysis.baseAppMaps,
        headAppMaps: changeAnalysis.headAppMaps,
        appMapMetadata: changeAnalysis.appMapMetadata,
        newAppMaps: changeAnalysis.newAppMaps,
        removedAppMaps: changeAnalysis.removedAppMaps,
        changedAppMaps: changeAnalysis.changedAppMaps,
        failedAppMaps: changeAnalysis.failedAppMaps,
        findingDiff: changeAnalysis.findingDiff,
        referencedAppMaps: changeAnalysis.referencedAppMaps,
    };
}
exports.analyzeChanges = analyzeChanges;
class ChangeAnalysisImpl {
    constructor(workingDir, srcDir, baseRevision, headRevision) {
        this.workingDir = workingDir;
        this.srcDir = srcDir;
        this.baseRevision = baseRevision;
        this.headRevision = headRevision;
        this.referencedAppMaps = new ReferencedAppMaps();
        this.paths = new Paths_1.Paths(workingDir);
        this.digests = new Digests_1.Digests(this.paths);
    }
    async initialize() {
        var _a;
        await this.digests.build();
        this.baseManifest = JSON.parse(await (0, promises_1.readFile)(this.paths.manifestPath(RevisionName_1.RevisionName.Base), 'utf-8'));
        this.headManifest = JSON.parse(await (0, promises_1.readFile)(this.paths.manifestPath(RevisionName_1.RevisionName.Head), 'utf-8'));
        this.baseAppMaps = new Set(await this.paths.appmaps(RevisionName_1.RevisionName.Base));
        this.headAppMaps = new Set(await this.paths.appmaps(RevisionName_1.RevisionName.Head));
        await this.loadMetadata();
        await this.loadFailedAppMaps();
        await this.loadAppMapChanges();
        if (((_a = this.failedAppMaps) === null || _a === void 0 ? void 0 : _a.size) === 0)
            await this.loadFindingDiff();
        await this.computeReferencedAppMaps();
    }
    async loadAppMapChanges() {
        const { baseAppMaps, headAppMaps, appMapMetadata } = this;
        (0, assert_1.default)(baseAppMaps && headAppMaps && appMapMetadata);
        const isNewFn = isAdded(baseAppMaps, isTest(RevisionName_1.RevisionName.Head, appMapMetadata));
        const isRemovedFn = isAdded(headAppMaps, isTest(RevisionName_1.RevisionName.Base, appMapMetadata));
        const isChangedFn = isChanged(baseAppMaps, isTest(RevisionName_1.RevisionName.Head, appMapMetadata), this.digests);
        this.newAppMaps = [...headAppMaps].filter(isNewFn);
        this.removedAppMaps = [...baseAppMaps].filter(isRemovedFn);
        this.changedAppMaps = [...headAppMaps].filter(isChangedFn);
    }
    async computeReferencedAppMaps() {
        const { appMapMetadata, failedAppMaps, findingDiff, newAppMaps, removedAppMaps, changedAppMaps, } = this;
        (0, assert_1.default)(appMapMetadata && failedAppMaps && newAppMaps && removedAppMaps && changedAppMaps);
        (0, assert_1.default)(failedAppMaps || findingDiff);
        const referenceAppMapFn = (appmap) => [RevisionName_1.RevisionName.Base, RevisionName_1.RevisionName.Head].forEach((revisionName) => this.referencedAppMaps.add(revisionName, appmap));
        const referenceFindingAppMapFn = async (revisionName, finding) => {
            const { appMapFile } = finding;
            const appmap = appMapFile.slice(0, -'.appmap.json'.length);
            const path = this.paths.appmapPath(revisionName, appmap);
            // A sanity check
            if (!(await (0, utils_1.exists)(path)))
                (0, console_1.warn)(`AppMap ${path}, referenced by finding ${finding.hash_v2}, does not exist.`);
            referenceAppMapFn(appmap);
        };
        newAppMaps.forEach((appmap) => referenceAppMapFn(appmap));
        removedAppMaps.forEach((appmap) => referenceAppMapFn(appmap));
        changedAppMaps.forEach((appmap) => referenceAppMapFn(appmap));
        failedAppMaps.forEach((appmap) => referenceAppMapFn(appmap));
        if (findingDiff) {
            for (const finding of findingDiff.new || [])
                referenceFindingAppMapFn(RevisionName_1.RevisionName.Head, finding);
            for (const finding of findingDiff.resolved || [])
                referenceFindingAppMapFn(RevisionName_1.RevisionName.Base, finding);
        }
        const sequenceDiagramExists = async (revisionName, appmap) => {
            const path = this.paths.sequenceDiagramPath(revisionName, appmap);
            return await (0, utils_1.exists)(path);
        };
        // Limit AppMap metadata to only those AppMaps that have a sequence diagram.
        for (const revisionName of [RevisionName_1.RevisionName.Base, RevisionName_1.RevisionName.Head]) {
            const metadataByPath = appMapMetadata[revisionName];
            for (const appmap of metadataByPath.keys()) {
                if (!(await sequenceDiagramExists(revisionName, appmap))) {
                    (0, console_1.warn)(`No sequence diagram found for ${revisionName} AppMap ${appmap}`);
                    metadataByPath.delete(appmap);
                }
            }
        }
    }
    async loadMetadata() {
        const appMapMetadata = {
            base: new Map(),
            head: new Map(),
        };
        const q = (0, async_1.queue)(async (appmap) => {
            const metadataPath = this.paths.metadataPath(appmap.revisionName, appmap.name);
            if (!(await (0, utils_1.exists)(metadataPath))) {
                console.warn(`Metadata file ${metadataPath} does not exist!`);
                return;
            }
            const metadata = JSON.parse(await (0, promises_1.readFile)(metadataPath, 'utf-8'));
            appMapMetadata[appmap.revisionName].set(appmap.name, metadata);
        }, 2);
        q.error(console.warn);
        for (const revisionName of [RevisionName_1.RevisionName.Base, RevisionName_1.RevisionName.Head]) {
            (await this.paths.appmaps(revisionName)).forEach((appmap) => q.push({
                revisionName: revisionName,
                name: appmap,
            }));
        }
        if (!q.idle())
            await q.drain();
        this.appMapMetadata = appMapMetadata;
    }
    async loadFailedAppMaps() {
        (0, assert_1.default)(this.appMapMetadata);
        const failedAppMaps = new Set();
        {
            for (const appmap of await this.paths.appmaps(RevisionName_1.RevisionName.Head)) {
                const metadata = this.appMapMetadata[RevisionName_1.RevisionName.Head].get(appmap);
                if (!metadata) {
                    console.warn(`Metadata for ${appmap} not found`);
                    continue;
                }
                if (metadata.test_status === 'failed')
                    failedAppMaps.add(appmap);
            }
        }
        this.failedAppMaps = failedAppMaps;
    }
    async loadFindingDiff() {
        const { baseManifest, headManifest, paths } = this;
        (0, assert_1.default)(baseManifest && headManifest && paths);
        const baseFindings = await (0, loadFindings_1.default)(paths, RevisionName_1.RevisionName.Base, baseManifest.appMapDir);
        const headFindings = await (0, loadFindings_1.default)(paths, RevisionName_1.RevisionName.Head, headManifest.appMapDir);
        let newFindings;
        let resolvedFindings;
        const baseFindingHashes = baseFindings.reduce((memo, finding) => (memo.add(finding.hash_v2), memo), new Set());
        const headFindingHashes = headFindings.reduce((memo, finding) => (memo.add(finding.hash_v2), memo), new Set());
        const newFindingHashes = [...headFindingHashes].filter((hash) => !baseFindingHashes.has(hash));
        const resolvedFindingHashes = [...baseFindingHashes].filter((hash) => !headFindingHashes.has(hash));
        newFindings = Object.values(headFindings
            .filter((finding) => newFindingHashes.includes(finding.hash_v2))
            .reduce((memo, finding) => {
            if (!(finding.hash_v2 in memo))
                memo[finding.hash_v2] = finding;
            return memo;
        }, {}));
        resolvedFindings = Object.values(baseFindings
            .filter((finding) => resolvedFindingHashes.includes(finding.hash_v2))
            .reduce((memo, finding) => {
            if (!(finding.hash_v2 in memo))
                memo[finding.hash_v2] = finding;
            return memo;
        }, {}));
        this.findingDiff = {
            new: newFindings,
            resolved: resolvedFindings,
        };
    }
}
exports.ChangeAnalysisImpl = ChangeAnalysisImpl;
//# sourceMappingURL=ChangeAnalysis.js.map