"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Digests = void 0;
const async_1 = require("async");
const RevisionName_1 = require("./RevisionName");
const SequenceDiagramDigest_1 = require("./SequenceDiagramDigest");
const utils_1 = require("../utils");
class Digests {
    constructor(paths) {
        this.paths = paths;
        // All digests for the base and head revisions.
        this.digests = {
            [RevisionName_1.RevisionName.Base]: new Set(),
            [RevisionName_1.RevisionName.Head]: new Set(),
        };
        // Index of AppMap name to digest for both revisions.
        this.appmapsByDigest = {
            [RevisionName_1.RevisionName.Base]: new Map(),
            [RevisionName_1.RevisionName.Head]: new Map(),
        };
        // Index of digest to AppMap name for both revisions.
        this.digestsByAppMap = {
            [RevisionName_1.RevisionName.Base]: new Map(),
            [RevisionName_1.RevisionName.Head]: new Map(),
        };
    }
    async build() {
        const baseAppMaps = await this.paths.appmaps(RevisionName_1.RevisionName.Base);
        const headAppMaps = await this.paths.appmaps(RevisionName_1.RevisionName.Head);
        if (baseAppMaps.length === 0 && headAppMaps.length === 0)
            return;
        const q = (0, async_1.queue)(async ({ revisionName, appmap }) => {
            if (!(await (0, utils_1.exists)(this.paths.sequenceDiagramPath(revisionName, appmap))))
                return;
            const digest = await new SequenceDiagramDigest_1.SequenceDiagramDigest(this.paths, revisionName, appmap).digest();
            this.digests[revisionName].add(digest);
            if (!this.appmapsByDigest[revisionName].has(digest))
                this.appmapsByDigest[revisionName].set(digest, new Set());
            this.appmapsByDigest[revisionName].get(digest).add(appmap);
            this.digestsByAppMap[revisionName].set(appmap, digest);
        }, 5);
        q.error(console.warn);
        baseAppMaps.forEach((appmap) => q.push({ revisionName: RevisionName_1.RevisionName.Base, appmap }));
        headAppMaps.forEach((appmap) => q.push({ revisionName: RevisionName_1.RevisionName.Head, appmap }));
        if (q.length())
            await q.drain();
    }
    appmapDigest(revisionName, appmap) {
        return this.digestsByAppMap[revisionName].get(appmap);
    }
}
exports.Digests = Digests;
//# sourceMappingURL=Digests.js.map