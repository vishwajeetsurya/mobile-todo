"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceDiffQueue = exports.MAX_DIFF_LENGTH = void 0;
const parse_diff_1 = __importDefault(require("parse-diff"));
const console_1 = require("console");
const assert_1 = __importDefault(require("assert"));
const executeCommand_1 = require("../lib/executeCommand");
const async_1 = require("async");
const fs_1 = require("fs");
exports.MAX_DIFF_LENGTH = 1000 * 1000;
class SourceDiffQueue {
    constructor(baseRevision, headRevision) {
        this.baseRevision = baseRevision;
        this.headRevision = headRevision;
        this.diffByRoots = new Map();
        this.diffQueue = (0, async_1.queue)(this.executeDiffCommand.bind(this), 1);
    }
    async diff(sourcePathRoots) {
        // Process only one diff at a time.
        if (this.diffQueue.length())
            await this.diffQueue.drain();
        const roots = [...sourcePathRoots].sort().join(' ');
        this.diffQueue.push(roots);
        await this.diffQueue.drain();
        return this.diffByRoots.get(roots);
    }
    async executeDiffCommand(roots) {
        if (roots === '')
            return;
        if (this.diffByRoots.get(roots))
            return;
        const command = `git diff ${this.baseRevision}..${this.headRevision} -- ${roots}`;
        let diff = { command, files: [] };
        try {
            const diffStr = await (0, executeCommand_1.executeCommand)(command, true);
            if (diffStr.length > exports.MAX_DIFF_LENGTH) {
                (0, console_1.warn)(`Diff is too large to parse. Skipping...`);
            }
            else {
                const files = (0, parse_diff_1.default)(diffStr);
                diff = { command, files };
            }
        }
        catch (err) {
            // There's no point in trying this command again.
            (0, console_1.warn)(err);
        }
        finally {
            this.diffByRoots.set(roots, diff);
        }
    }
}
exports.SourceDiffQueue = SourceDiffQueue;
class SourceDiff {
    constructor(baseRevision, headRevision) {
        this.baseRevision = baseRevision;
        this.headRevision = headRevision;
        this.sourcePathRoots = new Set();
        this.diffLoaderQueue = new SourceDiffQueue(baseRevision, headRevision);
    }
    lookupDiff(path) {
        if (!this.diffByFile)
            return;
        const diff = this.diffByFile.get(path);
        if (!diff)
            return;
        const { files: diffFiles } = diff;
        const content = diffFiles
            .map((diffFile) => {
            const fromLine = ['---', diffFile.from].join(' ');
            const toLine = ['+++', diffFile.to].join(' ');
            const content = diffFile.chunks
                .map((chunk) => [chunk.content, chunk.changes.map((change) => change.content).join('\n')].join('\n'))
                .join('\n');
            return [fromLine, toLine, content, ''].join('\n');
        })
            .join('\n');
        return [content].join('\n');
    }
    async update(sourcePathRoots) {
        const diffRoots = new Set();
        for (const root of sourcePathRoots) {
            if (!this.sourcePathRoots.has(root)) {
                this.sourcePathRoots.add(root);
                if (SourceDiff.isEligibleFile(root))
                    diffRoots.add(root);
            }
        }
        const diff = await this.diffLoaderQueue.diff(diffRoots);
        if (diff)
            this.parseDiffStr(diff);
    }
    static isEligibleFile(root) {
        return !['vendor', 'node_modules'].includes(root) && (0, fs_1.existsSync)(root);
    }
    parseDiffStr(diff) {
        if (!this.diffByFile)
            this.diffByFile = new Map();
        diff.files.reduce((memo, diffFile) => {
            [...new Set([diffFile.to, diffFile.from])]
                .filter(Boolean)
                .sort()
                .forEach((path) => {
                (0, assert_1.default)(path);
                if (!memo.has(path))
                    memo.set(path, { command: diff.command, files: [] });
                memo.get(path).files.push(diffFile);
            });
            return memo;
        }, this.diffByFile);
    }
}
exports.default = SourceDiff;
//# sourceMappingURL=SourceDiff.js.map