"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const promises_1 = require("node:fs/promises");
const utils_1 = require("../utils");
const node_path_1 = require("node:path");
const node_assert_1 = __importDefault(require("node:assert"));
// Gets the file path of a location. Location may include a line number or other info
// in addition to the file path.
const parseFilePath = (location) => location.split(':')[0];
class FileAppMapIndex {
    async updatedAt(appmapName) {
        let appmapUpdatedAtStr;
        try {
            appmapUpdatedAtStr = await (0, promises_1.readFile)((0, node_path_1.join)(appmapName, 'mtime'), 'utf-8');
        }
        catch (err) {
            if (!(0, utils_1.isCodedError)(err))
                console.warn(err);
            if ((0, utils_1.isCodedError)(err) && err.code !== 'ENOENT')
                console.warn(err);
            return;
        }
        return parseFloat(appmapUpdatedAtStr);
    }
    async classMap(appmapName) {
        return JSON.parse(await (0, promises_1.readFile)((0, node_path_1.join)(appmapName, 'classMap.json'), 'utf-8'));
    }
}
class UpToDate {
    constructor() {
        this.appMapIndex = new FileAppMapIndex();
        this.mtime = utils_1.mtime;
        this.mtimes = new Map();
        this.mtimeLookupCount = 0;
        this.mtimeCacheHits = 0;
    }
    async isOutOfDate(appmapName) {
        (0, node_assert_1.default)(!appmapName.endsWith('.appmap.json'), 'appmapName should not end with .appmap.json');
        const appmapUpdatedAt = await this.appMapIndex.updatedAt(appmapName);
        if (appmapUpdatedAt === undefined) {
            if ((0, utils_1.verbose)())
                console.warn(`[UpToDate] Update time for ${appmapName} cannot be determined`);
            return;
        }
        if ((0, utils_1.verbose)()) {
            console.log(`[UpToDate] Checking AppMap ${appmapName} with timestamp ${appmapUpdatedAt}`);
        }
        const outOfDateNames = new Set();
        const reportOutOfDate = (filePath) => {
            if ((0, utils_1.verbose)())
                console.log(`[UpToDate] ${filePath} requires rebuild of AppMap ${appmapName}`);
            outOfDateNames.add(filePath);
        };
        const classMap = await this.appMapIndex.classMap(appmapName);
        const codeLocations = new Set();
        const collectFilePaths = (classEntry) => {
            if (classEntry.location) {
                const filePath = parseFilePath(classEntry.location);
                codeLocations.add(filePath);
            }
            if (classEntry.children)
                classEntry.children.forEach(collectFilePaths);
        };
        classMap.forEach(collectFilePaths);
        const modifiedTime = async (sourceFilePath) => {
            const result = this.mtimes.get(sourceFilePath);
            if (result || result === false) {
                this.mtimeCacheHits++;
                return result;
            }
            // Eleswhere, we are dealing with logical file names. But here, we need to resolve
            // the file path to the actual file system path.
            const resolvedFilePath = this.resolveFilePath(sourceFilePath);
            const dependencyModifiedAt = (await this.mtime(resolvedFilePath)) || false;
            this.mtimeLookupCount++;
            if (dependencyModifiedAt === false && (0, utils_1.verbose)())
                console.log(`[UpToDate] ${sourceFilePath} does not exist`);
            this.mtimes.set(sourceFilePath, dependencyModifiedAt);
            return dependencyModifiedAt;
        };
        const isFileModifiedSince = async (sourceFilePath) => {
            const dependencyModifiedAt = await modifiedTime(sourceFilePath);
            if (dependencyModifiedAt === false)
                return dependencyModifiedAt;
            const outOfDate = appmapUpdatedAt < dependencyModifiedAt;
            if (outOfDate && (0, utils_1.verbose)()) {
                console.log(`[UpToDate] ${appmapName} (${appmapUpdatedAt}) is NOT up to date with ${sourceFilePath} (${dependencyModifiedAt})`);
            }
            return outOfDate;
        };
        const test = this.testFunction || isFileModifiedSince;
        await Promise.all([...codeLocations].map(async (sourceFilePath) => {
            if (await test(sourceFilePath)) {
                if ((0, utils_1.verbose)())
                    console.debug(`[UpToDate] ${appmapName} is out of date due to ${sourceFilePath}`);
                reportOutOfDate(sourceFilePath);
            }
        }));
        return outOfDateNames.size > 0 ? outOfDateNames : undefined;
    }
    /**
     * Prepend the baseDir to filePath, unless filePath is absolute.
     *
     * @param {string} filePath
     * @returns string
     */
    resolveFilePath(filePath) {
        if (!this.baseDir)
            return filePath;
        if ((0, node_path_1.isAbsolute)(filePath))
            return filePath;
        return (0, node_path_1.join)(this.baseDir, filePath);
    }
}
exports.default = UpToDate;
//# sourceMappingURL=UpToDate.js.map