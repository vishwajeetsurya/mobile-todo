"use strict";
// Direct from the Node.js docs
// https://nodejs.org/api/async_context.html#using-asyncresource-for-a-worker-thread-pool
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_ADD_WORKER_DELAY = void 0;
const async_hooks_1 = require("async_hooks");
const events_1 = require("events");
const worker_threads_1 = require("worker_threads");
const assert_1 = __importDefault(require("assert"));
const console_1 = require("console");
const utils_1 = require("../utils");
const kTaskInfo = Symbol('kTaskInfo');
const kWorkerFreedEvent = Symbol('kWorkerFreedEvent');
class WorkerPoolTaskInfo extends async_hooks_1.AsyncResource {
    constructor(callback) {
        super('WorkerPoolTaskInfo');
        this.callback = callback;
    }
    done(err, result) {
        this.runInAsyncScope(this.callback, null, err, result);
        this.emitDestroy(); // `TaskInfo`s are used only once.
    }
}
exports.DEFAULT_ADD_WORKER_DELAY = 5000;
class WorkerPool extends events_1.EventEmitter {
    constructor(taskFile, numThreads, addWorkerDelay = exports.DEFAULT_ADD_WORKER_DELAY) {
        super();
        this.taskFile = taskFile;
        this.numThreads = numThreads;
        this.addWorkerDelay = addWorkerDelay;
        this.workers = [];
        this.freeWorkers = [];
        this.tasks = [];
        this.workerInfoByThreadId = new Map();
        this.addNewWorker();
        if (numThreads > 1)
            this.addNewWorker();
        if (numThreads > 2) {
            this.addWorkerInterval = setInterval(() => {
                this.addNewWorker();
                if (this.addWorkerInterval && this.workers.length === numThreads)
                    clearInterval(this.addWorkerInterval);
            }, addWorkerDelay);
            this.addWorkerInterval.unref();
        }
        const nextTask = () => {
            const task = this.tasks.shift();
            (0, assert_1.default)(task);
            return task;
        };
        // Any time the kWorkerFreedEvent is emitted, dispatch
        // the next task pending in the queue, if any.
        this.on(kWorkerFreedEvent, () => {
            if (this.tasks.length > 0) {
                const { task, callback } = nextTask();
                this.runTask(task, callback);
            }
        });
    }
    runTask(task, callback) {
        if (this.freeWorkers.length === 0) {
            // No free threads, wait until a worker thread becomes free.
            this.tasks.push({ task, callback });
            return;
        }
        const worker = this.freeWorkers.pop();
        (0, assert_1.default)(worker);
        worker[kTaskInfo] = new WorkerPoolTaskInfo(callback);
        if ((0, utils_1.verbose)())
            (0, console_1.warn)(`Assigning ${JSON.stringify(task)} to worker thread ${worker.threadId}`);
        worker.postMessage(task);
    }
    async close() {
        if (this.addWorkerInterval)
            clearInterval(this.addWorkerInterval);
        // Average time between worker creation and first task assignment
        const averageTimeToFirstTask = Array.from(this.workerInfoByThreadId.values())
            .filter((info) => info.firstTask)
            .map((info) => info.firstTask.getTime() - info.created.getTime())
            .reduce((sum, time) => sum + time, 0) / this.workerInfoByThreadId.size;
        if ((0, utils_1.verbose)())
            (0, console_1.warn)(`Worker average time to first task completion: ${averageTimeToFirstTask}ms`);
        for (const worker of this.workers)
            await worker.terminate();
    }
    enrollWorker(worker) {
        this.workerInfoByThreadId.set(worker.threadId, {
            created: new Date(),
        });
    }
    workerTask(worker) {
        if (this.workerInfoByThreadId.get(worker.threadId).firstTask)
            return;
        this.workerInfoByThreadId.get(worker.threadId).firstTask = new Date();
    }
    addNewWorker() {
        if ((0, utils_1.verbose)())
            (0, console_1.warn)(`Adding new worker thread`);
        const worker = new worker_threads_1.Worker(this.taskFile);
        this.enrollWorker(worker);
        worker.on('message', (result) => {
            // In case of success: Call the callback that was passed to `runTask`,
            // remove the `TaskInfo` associated with the Worker, and mark it as free
            // again.
            if ((0, utils_1.verbose)())
                (0, console_1.warn)(`Worker thread ${worker.threadId} finished task`);
            this.workerTask(worker);
            worker[kTaskInfo].done(null, result);
            worker[kTaskInfo] = null;
            this.freeWorkers.push(worker);
            this.emit(kWorkerFreedEvent);
        });
        worker.on('error', (err) => {
            (0, console_1.warn)(`Uncaught exception in worker thread: ${err}`);
            (0, console_1.warn)(`This worker thread will be terminated and a new one launched in its place - which is expensive!`);
            // In case of an uncaught exception: Call the callback that was passed to
            // `runTask` with the error.
            if (worker[kTaskInfo])
                worker[kTaskInfo].done(err, null);
            else
                this.emit('error', err);
            // Remove the worker from the list and start a new Worker to replace the
            // current one.
            this.workers.splice(this.workers.indexOf(worker), 1);
            worker.unref();
            this.addNewWorker();
        });
        this.workers.push(worker);
        this.freeWorkers.push(worker);
        this.emit(kWorkerFreedEvent);
    }
}
exports.default = WorkerPool;
//# sourceMappingURL=workerPool.js.map