"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findRepository = void 0;
const gitconfiglocal_1 = __importDefault(require("gitconfiglocal"));
const node_assert_1 = __importDefault(require("node:assert"));
const node_url_1 = require("node:url");
const util_1 = require("util");
// Attempt to parse special syntax allowed by git:
// - scp-style urls ([user@]host.xz:path/to/repo.git/),
// - bare file paths.
function parseSpecial(url) {
    // From git-push(1):
    // > This syntax is only recognized if there are no slashes before the first colon.
    // > This helps differentiate a local path that contains a colon.
    // Note {2,} is to avoid recognizing d:/windows style paths.
    if (url.match(/^[^/]{2,}:/))
        return new URL('ssh://' + url.replace(':', '/'));
    else
        return (0, node_url_1.pathToFileURL)(url);
}
// Utility type. This is just so the type system can
// verify we're not leaking unsanitized uris anywhere.
class SanitizedUri {
    constructor(uri) {
        try {
            this.uri = new URL(uri);
        }
        catch (err) {
            (0, node_assert_1.default)(util_1.types.isNativeError(err));
            if (err.name === 'TypeError') {
                const special = parseSpecial(uri);
                if (!special)
                    throw err;
                this.uri = special;
            }
            else
                throw err;
        }
        this.uri.username = '';
        this.uri.password = '';
    }
    toString() {
        return this.uri.toString();
    }
}
function hasUrl(remote) {
    return remote === null || remote === void 0 ? void 0 : remote['url'];
}
async function findAndSanitizeRepository(dir) {
    try {
        const config = await (0, util_1.promisify)(gitconfiglocal_1.default)(dir);
        const remote = config.remote;
        if (!remote || typeof remote !== 'object')
            return;
        const origin = remote['origin'];
        if (hasUrl(origin))
            return new SanitizedUri(origin.url);
        const first = Object.values(remote).find(hasUrl);
        if (!first)
            return;
        return new SanitizedUri(first.url);
    }
    catch (err) {
        (0, node_assert_1.default)(util_1.types.isNativeError(err));
        if (err.message.includes('no gitconfig'))
            return;
        throw err;
    }
}
async function findRepository(dir) {
    var _a;
    return (_a = (await findAndSanitizeRepository(dir))) === null || _a === void 0 ? void 0 : _a.toString();
}
exports.findRepository = findRepository;
//# sourceMappingURL=git.js.map