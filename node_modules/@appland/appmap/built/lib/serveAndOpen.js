"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.serveAndOpenAppMap = exports.serveAndOpenSequenceDiagram = void 0;
const fs_1 = require("fs");
const http_1 = require("http");
const open_1 = __importDefault(require("open"));
const path_1 = require("path");
const url_1 = require("url");
const utils_1 = require("../utils");
const userInteraction_1 = __importDefault(require("../cmds/userInteraction"));
function mimeTypeOfName(filename) {
    return ({
        js: 'application/javascript',
        css: 'text/css',
        json: 'application/json',
        map: 'application/json',
    }[(0, path_1.extname)(filename)] || 'application/octet-stream');
}
async function serveAndOpen(file, resources, verifyInSubdir, onListen) {
    userInteraction_1.default.progress(`Opening ${file}`);
    const baseDir = (0, path_1.join)(__dirname, '..', '..', 'built', 'html');
    if (!(await (0, utils_1.exists)((0, path_1.join)(baseDir, file))))
        throw new Error(`File ${file} does not exist`);
    const server = (0, http_1.createServer)(async (req, res) => {
        const send404 = () => {
            res.writeHead(404);
            res.end();
        };
        const serveStaticFile = (dir, fileName, contentType) => {
            const path = (0, path_1.isAbsolute)(fileName) ? fileName : (0, path_1.join)(dir, fileName);
            if (verifyInSubdir && !path.startsWith(dir))
                return send404();
            if (!contentType)
                contentType = mimeTypeOfName(fileName);
            const fileStream = (0, fs_1.createReadStream)(path);
            fileStream.pipe(res);
            fileStream.on('open', function () {
                if ((0, utils_1.verbose)()) {
                    console.log(`${path}: 200`);
                }
                res.writeHead(200, 'OK', { 'Content-Type': contentType });
            });
            fileStream.on('error', function (e) {
                if ((0, utils_1.verbose)()) {
                    console.log(`${path}: 404 (${e})`);
                }
                send404();
            });
        };
        try {
            if ((0, utils_1.verbose)()) {
                console.log(req.url);
            }
            const requestUrl = (0, url_1.parse)(req.url);
            const pathname = requestUrl.pathname;
            if (pathname === '/') {
                return serveStaticFile(baseDir, file, 'text/html');
            }
            else if (pathname === null || pathname === void 0 ? void 0 : pathname.startsWith('/resource')) {
                const pathname = requestUrl.query;
                if (pathname)
                    serveStaticFile(process.cwd(), decodeURIComponent(pathname));
                else
                    send404();
            }
            else {
                serveStaticFile(baseDir, (pathname || '/').slice(1));
            }
        }
        catch (e) {
            console.log(e.stack);
            res.writeHead(500);
            res.end(); // end the response so browsers don't hang
        }
    })
        .listen(0, '127.0.0.1', () => {
        const port = server.address().port;
        const params = new URLSearchParams();
        for (const [key, value] of Object.entries(resources)) {
            params.append(key, value);
        }
        const url = new URL(`http://localhost:${port}/?${params.toString()}`);
        onListen(url.toString());
    })
        .on('connection', function (socket) {
        // Don't let the open socket keep the process alive.
        socket.unref();
    })
        .unref();
}
exports.default = serveAndOpen;
async function serveAndOpenSequenceDiagram(diagramFile, verifyInSubdir, onListen) {
    return new Promise((resolve) => {
        serveAndOpen('sequenceDiagram.html', {
            diagram: ['resource', encodeURIComponent(diagramFile)].join('?'),
        }, verifyInSubdir, async (url) => {
            onListen(url);
            resolve(url);
        });
    });
}
exports.serveAndOpenSequenceDiagram = serveAndOpenSequenceDiagram;
async function serveAndOpenAppMap(appMapFile, verifyInSubdir) {
    return new Promise((resolve) => {
        serveAndOpen('appmap.html', {
            appmap: ['resource', encodeURIComponent(appMapFile)].join('?'),
        }, verifyInSubdir, async (url) => {
            await tryOpen(url);
            resolve(url);
        });
    });
}
exports.serveAndOpenAppMap = serveAndOpenAppMap;
async function tryOpen(url) {
    const showMessage = () => userInteraction_1.default.warn(`\nWe could not open the browser automatically.\nOpen ${url} to view the content.\n`);
    const cp = await (0, open_1.default)(url);
    cp.once('error', showMessage);
    cp.once('exit', (code, signal) => (code || signal) && showMessage());
}
//# sourceMappingURL=serveAndOpen.js.map