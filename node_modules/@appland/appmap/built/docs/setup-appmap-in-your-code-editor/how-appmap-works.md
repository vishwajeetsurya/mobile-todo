---
layout: docs
setup-appmap-ide: true
title: Docs - AppMap in your Code Editor
description: "Learn how AppMap works: recording agents for Java, Python, Ruby, and Node.js, configuration, recording methods, AppMap files, running in containers, and viewing AppMap Diagrams."
step: 1
name: How AppMap Works
redirect_from: [/docs/your-first-15-minutes-with-appmap/what-is-appmap,/docs/your-first-15-minutes-with-appmap/ideal-projects,/docs/your-first-15-minutes-with-appmap/appmap-analysis,/docs/guides/how-appmap-works]
---

# How AppMap Works

- [Language "agent"](#language-agent)
- [appmap.yml configuration](#appmapyml-configuration)
- [Recording methods](#recording-methods)
- [About AppMap files](#about-appmap-files)
- [Running in containers](#running-in-containers)
- [Viewing AppMap Diagrams](#viewing-appmap-diagrams)

## Language “agent”

The AppMap process begins with the AppMap recording agent. This “agent” is a language-specific library - agents are available for Java, Python, Ruby and Node.js (Beta). You add the agent as a dependency of your project in the normal manner - via Maven, Gradle, Pip, Bundler, Yarn, etc. Then you configure your application to load the agent when the application runs. 


<table class="table table-striped table-bordered">
    <tr>
        <th>Java</th>
        <th>Python</th>
        <th>Ruby</th>
        <th>Node.js</th>
    </tr>
    <tr>
        <td><code>-javaagent</code> JVM option </td>
        <td>Django environment </td>
        <td><code>test</code> and/or <code>development</code> bundle</td>
        <td><code>npx appmap-node <i>yourapp</i></code></td> 
    </tr>
    <tr>
        <td>Gradle plugin</td>
        <td>Flask environment </td>
        <td></td>
        <td></td> 
    </tr>
        <tr>
        <td>Maven plugin</td>
        <td></td>
        <td></td>
        <td></td> 
    </tr>
</table>



_Running application code with the AppMap agent enabled_

AppMap is designed to record and display the code internals of your project, along with important I/O operations. Here’s a comparison of AppMap with other runtime code tools:

<table class="table table-striped table-bordered">
    <tr>
        <th></th>
        <th>AppMap </th>
        <th>Profiler</th>
        <th>Exception reporter</th>
        <th>Debugger</th>
        <th>APM / Telemetry</th>
    </tr>
    <tr>
        <td>Primary focus</td>
        <td>Your code<br> Parameters and return values<br> I/O<br> Log statements<br> Execution stack<br> Timing data<br> Exceptions</td>
        <td>All code (your code + dependencies)<br> Execution stack<br> Timing data</td>
        <td>Exceptions<br> Execution stack </td>
        <td>All code<br> Parameters and return values<br> Execution stack<br> Exceptions</td>
        <td>I/O<br> Log statements<br> Timing data<br> Your code (limited)</td>
    </tr>
    <tr>
        <td>Environment</td>
        <td>development, test, staging, CI</td>
        <td>development, staging </td>
        <td>staging, production</td>
        <td>development</td>
        <td>production</td>
    </tr>
</table>


To summarize, AppMap is designed primarily to record _full details of your code_, including _parameters and return values_, as well as _I/O_ (especially _SQL_ and _HTTP client requests_), it includes _log statements_, the _execution stack_, _timing information_, and _exceptions_. It captures all of this with minimal configuration. It’s designed primarily for non-production environments.

## appmap.yml configuration
When you start your app with the AppMap agent enabled, it reads a configuration file called appmap.yml. This file serves several basic purposes. It tells the AppMap agent:

* Which code to record
* Where to write the AppMap Data.

And it also tells other AppMap tools:
* The project name
* The language name
* Where the AppMap Data is located

**Note:** In most environments, a default appmap.yml will be auto-generated by the AppMap agent if none exists.

### Specifying which code to record
To get started, you just provide the top-level package names or directories containing the code you want to record. For a non-compiled language like Ruby, Python, or Node.js, it’s a directory list like `[ app]` or `[ src, lib ]`. For Java, it’s a package prefix like `org.mycorp`. 

Going beyond this basic, initial configuration, you have fine-grained control over which code to record. You can choose to record selected dependency libraries or packages. You can also include or exclude specific packages, classes and/or functions. And you can apply custom “labels” to any function, in order to organize the code into functional groups and to facilitate reasoning and analysis.

## Recording methods
The AppMap agent can be enabled in any environment, and configured to record selected code. There are several variants of this basic model that are commonly used to acquire AppMap Data for specific use cases.

### Test case recording
AppMap provides specialized support for recording test cases. When you run your test cases in a supported framework (there are many - see the [language agent reference](/docs/reference) for details), a separate AppMap Diagram is created for each test case. AppMap Diagrams created from tests cases have some distinct features:

* Each AppMap file is named for the test case, and stored in a folder called `$appmap_dir/$test_framework`
* The test framework name and version are stored in the AppMap.
* The test case name, file name and line number are stored in the AppMap.
* The test status (`succeeded` or `failed`) and any test failure message are stored in the AppMap.

Recording the test suite of an application is a good way to quickly obtain a lot of data about an application. And because test cases work the same way for each build, recording test cases is also a good way to compare the behavior of application code across versions.

### Requests recording
For web applications, AppMap can be configured to record an AppMap for each HTTP server request handled by the app. This is a great way to collect data interactively. Just start the application with the AppMap language agent enabled, and start interacting with the app - manually, or using QA scripts or an API testing tool like Postman. AppMap Data is generated continuously as the application handles requests.

### Remote recording
Remote recording is similar to requests recording, in that:
* It’s for web applications
* It makes AppMap Data as the application handles requests

But unlike requests recording, you control the boundaries of the AppMap, each AppMap can contain more than one HTTP server request, and it will also contain non-HTTP activity such as background jobs. To start a remote recording, you send an HTTP command to the AppMap agent running inside your application’s web stack to start recording. From that point on, everything that happens inside the application is recorded, until you send the “stop” command.

### Code block recording
Some language agents enable you to make an AppMap by adding a simple code snippet to your code. This gives you total control over what’s recorded. The only downside of this is that you need access to the source code - which is not required by other recording methods.

### Process recording
Process recording is something of a last resort, when other recording methods aren’t available. When you run your application with process recording enabled, _everything_ that happens in the code (as configured by the appmap.yml) is recorded, from process startup to shutdown. 

## About AppMap files
AppMap Data is ordinary JSON files. As you record AppMap Data with test case recording, requests recording, or process recording, these JSON files are generated and written to the filesystem. The default location for AppMap Data is `tmp/appmap`, relative to the process working directory. Be sure that you know that the working directory of the application server is! You’ll need to know this to find and open your AppMap Diagrams.

When you use remote recording, the HTTP “stop” command responds with the AppMap in the response payload. It’s up to the client to decide where to write the file. For example, you can start and stop a remote recording using cURL, and write the output of the “stop” command to a file of your choosing. 

When you use code block recording, it’s up to you in your code snippet to write the AppMap to a file. Naturally, you can direct the data anywhere you please.

AppMap files conform to the [AppMap specification](https://github.com/getappmap/appmap), which is freely available on GitHub. 

## Running in containers
You can make AppMap Data while running your application in a container. From the AppMap standpoint, there is really no difference between running in a container and running in any other environment. There are just a couple of basic considerations:
* The AppMap file will be written to the filesystem of the container. To make it available to the host, you should either use a volume mount to the `$appmap_dir` (typically, `tmp/appmap`), or copy the AppMap Data out of the container after the recording is complete.
* If you are using remote recording, your application web port should be exposed to the host, so that you can send the HTTP start and stop commands. You’ll need this anyway, in order to access your application’s web UI or API from the host.

## Viewing AppMap Diagrams
AppMap includes open-source UI tools to display AppMap Data as visual diagrams. Built-in diagrams include:

* Dependency map
* Sequence diagram
* Trace view
* Flame graph

These diagrams are integrated together in the AppMap UI, and fully interactive. The data can be organized, selected, and filtered by the user. This makes the user interface much better suited for code investigation than a static diagram image. It’s also much more scalable, because the diagrams can be tuned to reveal specific information and hide extraneous data.

### IDE extensions
The AppMap extensions for VSCode and JetBrains include a file association for AppMap Data. Just click on an AppMap file, and it will be opened graphically in the code editor. The diagram is fully linked to source code within the IDE.

### Hosting an AppMap viewer
The AppMap Diagrams are published as an open source library on [NPM](https://www.npmjs.com/package/@appland/appmap). If you want to provide a centralized service to open AppMap Diagrams in the browser, you can just serve [appmap.html](https://www.npmjs.com/package/@appland/appmap?activeTab=code) from any web server. Provide a URL to the AppMap Data using the `appmap` parameter - for example: `http://myappmapserver/appmap.html?appmap=https://<appmap-url>`.

### Exporting AppMap Data
The AppMap sequence diagram can be exported to SVG or PlantUML. Consult the [diagrams reference](/docs/guides/using-appmap-diagrams.html#sequence-diagram) for details.
